#include <30F4011.h>
#DEVICE ADC=10
#device ICSP=1
#use delay(clock=64000000,crystal=8000000)
#use rs232(UART2, baud=9600, stream=UART_PORT2)

#FUSES NOWDT                    //No Watch Dog Timer
#FUSES CKSFSM                   //Clock Switching is enabled, fail Safe clock monitor is enabled
#FUSES BORV42                   //Brownout reset at 4.5V
#FUSES WRT                      //Program Memory Write Protected
#FUSES PROTECT                  //Code protected from reads
#include <math.h>


#define P1TCON 0x01C0
#define P1TMR 0x01C2 
#define P1TPER 0x01C4
#define P1SECMP 0x01C6
#define PWM1CON1 0x01C8 
#define PWM1CON2 0x01CA
#define P1DTCON1 0x01CC
#define P1DTCON2 0x01CE  
#define P1FLTACON 0x01D0
#define P1OVDCON 0x01D4   
#define P1DC1 0x01D6   
#define P1DC2 0x01D8
#define P1DC3 0x01DA
#define IPC14 0x00C0  
#define CLKDIV 0x0744 
#define PLLFBD 0x0746


#define ADC_pin sAN0
#define LED_PIN PIN_B5

#define voltage_offset 1000//1248
#define low_duty_limit 50
#define high_duty_limit 1950
#define SLOPE 0
//! #define SLOPE 6.2
#define break_level 5
#define sustain_level 200  
#define break_amplitude 0 
//!#define pedestal_amplitude 85
#define pedestal_amplitude 500
#define peak_amplitude 950


#define throttle_PIN PIN_B1
#define PWM_tick_pin PIN_B2
#define TIM_tick_pin PIN_B3

#define kalman_up 18
#define kalman_diff_down 8

#define init_freq 30

  
  
void initMCPWM(void);
void fill_sine_table(void);  
void timer_reload(void);
void voltage_gain(void); 


unsigned int16 duty[3]={voltage_offset,voltage_offset,voltage_offset},sample=0;
signed int16 peak_voltage =0;//  1184; 
signed int32 reference[3] = {0,0,0};

const unsigned max_samples=30.0;
signed int16 sine_table[max_samples];
unsigned int16 sine_index,phase_angle[3] = {0 , 0 , 0};  
double theeta;

const unsigned max_freq = 250; //Hz
//!const double per_clock_tick = 0.006405; //ms
//!const double per_clock_tick = 0.007996; //ms
const double per_clock_tick = 0.004; //ms
//!unsigned int16 timer_table[max_freq+1];


unsigned int16 raw_adc =0 ;
signed int16 throttle_level = 0;
unsigned int16 freq = 1;
unsigned int16 temp = 0;

int1 tick = 0;
int1 uart_tick = 0;
int8 tick_count = 0;
unsigned long millis_count = 0;

char Serial_OutputBuffer[60];

signed int32 kalman_big_1=0, kalman_big_2=0, kalman_diff=0;

//!const int timer_table[] = {
//!1041,1041,1041,1041,1041,1041,1041,1041,925,833,757,694,641,595,555,520,490,462,438,416,396,378,362,347,333,320,308,297,287,277,268,260,252,245,238,231,
//!225,219,213,208,203,198,193,189,185,181,177,173,170,166,163,160,157,154,151,148,146,143,141,138,136,134,132,130,128,126,124,122,120,
//!119,117,115,114,112,111,109,108,106,105,104,102,101,100,99,98,96,95,94,93,92,91,90,89,88,87,86,85,85,84,83,82,81,80,80,79,78,77,77,
//!76,75,75,74,73,73,72,71,71,70,7070,68,68,67,67,66,66,66,65,64,64,63,63,62,62,61,61,60,60,60,59,59,58,58,57,57,57,56,56,56,55,55,55,
//!54,54,53,53,53,52,52,52,51,51,51,51,50,50,50,49,49,49,49,48,48,47,47,47,47,46,46,46,46,45,45,45,45,44,44,44,44,43,43,43,43,43,42,42,
//!42,42,41,41,41,41,41,40,40,40,40,40,39,39,39,39,39,38,38,38,38,38,38,37,37,37,37,37,37,37,37,36,36,36,36,36,36,35,35,35,35,35,35,34,
//!34,34,34,34,34,33,33,33,33,33
//!};
//!

const int timer_table[] = { 
1036,
1036,
1036,
1036,
1036,
1036,
1036,
1036,
1036,
1036,
1036,
1036,
1036,
1036,
1036,
1036,
1036,
1036,
1036,
1036,
1036,
1021,
1006,
992,
978,
964,
950,
936,
923,
910,
897,
884,
871,
859,
847,
835,
823,
811,
799,
788,
777,
766,
755,
744,
733,
723,
713,
703,
693,
683,
673,
663,
654,
645,
636,
627,
618,
609,
600,
591,
583,
575,
567,
559,
551,
543,
535,
527,
519,
512,
505,
498,
491,
484,
477,
470,
463,
456,
449,
443,
437,
431,
425,
419,
413,
407,
401,
395,
389,
383,
378,
373,
368,
363,
358,
353,
348,
343,
338,
333,
328,
323,
318,
313,
309,
305,
301,
297,
293,
289,
285,
281,
277,
273,
269,
265,
261,
257,
253,
249,
245,
241,
238,
235,
232,
229,
226,
223,
220,
217,
214,
211,
208,
205,
202,
199,
196,
193,
190,
187,
184,
181,
178,
175,
172,
170,
168,
166,
164,
162,
160,
158,
156,
154,
152,
150,
148,
146,
144,
142,
140,
138,
136,
134,
132,
130,
128,
126,
124,
122,
120,
118,
116,
114,
112,
110,
108,
106,
104,
102,
101,
100,
99,
98,
97,
96,
95,
94,
93,
92,
91,
90,
89,
88,
87,
86,
85,
84,
83,
82,
81,
80,
79,
78,
77,
76,
75,
74,
73,
72,
71,
70,
69,
68,
67,
66,
65,
64,
63,
62,
61,
60,
59,
58,
57,
56,
55,
54,
53,
52,
51,
50,
49,
48,
47,
46,
45,
44,
43,
42,
41,
40,
39,
38,
37,
36,
35,
34,
33,
33,
33,
33,
33,
33,
33,
33
};

const unsigned int16 gain_table[256] = {
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
85,
85,
85,
86,
86,
86,
86,
86,
86,
87,
87,
87,
87,
87,
88,
88,
88,
88,
88,
89,
89,
89,
89,
90,
90,
90,
90,
91,
91,
91,
91,
92,
92,
92,
92,
93,
93,
93,
94,
94,
94,
95,
95,
95,
95,
96,
96,
96,
97,
97,
97,
98,
98,
98,
99,
99,
100,
100,
101,
101,
101,
102,
102,
102,
103,
103,
104,
104,
105,
105,
106,
106,
106,
107,
107,
108,
108,
109,
110,
110,
111,
111,
112,
112,
113,
113,
114,
114,
115,
116,
116,
117,
117,
118,
119,
120,
120,
121,
122,
122,
123,
124,
125,
125,
126,
127,
127,
128,
129,
130,
130,
131,
132,
133,
134,
135,
136,
137,
138,
139,
140,
141,
142,
143,
144,
145,
146,
147,
148,
149,
150,
151,
152,
153,
154,
155,
156,
157,
158,
159,
161,
162,
163,
164,
166,
167,
169,
170,
172,
173,
175,
177,
178,
180,
182,
184,
186,
188,
191,
193,
194,
195,
196,
198,
199,
200,
201,
203,
204,
206,
207,
209,
210,
212,
213,
215,
216,
218,
220,
222,
223,
225,
227,
229,
231,
233,
235,
237,
240,
242,
244,
247,
249,
252,
254,
257,
260,
263,
266,
269,
272,
275,
279,
282,
286,
289,
293,
297,
301,
306,
310,
315,
320,
325,
330,
335,
341,
347,
353,
360,
367,
374,
381,
389,
397,
406,
415,
425,
436,
436,
436,
436,
436,
436,
436,
436

};




#int_PWM1
void  PWM1_isr(void) 
{

   tick_count++;
   if(tick_count >= 8)
   {   
//!      output_bit(PWM_tick_pin , 1);
      millis_count++;
      tick = 1;
      tick_count=0;
   
   }
   if (millis_count >= 500) {
      output_toggle(LED_PIN);
      uart_tick = 1;
      millis_count = 0;
      
   }

}
#INT_TIMER1
void  timer1_isr(void) 
{
//!    output_bit(TIM_tick_pin , 1);
   
//!   delay_us(10);
//!   output_bit(TIM_tick_pin , 0); 
//!   
   
   sample = (sample+1)%max_samples;
   phase_angle[0] = sample;
   phase_angle[1] = (sample+10)%max_samples;
   phase_angle[2] = (sample+20)%max_samples; 

   for (int i = 0 ; i < 3 ; i++) {
      
      reference[i] = sine_table[phase_angle[i]];
      reference[i] = reference[i] * peak_voltage; 
      if( reference[i] > 0)
      {
         reference[i] = reference[i] >> 8; 
      }
      else if( reference[i] < 0)
      {
         reference[i] = 0 - reference[i];
         reference[i] = reference[i] >> 8;
         reference[i] = 0 - reference[i];
      }
      
      reference[i] = reference[i] + voltage_offset;
      if(reference[i] > high_duty_limit )
      { 
         reference[i] = high_duty_limit;
      }
      if(reference[i] < low_duty_limit)
      { 
         reference[i] = low_duty_limit;
      }
   }
      
   *P1DC1 = reference[0];  *(P1DC1+1) = reference[0]>>8;
   *P1DC2 = reference[1];  *(P1DC2+1) = reference[1]>>8;
   *P1DC3 = reference[2];  *(P1DC3+1) = reference[2]>>8;
   

         
   
   setup_timer1(TMR_INTERNAL | TMR_DIV_BY_64, timer_table[freq]);
   
  
//!   if(sample < 15)
//!   { 
//!      output_bit(Sync_Out,1);
//!   }
//!   else
//!   {
//!      output_bit(Sync_Out,0);
//!   }
//!      output_bit(TIM_tick_pin , 0);
}

#INT_TIMER2
void  timer2_isr(void) 
{
   output_bit(TIM_tick_pin , 1);
   delay_us(10);
   output_bit(TIM_tick_pin , 0);

}

   
void main()
{ 
    sprintf(Serial_OutputBuffer, "\nMotor Control Unit v0.1\r\n");
    printf(Serial_OutputBuffer);
 
   freq = 1;
   
   initMCPWM();
   fill_sine_table();
//!   timer_reload();
//!   voltage_gain(); 
   
   output_drive(LED_PIN);
   output_drive(PWM_tick_pin);
   output_drive(TIM_tick_pin);   
   
   setup_adc(ADC_CLOCK_DIV_32);
   setup_adc_ports(ADC_pin);
   set_adc_channel(0);
   delay_us(10);
   

   setup_timer1(TMR_INTERNAL | TMR_DIV_BY_64,timer_table[freq]);            
   enable_interrupts(INT_TIMER1);  
      
   enable_interrupts(INT_PWM1);  
   enable_interrupts(INTR_GLOBAL);
   
//!   duty[0] = 50;
//!   duty[1] = 50;    
//!   duty[2] = 50;  
//!   
//!   *(P1DC1+1) = duty[0]>>8;   *P1DC1 = duty[0];
   
  
   
    
   while(TRUE)         
   {
      
      if (tick) {
         raw_adc = read_adc();
         if (raw_adc > 1023) 
         {
            raw_adc = 1023;
         }
         kalman_big_1 =  raw_adc << kalman_up;
         kalman_diff = kalman_big_1 - kalman_big_2;
         if(kalman_diff > 0)
         {
            kalman_diff = kalman_diff >> kalman_diff_down;
            kalman_big_2 = kalman_big_2 + kalman_diff; 
         }
         else if(kalman_diff < 0)
         {
            kalman_diff = 0 - kalman_diff;
            kalman_diff = kalman_diff >> kalman_diff_down;
            kalman_big_2 = kalman_big_2 - kalman_diff;   
         }
         if(kalman_big_2 < 0)
         {
            kalman_big_2 = 0 ;
         }
         raw_adc = kalman_big_2 >> kalman_up;
         raw_adc = raw_adc >> 2;
         
         
         throttle_level = raw_adc;  
         
         if (throttle_level > 255)
         {
            throttle_level = 255;
         }
         if (throttle_level < 0)   
         {  
            throttle_level = 0; 
         }  
         
         freq = throttle_level;
       
         peak_voltage = gain_table[throttle_level];
//!         peak_voltage = gain_table[55];  
        
         output_bit(PWM_tick_pin , 0);
         tick = 0;      
      } 
      
      if (uart_tick) 
      {
//!         sprintf(Serial_OutputBuffer, "CHECKING SERIAL!");
         sprintf(Serial_OutputBuffer, "\r\n %d , %d , %d , %d", raw_adc , throttle_level , freq , peak_voltage);
         printf(Serial_OutputBuffer);
         
      
      }
    } 
}    


void initMCPWM(void) 
{    
   *(P1TCON+1)=0x80;  *P1TCON=0x02;
   *(P1TPER+1)=0x03;  *P1TPER=0xE7;  
   *(P1SECMP+1)=0x00;  *P1SECMP=0x01; //
   *(PWM1CON1+1)=0x00;  *PWM1CON1=0x77;  
   *(PWM1CON2+1)=0x00;  *PWM1CON2=0x02;
   *(P1DTCON1+1)=0x00;  *P1DTCON1=0x10; //0x09
   *(P1DTCON2+1)=0x00;  *P1DTCON2=0x00;
   *(P1FLTACON+1)=0x00;  *P1FLTACON=0x00; //0x0000
   *(P1OVDCON+1)=0x3F;  *P1OVDCON=0x0F;
   *(P1DC1+1) = duty[0]>>8;   *P1DC1 = duty[0]; 
   *(P1DC2+1) = duty[1]>>8;   *P1DC2 = duty[1];
   *(P1DC3+1) = duty[2]>>8;   *P1DC3 = duty[2];  
   *(IPC14+1) =0x00;*(IPC14) =0x70;
  }


   
void fill_sine_table(void)
{
   for(sine_index=0;sine_index < max_samples;sine_index++)  
   {
      theeta=sine_index*2.0*PI/max_samples;
      sine_table[sine_index]=255*sin(theeta);
   }
}


//!void timer_reload(void) 
//!{
//!   double intr_per_sample = 0.0;
//!   
//!   for (int sample = 1 ; sample <= max_freq ; sample++) 
//!   {
//!      intr_per_sample = ((1.0/sample)*1000)/max_samples;
//!      timer_table[sample] = (intr_per_sample/per_clock_tick) - 100;     
//!   }
//!   timer_table[0] = timer_table[1];
//!   
//!   
//!}

//!void voltage_gain(void) 
//!{
//!   for (int i = 0 ; i <= break_level ; i++) {
//!            gain_table[i] = 0; 
//!   }
//!   
//!   for (int i = break_level+1 ; i <= sustain_level; i++) 
//!   {
//!       temp = SLOPE * i + pedestal_amplitude;
//!       if(temp > peak_amplitude ) 
//!       {
//!         temp = peak_amplitude;
//!       }
//!       gain_table[i] = temp;
//!   }
//!   for (int i = sustain_level+1 ; i <= 255; i++) {     
//!      gain_table[i] = peak_amplitude;
//!   }
//!
//!}




