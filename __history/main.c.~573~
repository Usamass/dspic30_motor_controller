#include <30F4011.h>
#include <Inc/lookup_tables.h>
#DEVICE ADC=10
#device ICSP=1
#use delay(clock=64000000,crystal=8000000)
#use rs232(UART2, baud=9600, stream=UART_PORT2)

#FUSES NOWDT                    //No Watch Dog Timer
#FUSES CKSFSM                   //Clock Switching is enabled, fail Safe clock monitor is enabled
#FUSES BORV42                   //Brownout reset at 4.5V
#FUSES WRT                      //Program Memory Write Protected
#FUSES PROTECT                  //Code protected from reads
#include <math.h>

#define P1TCON    0x01C0
#define P1TMR     0x01C2 
#define P1TPER    0x01C4
#define P1SECMP   0x01C6
#define PWM1CON1  0x01C8 
#define PWM1CON2  0x01CA
#define P1DTCON1  0x01CC
#define P1DTCON2  0x01CE  
#define P1FLTACON 0x01D0
#define P1OVDCON  0x01D4   
#define P1DC1     0x01D6   
#define P1DC2     0x01D8
#define P1DC3     0x01DA
#define IPC14     0x00C0  
#define CLKDIV    0x0744 
#define PLLFBD    0x0746


#define ADC_pin sAN0
#define LED_PIN PIN_B5

#define voltage_offset 1000//1248
#define low_duty_limit 50
#define high_duty_limit 1950
#define SLOPE 0

#define break_level 5
#define sustain_level 200  
#define break_amplitude 0 

#define pedestal_amplitude 500
#define peak_amplitude 950


#define throttle_PIN PIN_B1
#define PWM_tick_pin PIN_B2
#define TIM_tick_pin PIN_B3

#define kalman_up 18
#define kalman_diff_down 8

#define init_freq 30

  
  
void initMCPWM(void);
void fill_sine_table(void);  

unsigned int16 duty[3]={voltage_offset,voltage_offset,voltage_offset},sample=0;
signed int16 peak_voltage =0;//  1184; 
signed int32 reference[3] = {0,0,0};

const unsigned max_samples=30.0;
signed int16 sine_table[max_samples];
unsigned int16 sine_index,phase_angle[3] = {0 , 0 , 0};  
double theeta;

const unsigned max_freq = 250; //Hz

unsigned int16 raw_adc =0 ;
signed int16 throttle_level = 0;
unsigned int16 freq = 1;
unsigned int16 temp = 0;

int1 tick = 0;
int1 uart_tick = 0;
int8 tick_count = 0;
unsigned long millis_count = 0;

char Serial_OutputBuffer[60];

signed int32 kalman_big_1=0, kalman_big_2=0, kalman_diff=0;

const int timer_table[] = {
65068,65068,65068,65068,65068,65068,65068,65068,65068,65068,65068,65068,65068,65068,65068,65068,
65068,65068,65068,65068,65068,61218,57795,54733,51977,49484,47217,45148,43251,41505,39894,38402,
37016,35726,34522,33395,32339,31346,30412,29531,28699,27912,27165,26458,25785,25145,24535,23954,
23399,22868,22360,21874,21408,20961,20531,20118,19721,19339,18971,18616,18273,17943,17624,17315,
17017,16728,16448,16177,15915,15660,15413,15173,14940,14714,14494,14280,14072,13869,13672,13480,
13292,13110,12932,12758,12589,12423,12262,12104,11950,11799,11652,11508,11367,11229,11094,10962,
10832,10705,10581,10459,10340,10223,10108,9995,9884,9776,9669,9564,9461,9360,9261,9163,9067,8973,
8880,8789,8699,8611,8523,8438,8353,8270,8188,8108,8028,7950,7873,7796,7721,7647,7574,7502,7431,7361,
7291,7223,7155,7089,7023,6958,6893,6830,6767,6705,6643,6582,6522,6463,6404,6346,6289,6232,6175,6120,
6064,6010,5955,5902,5849,5796,5744,5692,5641,5590,5540,5490,5441,5392,5343,5295,5247,5200,5153,5106,
5059,5013,4968,4923,4878,4833,4789,4745,4701,4657,4614,4572,4529,4487,4445,4403,4362,4321,4280,4239,
4199,4159,4119,4079,4040,4000,3961,3923,3884,3846,3808,3770,3732,3695,3658,3621,3584,3547,3511,3475,
3439,3403,3368,3332,3297,3262,3227,3193,3158,3124,3090,3056,3023,2989,2956,2923,2890,2858,2825,2793,
2761,2729,2697,2666,2634,2603,2572,2542,2511,2481,2451,2421,2391,2361,2332,2303,2274,2245,2217,2188,
2160,2132};

const unsigned int16 gain_table[] = {
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,85,85,85,86,
86,86,86,86,86,87,87,87,87,87,88,88,88,88,88,89,89,
89,89,90,90,90,90,91,91,91,91,92,92,92,92,93,93,93,
94,94,94,95,95,95,95,96,96,96,97,97,97,98,98,98,99,
99,100,100,101,101,101,102,102,102,103,103,104,104,
105,105,106,106,106,107,107,108,108,109,110,110,111,
111,112,112,113,113,114,114,115,116,116,117,117,118,
119,120,120,121,122,122,123,124,125,125,126,127,127,
128,129,130,130,131,132,133,134,135,136,137,138,139,
140,141,142,143,144,145,146,147,148,149,150,151,152,
153,154,155,156,157,158,159,161,162,163,164,166,167,
169,170,172,173,175,177,178,180,182,184,186,188,191,
193,194,195,196,198,199,200,201,203,204,206,207,209,
210,212,213,215,216,218,220,222,223,225,227,229,231,
233,235,237,240,242,244,247,249,252,254,257,260,263,
266,269,272,275,279,282,286,289,293,297,301,306,310,
315,320,325,330,335,341,347,353,360,367,374,381,389,
397,406,415,425,436,436,436,436,436,436,436,436
};


#int_PWM1
void  PWM1_isr(void) 
{

   tick_count++;
   if(tick_count >= 8)
   {   
      millis_count++;
      tick = 1;
      tick_count=0;
   
   }
   if (millis_count >= 500) {
      output_toggle(LED_PIN);
      uart_tick = 1;
      millis_count = 0;
      
   }

}

#INT_TIMER3
void  timer3_isr(void) 
{

   output_bit(TIM_tick_pin , 1);
   
   sample = (sample+1)%max_samples;
   phase_angle[0] = sample;
   phase_angle[1] = (sample+10)%max_samples;
   phase_angle[2] = (sample+20)%max_samples; 

   for (int i = 0 ; i < 3 ; i++) {
      
      reference[i] = sine_table[phase_angle[i]];
      reference[i] = reference[i] * peak_voltage; 
      if( reference[i] > 0)
      {
         reference[i] = reference[i] >> 8; 
      }
      else if( reference[i] < 0)
      {
         reference[i] = 0 - reference[i];
         reference[i] = reference[i] >> 8;
         reference[i] = 0 - reference[i];
      }
      
      reference[i] = reference[i] + voltage_offset;
      if(reference[i] > high_duty_limit )
      { 
         reference[i] = high_duty_limit;
      }
      if(reference[i] < low_duty_limit)
      { 
         reference[i] = low_duty_limit;
      }
   }
      
   *P1DC1 = reference[0];  *(P1DC1+1) = reference[0]>>8;
   *P1DC2 = reference[1];  *(P1DC2+1) = reference[1]>>8;
   *P1DC3 = reference[2];  *(P1DC3+1) = reference[2]>>8;

   
   setup_timer2(TMR_INTERNAL | TMR_DIV_BY_1 | TMR_32_BIT , timer_table[freq]);
   output_bit(TIM_tick_pin , 0);
   
}


   
void main()
{ 
    sprintf(Serial_OutputBuffer, "\nMotor Control Unit v0.1\r\n");
    printf(Serial_OutputBuffer);
 
   freq = 1;
   
   initMCPWM();
   fill_sine_table();

   output_drive(LED_PIN);
   output_drive(PWM_tick_pin);
   output_drive(TIM_tick_pin);   
   
   setup_adc(ADC_CLOCK_DIV_32);
   setup_adc_ports(ADC_pin);
   set_adc_channel(0);
   delay_us(10);
   
   setup_timer2(TMR_INTERNAL | TMR_DIV_BY_1 | TMR_32_BIT , timer_table[freq]);
   enable_interrupts(INT_TIMER3);   // enable interrupt in timer3 register (in case of 32bit mode) 

   enable_interrupts(INT_PWM1);  
   enable_interrupts(INTR_GLOBAL);
   

   while(TRUE)         
   {
      
      if (tick) {
         raw_adc = read_adc();
         if (raw_adc > 1023) 
         {
            raw_adc = 1023;
         }
         
//------------- KALMAN FILTER IMPLIMENTATION---------------//
         kalman_big_1 =  raw_adc << kalman_up;
         kalman_diff = kalman_big_1 - kalman_big_2;
         if(kalman_diff > 0)
         {
            kalman_diff = kalman_diff >> kalman_diff_down;
            kalman_big_2 = kalman_big_2 + kalman_diff; 
         }
         else if(kalman_diff < 0)
         {
            kalman_diff = 0 - kalman_diff;
            kalman_diff = kalman_diff >> kalman_diff_down;
            kalman_big_2 = kalman_big_2 - kalman_diff;   
         }
         if(kalman_big_2 < 0)
         {
            kalman_big_2 = 0 ;
         }
         raw_adc = kalman_big_2 >> kalman_up;
//------------- KALMAN FILTER IMPLIMENTATION---------------//


         raw_adc = raw_adc >> 2;
         throttle_level = raw_adc;  
         
         if (throttle_level > 255)
         {
            throttle_level = 255;
         }
         if (throttle_level < 0)   
         {  
            throttle_level = 0; 
         }  
         
         freq = throttle_level;
       
         peak_voltage = gain_table[throttle_level]; 
        
         output_bit(PWM_tick_pin , 0);
         tick = 0;      
      } 
      
      if (uart_tick) 
      {
         sprintf(Serial_OutputBuffer, "\r\n %d , %d , %d , %d", raw_adc , throttle_level , freq , peak_voltage);
         printf(Serial_OutputBuffer);
         
      
      }
    } 
}    


void initMCPWM(void) 
{    
   *(P1TCON+1)  =  0x80;  *P1TCON =  0x02;
   *(P1TPER+1)  =  0x03;  *P1TPER =  0xE7;  
   *(P1SECMP+1) =  0x00;  *P1SECMP=  0x01; //
   *(PWM1CON1+1)=  0x00;  *PWM1CON1= 0x77;  
   *(PWM1CON2+1)=  0x00;  *PWM1CON2= 0x02;
   *(P1DTCON1+1)=  0x00;  *P1DTCON1= 0x10; //0x09
   *(P1DTCON2+1)=  0x00;  *P1DTCON2= 0x00;
   *(P1FLTACON+1)= 0x00;  *P1FLTACON=0x00; //0x0000
   *(P1OVDCON+1)=  0x3F;  *P1OVDCON= 0x0F;
   
   *(P1DC1+1) = duty[0]>>8;   *P1DC1 = duty[0]; 
   *(P1DC2+1) = duty[1]>>8;   *P1DC2 = duty[1];
   *(P1DC3+1) = duty[2]>>8;   *P1DC3 = duty[2];  
   *(IPC14+1) =0x00;*(IPC14) =0x70;
}


   
void fill_sine_table(void)
{
   for(sine_index=0;sine_index < max_samples;sine_index++)  
   {
      theeta=sine_index*2.0*PI/max_samples;
      sine_table[sine_index]=255*sin(theeta);
   }
}





