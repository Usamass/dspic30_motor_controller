CCS PCD C Compiler, Version 5.112, 5967               13-Jun-24 15:41

               Filename:   C:\Users\eelab\Documents\[2024-05-15] MOTOR_CONTROL\main.lst

               ROM used:   6690 bytes (20%)
                           Largest free fragment is 26078
               RAM used:   624 (30%) at main() level
                           831 (41%) worst case
               Stack used: 108 locations (58 in main + 50 for interrupts)
               Stack size: 128

*
0000:  GOTO    1682
*
0022:  DATA    F4,07,00
*
0026:  DATA    08,07,00
*
0062:  DATA    42,07,00
.................... #include <30F4011.h>
.................... //////////// Standard Header file for the DSPIC30F4011 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
*
0732:  MOV     #1A,W0
0734:  REPEAT  #C
0736:  MOV     [--W15],[W0--]
0738:  MOV     [--W15],W0
073A:  POP     32
073C:  POP     36
073E:  POP     42
0740:  RETFIE  
.................... #device DSPIC30F4011
*
0100:  CLR     32
0102:  MOV     #156,W3
0104:  SUB     W0,W3,W3
0106:  BRA     C,110
0108:  MOV     #122,W3
010A:  ADD     W3,W0,W0
010C:  TBLRDL  [W0],W0
010E:  RETURN  
0110:  MOV     #122,W0
0112:  BCLR.B  6.0
0114:  ADD     W3,W3,W3
0116:  ADD     W3,W0,W3
0118:  TBLRDH  [W3++],W0
011A:  TBLRDH  [W3],W3
011C:  SL      W3,#8,W3
011E:  IOR      W3,  W0,W0
0120:  RETURN  
0122:  DATA    00,00,23
0124:  DATA    00,00,01
0126:  DATA    00,00,26
0128:  DATA    00,00,01
012A:  DATA    00,00,29
012C:  DATA    00,00,01
012E:  DATA    00,00,2C
0130:  DATA    00,00,01
0132:  DATA    00,00,2E
0134:  DATA    00,00,01
0136:  DATA    00,00,31
0138:  DATA    00,00,01
013A:  DATA    00,00,34
013C:  DATA    00,00,01
013E:  DATA    00,00,37
0140:  DATA    00,00,01
0142:  DATA    00,00,3A
0144:  DATA    00,00,01
0146:  DATA    00,00,3D
0148:  DATA    00,00,01
014A:  DATA    00,00,40
014C:  DATA    17,00,01
014E:  DATA    1A,00,42
0150:  DATA    1A,00,01
0152:  DATA    1D,00,45
0154:  DATA    1D,00,01
0156:  DATA    20,00,49
0158:  DATA    20,00,01
015A:  DATA    22,00,4B
015C:  DATA    22,00,01
015E:  DATA    25,00,4E
0160:  DATA    25,00,01
0162:  DATA    28,00,51
0164:  DATA    28,00,01
0166:  DATA    2B,00,53
0168:  DATA    2B,00,01
016A:  DATA    2E,00,5A
016C:  DATA    31,00,01
016E:  DATA    31,00,5C
0170:  DATA    33,00,01
0172:  DATA    33,00,5F
0174:  DATA    36,00,01
0176:  DATA    36,00,62
0178:  DATA    39,00,01
017A:  DATA    39,00,64
017C:  DATA    3C,00,01
017E:  DATA    3C,00,68
0180:  DATA    3F,00,01
0182:  DATA    3F,00,6D
0184:  DATA    42,00,01
0186:  DATA    42,00,70
0188:  DATA    44,00,01
018A:  DATA    44,00,73
018C:  DATA    47,00,01
018E:  DATA    47,00,76
0190:  DATA    4A,00,01
0192:  DATA    4D,00,7C
0194:  DATA    4D,00,01
0196:  DATA    50,00,7F
0198:  DATA    50,00,01
019A:  DATA    53,00,81
019C:  DATA    53,00,01
019E:  DATA    56,00,87
01A0:  DATA    56,00,01
01A2:  DATA    58,00,8A
01A4:  DATA    58,00,01
01A6:  DATA    5B,00,90
01A8:  DATA    5B,00,01
01AA:  DATA    5F,00,92
01AC:  DATA    61,00,01
01AE:  DATA    61,00,95
01B0:  DATA    64,00,01
01B2:  DATA    64,00,9B
01B4:  DATA    67,00,01
01B6:  DATA    67,00,9E
01B8:  DATA    69,00,01
01BA:  DATA    69,00,A3
01BC:  DATA    6C,00,01
01BE:  DATA    70,00,A6
01C0:  DATA    70,00,01
01C2:  DATA    72,00,AC
01C4:  DATA    72,00,01
01C6:  DATA    75,00,AF
01C8:  DATA    75,00,01
01CA:  DATA    78,00,B5
01CC:  DATA    78,00,01
01CE:  DATA    7A,00,BA
01D0:  DATA    7E,00,01
01D2:  DATA    7E,00,BE
01D4:  DATA    81,00,01
01D6:  DATA    81,00,C3
01D8:  DATA    83,00,01
01DA:  DATA    83,00,C8
01DC:  DATA    86,00,01
01DE:  DATA    89,00,CC
01E0:  DATA    89,00,01
01E2:  DATA    8C,00,D1
01E4:  DATA    8C,00,01
01E6:  DATA    8F,00,D7
01E8:  DATA    8F,00,01
01EA:  DATA    92,00,D9
01EC:  DATA    95,00,01
01EE:  DATA    95,00,E0
01F0:  DATA    97,00,01
01F2:  DATA    97,00,E5
01F4:  DATA    9A,00,01
01F6:  DATA    9D,00,EB
01F8:  DATA    9D,00,01
01FA:  DATA    A0,00,F1
01FC:  DATA    A0,00,01
01FE:  DATA    A3,00,F6
0200:  DATA    A6,00,01
0202:  DATA    A6,00,FC
0204:  DATA    A8,00,01
0206:  DATA    AB,00,02
0208:  DATA    AB,00,02
020A:  DATA    AE,00,07
020C:  DATA    AE,00,02
020E:  DATA    B1,00,0D
0210:  DATA    B4,00,02
0212:  DATA    B4,00,13
0214:  DATA    B7,00,02
0216:  DATA    B9,00,18
0218:  DATA    B9,00,02
021A:  DATA    BC,00,1E
021C:  DATA    BF,00,02
021E:  DATA    BF,00,27
0220:  DATA    C2,00,02
0222:  DATA    C5,00,2C
0224:  DATA    C5,00,02
0226:  DATA    C8,00,33
0228:  DATA    CB,00,02
022A:  DATA    CB,00,38
022C:  DATA    CD,00,02
022E:  DATA    D0,00,41
0230:  DATA    D0,00,02
0232:  DATA    D4,00,46
0234:  DATA    D6,00,02
0236:  DATA    D6,00,4E
0238:  DATA    D9,00,02
023A:  DATA    DC,00,55
023C:  DATA    DE,00,02
023E:  DATA    DE,00,5D
0240:  DATA    E2,00,02
0242:  DATA    E5,00,63
0244:  DATA    E7,00,02
0246:  DATA    E7,00,6B
0248:  DATA    EA,00,02
024A:  DATA    ED,00,74
024C:  DATA    EF,00,02
024E:  DATA    EF,00,7A
0250:  DATA    F3,00,02
0252:  DATA    F6,00,82
0254:  DATA    F8,00,02
0256:  DATA    F8,00,8B
0258:  DATA    FB,00,02
025A:  DATA    FE,00,93
025C:  DATA    01,01,02
025E:  DATA    04,01,9C
0260:  DATA    07,01,02
0262:  DATA    07,01,A5
0264:  DATA    0A,01,02
0266:  DATA    0C,01,AD
0268:  DATA    0F,01,02
026A:  DATA    12,01,B6
026C:  DATA    15,01,02
026E:  DATA    18,01,BE
0270:  DATA    18,01,02
0272:  DATA    1B,01,CA
0274:  DATA    1D,01,02
0276:  DATA    20,01,00
0278:  CLR     32
027A:  MOV     #156,W3
027C:  SUB     W0,W3,W3
027E:  BRA     C,288
0280:  MOV     #29A,W3
0282:  ADD     W3,W0,W0
0284:  TBLRDL  [W0],W0
0286:  RETURN  
0288:  MOV     #29A,W0
028A:  BCLR.B  6.0
028C:  ADD     W3,W3,W3
028E:  ADD     W3,W0,W3
0290:  TBLRDH  [W3++],W0
0292:  TBLRDH  [W3],W3
0294:  SL      W3,#8,W3
0296:  IOR      W3,  W0,W0
0298:  RETURN  
029A:  DATA    00,00,40
029C:  DATA    00,00,01
029E:  DATA    00,00,43
02A0:  DATA    00,00,01
02A2:  DATA    00,00,47
02A4:  DATA    00,00,01
02A6:  DATA    00,00,4A
02A8:  DATA    00,00,01
02AA:  DATA    00,00,4C
02AC:  DATA    00,00,01
02AE:  DATA    00,00,50
02B0:  DATA    00,00,01
02B2:  DATA    00,00,53
02B4:  DATA    00,00,01
02B6:  DATA    00,00,56
02B8:  DATA    00,00,01
02BA:  DATA    00,00,59
02BC:  DATA    00,00,01
02BE:  DATA    00,00,5D
02C0:  DATA    00,00,01
02C2:  DATA    00,00,60
02C4:  DATA    19,00,01
02C6:  DATA    1D,00,62
02C8:  DATA    1D,00,01
02CA:  DATA    20,00,66
02CC:  DATA    20,00,01
02CE:  DATA    23,00,6A
02D0:  DATA    23,00,01
02D2:  DATA    25,00,6C
02D4:  DATA    25,00,01
02D6:  DATA    29,00,6F
02D8:  DATA    29,00,01
02DA:  DATA    2C,00,73
02DC:  DATA    2C,00,01
02DE:  DATA    2F,00,75
02E0:  DATA    2F,00,01
02E2:  DATA    33,00,7D
02E4:  DATA    36,00,01
02E6:  DATA    36,00,7F
02E8:  DATA    38,00,01
02EA:  DATA    38,00,82
02EC:  DATA    3B,00,01
02EE:  DATA    3B,00,85
02F0:  DATA    3F,00,01
02F2:  DATA    3F,00,88
02F4:  DATA    42,00,01
02F6:  DATA    42,00,8C
02F8:  DATA    45,00,01
02FA:  DATA    45,00,92
02FC:  DATA    49,00,01
02FE:  DATA    49,00,95
0300:  DATA    4B,00,01
0302:  DATA    4B,00,98
0304:  DATA    4E,00,01
0306:  DATA    4E,00,9B
0308:  DATA    51,00,01
030A:  DATA    55,00,A2
030C:  DATA    55,00,01
030E:  DATA    58,00,A5
0310:  DATA    58,00,01
0312:  DATA    5B,00,A8
0314:  DATA    5B,00,01
0316:  DATA    5F,00,AE
0318:  DATA    5F,00,01
031A:  DATA    61,00,B1
031C:  DATA    61,00,01
031E:  DATA    64,00,B8
0320:  DATA    64,00,01
0322:  DATA    69,00,BA
0324:  DATA    6B,00,01
0326:  DATA    6B,00,BE
0328:  DATA    6E,00,01
032A:  DATA    6E,00,C4
032C:  DATA    71,00,01
032E:  DATA    71,00,C7
0330:  DATA    74,00,01
0332:  DATA    74,00,CD
0334:  DATA    77,00,01
0336:  DATA    7B,00,D0
0338:  DATA    7B,00,01
033A:  DATA    7D,00,D7
033C:  DATA    7D,00,01
033E:  DATA    81,00,DA
0340:  DATA    81,00,01
0342:  DATA    84,00,E1
0344:  DATA    84,00,01
0346:  DATA    86,00,E6
0348:  DATA    8B,00,01
034A:  DATA    8B,00,EB
034C:  DATA    8E,00,01
034E:  DATA    8E,00,F0
0350:  DATA    90,00,01
0352:  DATA    90,00,F6
0354:  DATA    93,00,01
0356:  DATA    97,00,FA
0358:  DATA    97,00,01
035A:  DATA    9A,00,00
035C:  DATA    9A,00,02
035E:  DATA    9D,00,06
0360:  DATA    9D,00,02
0362:  DATA    A1,00,08
0364:  DATA    A4,00,02
0366:  DATA    A4,00,10
0368:  DATA    A6,00,02
036A:  DATA    A6,00,16
036C:  DATA    A9,00,02
036E:  DATA    AD,00,1C
0370:  DATA    AD,00,02
0372:  DATA    B0,00,23
0374:  DATA    B0,00,02
0376:  DATA    B3,00,28
0378:  DATA    B7,00,02
037A:  DATA    B7,00,2F
037C:  DATA    B9,00,02
037E:  DATA    BC,00,35
0380:  DATA    BC,00,02
0382:  DATA    BF,00,3B
0384:  DATA    BF,00,02
0386:  DATA    C3,00,42
0388:  DATA    C6,00,02
038A:  DATA    C6,00,48
038C:  DATA    C9,00,02
038E:  DATA    CC,00,4E
0390:  DATA    CC,00,02
0392:  DATA    CF,00,54
0394:  DATA    D2,00,02
0396:  DATA    D2,00,5E
0398:  DATA    D5,00,02
039A:  DATA    D9,00,64
039C:  DATA    D9,00,02
039E:  DATA    DC,00,6B
03A0:  DATA    DF,00,02
03A2:  DATA    DF,00,71
03A4:  DATA    E2,00,02
03A6:  DATA    E5,00,7B
03A8:  DATA    E5,00,02
03AA:  DATA    E9,00,80
03AC:  DATA    EB,00,02
03AE:  DATA    EB,00,89
03B0:  DATA    EF,00,02
03B2:  DATA    F2,00,91
03B4:  DATA    F4,00,02
03B6:  DATA    F4,00,9A
03B8:  DATA    F9,00,02
03BA:  DATA    FC,00,A0
03BC:  DATA    FE,00,02
03BE:  DATA    FE,00,A9
03C0:  DATA    01,01,02
03C2:  DATA    05,01,B3
03C4:  DATA    07,01,02
03C6:  DATA    07,01,B9
03C8:  DATA    0B,01,02
03CA:  DATA    0F,01,C2
03CC:  DATA    11,01,02
03CE:  DATA    11,01,CC
03D0:  DATA    14,01,02
03D2:  DATA    17,01,D5
03D4:  DATA    1B,01,02
03D6:  DATA    1E,01,DF
03D8:  DATA    21,01,02
03DA:  DATA    21,01,E9
03DC:  DATA    25,01,02
03DE:  DATA    27,01,F2
03E0:  DATA    2A,01,02
03E2:  DATA    2D,01,FB
03E4:  DATA    31,01,02
03E6:  DATA    34,01,04
03E8:  DATA    34,01,03
03EA:  DATA    37,01,11
03EC:  DATA    3A,01,03
03EE:  DATA    3D,01,00
03F0:  CLR     32
03F2:  MOV     #156,W3
03F4:  SUB     W0,W3,W3
03F6:  BRA     C,400
03F8:  MOV     #412,W3
03FA:  ADD     W3,W0,W0
03FC:  TBLRDL  [W0],W0
03FE:  RETURN  
0400:  MOV     #412,W0
0402:  BCLR.B  6.0
0404:  ADD     W3,W3,W3
0406:  ADD     W3,W0,W3
0408:  TBLRDH  [W3++],W0
040A:  TBLRDH  [W3],W3
040C:  SL      W3,#8,W3
040E:  IOR      W3,  W0,W0
0410:  RETURN  
0412:  DATA    2C,FE,50
0414:  DATA    2C,FE,14
0416:  DATA    2C,FE,21
0418:  DATA    2C,FE,14
041A:  DATA    2C,FE,F2
041C:  DATA    2C,FE,13
041E:  DATA    2C,FE,C3
0420:  DATA    2C,FE,13
0422:  DATA    2C,FE,95
0424:  DATA    2C,FE,13
0426:  DATA    2C,FE,68
0428:  DATA    2C,FE,13
042A:  DATA    2C,FE,3B
042C:  DATA    2C,FE,13
042E:  DATA    2C,FE,0E
0430:  DATA    2C,FE,13
0432:  DATA    2C,FE,E1
0434:  DATA    2C,FE,12
0436:  DATA    2C,FE,B5
0438:  DATA    2C,FE,12
043A:  DATA    2C,FE,89
043C:  DATA    22,EF,12
043E:  DATA    C3,E1,5D
0440:  DATA    CD,D5,12
0442:  DATA    09,CB,31
0444:  DATA    4C,C1,12
0446:  DATA    71,B8,06
0448:  DATA    5C,B0,12
044A:  DATA    F3,A8,DC
044C:  DATA    21,A2,11
044E:  DATA    D6,9B,B1
0450:  DATA    02,96,11
0452:  DATA    98,90,87
0454:  DATA    8E,8B,11
0456:  DATA    DA,86,5D
0458:  DATA    73,82,11
045A:  DATA    53,7E,33
045C:  DATA    72,7A,11
045E:  DATA    CC,76,0A
0460:  DATA    5B,73,11
0462:  DATA    1B,70,E1
0464:  DATA    08,6D,10
0466:  DATA    1D,6A,B8
0468:  DATA    5A,67,10
046A:  DATA    B9,64,8F
046C:  DATA    39,62,10
046E:  DATA    D7,5F,67
0470:  DATA    92,5D,10
0472:  DATA    67,5B,3F
0474:  DATA    54,59,10
0476:  DATA    58,57,17
0478:  DATA    72,55,10
047A:  DATA    A0,53,EF
047C:  DATA    E1,51,0F
047E:  DATA    33,50,C8
0480:  DATA    96,4E,0F
0482:  DATA    09,4D,A0
0484:  DATA    8B,4B,0F
0486:  DATA    1B,4A,79
0488:  DATA    B8,48,0F
048A:  DATA    61,47,53
048C:  DATA    17,46,0F
048E:  DATA    D8,44,2C
0490:  DATA    A3,43,0F
0492:  DATA    79,42,06
0494:  DATA    58,41,0F
0496:  DATA    40,40,E0
0498:  DATA    31,3F,0E
049A:  DATA    2B,3E,BA
049C:  DATA    2C,3D,0E
049E:  DATA    35,3C,94
04A0:  DATA    45,3B,0E
04A2:  DATA    5C,3A,6F
04A4:  DATA    7A,39,0E
04A6:  DATA    9E,38,4A
04A8:  DATA    C8,37,0E
04AA:  DATA    F8,36,25
04AC:  DATA    2D,36,0E
04AE:  DATA    68,35,00
04B0:  DATA    A8,34,0E
04B2:  DATA    EC,33,DB
04B4:  DATA    36,33,0D
04B6:  DATA    84,32,B7
04B8:  DATA    D6,31,0D
04BA:  DATA    2D,31,93
04BC:  DATA    87,30,0D
04BE:  DATA    E6,2F,6F
04C0:  DATA    48,2F,0D
04C2:  DATA    AE,2E,4B
04C4:  DATA    17,2E,0D
04C6:  DATA    84,2D,28
04C8:  DATA    F4,2C,0D
04CA:  DATA    67,2C,04
04CC:  DATA    DD,2B,0D
04CE:  DATA    56,2B,E1
04D0:  DATA    D2,2A,0C
04D2:  DATA    50,2A,BE
04D4:  DATA    D1,29,0C
04D6:  DATA    55,29,9B
04D8:  DATA    DB,28,0C
04DA:  DATA    64,28,79
04DC:  DATA    EF,27,0C
04DE:  DATA    7C,27,56
04E0:  DATA    0B,27,0C
04E2:  DATA    9C,26,34
04E4:  DATA    30,26,0C
04E6:  DATA    C5,25,12
04E8:  DATA    5C,25,0C
04EA:  DATA    F5,24,F0
04EC:  DATA    90,24,0B
04EE:  DATA    2D,24,CF
04F0:  DATA    CB,23,0B
04F2:  DATA    6B,23,AD
04F4:  DATA    0D,23,0B
04F6:  DATA    B0,22,8C
04F8:  DATA    55,22,0B
04FA:  DATA    FB,21,6B
04FC:  DATA    A3,21,0B
04FE:  DATA    4B,21,4A
0500:  DATA    F6,20,0B
0502:  DATA    A1,20,2A
0504:  DATA    4E,20,0B
0506:  DATA    FC,1F,09
0508:  DATA    AC,1F,0B
050A:  DATA    5C,1F,E9
050C:  DATA    0E,1F,0A
050E:  DATA    C1,1E,C9
0510:  DATA    74,1E,0A
0512:  DATA    29,1E,A9
0514:  DATA    DF,1D,0A
0516:  DATA    96,1D,89
0518:  DATA    4E,1D,0A
051A:  DATA    07,1D,6A
051C:  DATA    C1,1C,0A
051E:  DATA    7B,1C,4A
0520:  DATA    37,1C,0A
0522:  DATA    F3,1B,2B
0524:  DATA    B1,1B,0A
0526:  DATA    6F,1B,0C
0528:  DATA    2E,1B,0A
052A:  DATA    ED,1A,EE
052C:  DATA    AE,1A,09
052E:  DATA    6F,1A,CF
0530:  DATA    31,1A,09
0532:  DATA    F3,19,B1
0534:  DATA    B6,19,09
0536:  DATA    7A,19,93
0538:  DATA    3F,19,09
053A:  DATA    04,19,75
053C:  DATA    CA,18,09
053E:  DATA    91,18,57
0540:  DATA    58,18,09
0542:  DATA    1F,18,39
0544:  DATA    E8,17,09
0546:  DATA    B0,17,1C
0548:  DATA    7A,17,09
054A:  DATA    43,17,FF
054C:  DATA    0E,17,08
054E:  DATA    D9,16,E2
0550:  DATA    A4,16,08
0552:  DATA    70,16,C5
0554:  DATA    3C,16,08
0556:  DATA    09,16,A9
0558:  DATA    D6,15,08
055A:  DATA    A4,15,8C
055C:  DATA    72,15,08
055E:  DATA    41,15,70
0560:  DATA    10,15,08
0562:  DATA    DF,14,54
0564:  DATA    AF,14,08
0566:  DATA    7F,14,00
0568:  CLR     32
056A:  MOV     #156,W3
056C:  SUB     W0,W3,W3
056E:  BRA     C,578
0570:  MOV     #58A,W3
0572:  ADD     W3,W0,W0
0574:  TBLRDL  [W0],W0
0576:  RETURN  
0578:  MOV     #58A,W0
057A:  BCLR.B  6.0
057C:  ADD     W3,W3,W3
057E:  ADD     W3,W0,W3
0580:  TBLRDH  [W3++],W0
0582:  TBLRDH  [W3],W3
0584:  SL      W3,#8,W3
0586:  IOR      W3,  W0,W0
0588:  RETURN  
058A:  DATA    00,00,B1
058C:  DATA    00,00,00
058E:  DATA    00,00,B2
0590:  DATA    00,00,00
0592:  DATA    00,00,B4
0594:  DATA    00,00,00
0596:  DATA    00,00,B6
0598:  DATA    00,00,00
059A:  DATA    00,00,B8
059C:  DATA    00,00,00
059E:  DATA    00,00,BA
05A0:  DATA    00,00,00
05A2:  DATA    00,00,BC
05A4:  DATA    00,00,00
05A6:  DATA    00,00,BF
05A8:  DATA    00,00,00
05AA:  DATA    00,00,C1
05AC:  DATA    00,00,00
05AE:  DATA    00,00,C2
05B0:  DATA    00,00,00
05B2:  DATA    55,00,C3
05B4:  DATA    55,00,00
05B6:  DATA    55,00,C4
05B8:  DATA    56,00,00
05BA:  DATA    56,00,C6
05BC:  DATA    56,00,00
05BE:  DATA    56,00,C7
05C0:  DATA    56,00,00
05C2:  DATA    56,00,C8
05C4:  DATA    57,00,00
05C6:  DATA    57,00,C9
05C8:  DATA    57,00,00
05CA:  DATA    57,00,CB
05CC:  DATA    57,00,00
05CE:  DATA    58,00,CC
05D0:  DATA    58,00,00
05D2:  DATA    58,00,CE
05D4:  DATA    58,00,00
05D6:  DATA    58,00,CF
05D8:  DATA    59,00,00
05DA:  DATA    59,00,D1
05DC:  DATA    59,00,00
05DE:  DATA    59,00,D2
05E0:  DATA    5A,00,00
05E2:  DATA    5A,00,D4
05E4:  DATA    5A,00,00
05E6:  DATA    5A,00,D5
05E8:  DATA    5B,00,00
05EA:  DATA    5B,00,D7
05EC:  DATA    5B,00,00
05EE:  DATA    5B,00,D8
05F0:  DATA    5C,00,00
05F2:  DATA    5C,00,DA
05F4:  DATA    5C,00,00
05F6:  DATA    5C,00,DC
05F8:  DATA    5D,00,00
05FA:  DATA    5D,00,DE
05FC:  DATA    5D,00,00
05FE:  DATA    5E,00,DF
0600:  DATA    5E,00,00
0602:  DATA    5E,00,E1
0604:  DATA    5F,00,00
0606:  DATA    5F,00,E3
0608:  DATA    5F,00,00
060A:  DATA    5F,00,E5
060C:  DATA    60,00,00
060E:  DATA    60,00,E7
0610:  DATA    60,00,00
0612:  DATA    61,00,E9
0614:  DATA    61,00,00
0616:  DATA    61,00,EB
0618:  DATA    62,00,00
061A:  DATA    62,00,ED
061C:  DATA    62,00,00
061E:  DATA    63,00,F0
0620:  DATA    63,00,00
0622:  DATA    64,00,F2
0624:  DATA    64,00,00
0626:  DATA    65,00,F4
0628:  DATA    65,00,00
062A:  DATA    65,00,F7
062C:  DATA    66,00,00
062E:  DATA    66,00,F9
0630:  DATA    66,00,00
0632:  DATA    67,00,FC
0634:  DATA    67,00,00
0636:  DATA    68,00,FE
0638:  DATA    68,00,00
063A:  DATA    69,00,01
063C:  DATA    69,00,01
063E:  DATA    6A,00,04
0640:  DATA    6A,00,01
0642:  DATA    6A,00,07
0644:  DATA    6B,00,01
0646:  DATA    6B,00,0A
0648:  DATA    6C,00,01
064A:  DATA    6C,00,0D
064C:  DATA    6D,00,01
064E:  DATA    6E,00,10
0650:  DATA    6E,00,01
0652:  DATA    6F,00,13
0654:  DATA    6F,00,01
0656:  DATA    70,00,17
0658:  DATA    70,00,01
065A:  DATA    71,00,1A
065C:  DATA    71,00,01
065E:  DATA    72,00,1E
0660:  DATA    72,00,01
0662:  DATA    73,00,21
0664:  DATA    74,00,01
0666:  DATA    74,00,25
0668:  DATA    75,00,01
066A:  DATA    75,00,29
066C:  DATA    76,00,01
066E:  DATA    77,00,2D
0670:  DATA    78,00,01
0672:  DATA    78,00,32
0674:  DATA    79,00,01
0676:  DATA    7A,00,36
0678:  DATA    7A,00,01
067A:  DATA    7B,00,3B
067C:  DATA    7C,00,01
067E:  DATA    7D,00,40
0680:  DATA    7D,00,01
0682:  DATA    7E,00,45
0684:  DATA    7F,00,01
0686:  DATA    7F,00,4A
0688:  DATA    80,00,01
068A:  DATA    81,00,4F
068C:  DATA    82,00,01
068E:  DATA    82,00,55
0690:  DATA    83,00,01
0692:  DATA    84,00,5B
0694:  DATA    85,00,01
0696:  DATA    86,00,61
0698:  DATA    87,00,01
069A:  DATA    88,00,68
069C:  DATA    89,00,01
069E:  DATA    8A,00,6F
06A0:  DATA    8B,00,01
06A2:  DATA    8C,00,76
06A4:  DATA    8D,00,01
06A6:  DATA    8E,00,7D
06A8:  DATA    8F,00,01
06AA:  DATA    90,00,85
06AC:  DATA    91,00,01
06AE:  DATA    92,00,8D
06B0:  DATA    93,00,01
06B2:  DATA    94,00,96
06B4:  DATA    95,00,01
06B6:  DATA    96,00,9F
06B8:  DATA    97,00,01
06BA:  DATA    98,00,A9
06BC:  DATA    99,00,01
06BE:  DATA    9A,00,B4
06C0:  DATA    9B,00,01
06C2:  DATA    9C,00,B4
06C4:  DATA    9D,00,01
06C6:  DATA    9E,00,B4
06C8:  DATA    9F,00,01
06CA:  DATA    A1,00,B4
06CC:  DATA    A2,00,01
06CE:  DATA    A3,00,B4
06D0:  DATA    A4,00,01
06D2:  DATA    A6,00,B4
06D4:  DATA    A7,00,01
06D6:  DATA    A9,00,B4
06D8:  DATA    AA,00,01
06DA:  DATA    AC,00,B4
06DC:  DATA    AD,00,01
06DE:  DATA    AF,00,00
06E0:  CLR     32
06E2:  MOV     #6EC,W3
06E4:  ADD     W3,W0,W0
06E6:  TBLRDL.B[W0],W0L
06E8:  CLR.B   1
06EA:  RETURN  
06EC:  DATA    0A,4D,00
06EE:  DATA    6F,74,00
06F0:  DATA    6F,72,00
06F2:  DATA    20,43,00
06F4:  DATA    6F,6E,00
06F6:  DATA    74,72,00
06F8:  DATA    6F,6C,00
06FA:  DATA    20,55,00
06FC:  DATA    6E,69,00
06FE:  DATA    74,20,00
0700:  DATA    76,30,00
0702:  DATA    2E,31,00
0704:  DATA    0D,0A,00
0706:  DATA    00,00,00
0708:  PUSH    42
070A:  PUSH    36
070C:  PUSH    32
070E:  MOV     W0,[W15++]
0710:  MOV     #2,W0
0712:  REPEAT  #C
0714:  MOV     [W0++],[W15++]
0716:  MOV     #800,W0
0718:  MOV     864,W4
071A:  ADD     W0,W4,W1
071C:  MOV     212,W0
071E:  BCLR.B  85.1
0720:  MOV.B   W0L,[W1++]
0722:  INC     0864
0724:  MOV     #63,W4
0726:  MOV     864,W3
0728:  SUB     W4,W3,W0
072A:  BRA     C,72E
072C:  CLR     864
072E:  BTSC.B  20E.0
0730:  BRA     71C
*
07B2:  MOV     W5,[W15++]
07B4:  MOV     #C,W5
07B6:  REPEAT  #3
07B8:  MOV     [W5++],[W15++]
07BA:  MUL.UU  W0,W2,W4
07BC:  BTSS    W3.F
07BE:  BRA     7C4
07C0:  MUL.SS  W0,W3,W6
07C2:  BRA     7C6
07C4:  MUL.UU  W0,W3,W6
07C6:  BCLR.B  42.0
07C8:  ADD     W6,W5,W5
07CA:  ADDC    W7,#0,W8
07CC:  BTSS    W1.F
07CE:  BRA     7D4
07D0:  MUL.SS  W1,W2,W6
07D2:  BRA     7D6
07D4:  MUL.UU  W1,W2,W6
07D6:  ADDC    W6,W5,W5
07D8:  ADDC    W7,W8,W8
07DA:  ADDC    #0,W9
07DC:  MUL.SS  W1,W3,W6
07DE:  ADDC    W6,W8,W8
07E0:  ADDC    W9,W7,W7
07E2:  MOV     W7,W3
07E4:  MOV     W8,W2
07E6:  MOV     W5,W1
07E8:  MOV     W4,W0
07EA:  MOV     #12,W5
07EC:  REPEAT  #3
07EE:  MOV     [--W15],[W5--]
07F0:  MOV     [--W15],W5
07F2:  RETURN  
*
0A06:  MOV     W1,[W15++]
0A08:  MOV     9EE,W1
0A0A:  MOV.B   W0L,[W1++]
0A0C:  CLR.B   [W1]
0A0E:  MOV     [--W15],W1
0A10:  INC     09EE
0A12:  RETURN  
*
0A6C:  MOV     W5,[W15++]
0A6E:  MOV     #C,W5
0A70:  REPEAT  #3
0A72:  MOV     [W5++],[W15++]
0A74:  MOV     W0,W4
0A76:  MOV     W1,W5
0A78:  MOV     W2,W6
0A7A:  MOV     W3,W7
0A7C:  CLR     W0
0A7E:  CLR     W1
0A80:  CLR     W2
0A82:  CLR     W3
0A84:  BCLR    W8.0
0A86:  BTSS    W7.F
0A88:  BRA     A9A
0A8A:  BSET    W8.0
0A8C:  COM     W7,W7
0A8E:  COM     W6,W6
0A90:  COM     W5,W5
0A92:  NEG     W4,W4
0A94:  ADDC    W5,#0,W5
0A96:  ADDC    W6,#0,W6
0A98:  ADDC    W7,#0,W7
0A9A:  IOR      W4,  W5,W9
0A9C:  BRA     NZ,AA2
0A9E:  IOR      W6,  W7,W9
0AA0:  BRA     Z,ACC
0AA2:  MOV     #473,W9
0AA4:  BTSC    W3.4
0AA6:  BRA     ABE
0AA8:  BCLR.B  42.0
0AAA:  RLC     W4,W4
0AAC:  RLC     W5,W5
0AAE:  RLC     W6,W6
0AB0:  RLC     W7,W7
0AB2:  RLC     W0,W0
0AB4:  RLC     W1,W1
0AB6:  RLC     W2,W2
0AB8:  RLC     W3,W3
0ABA:  DEC     W9,W9
0ABC:  BRA     NZ,AA4
0ABE:  SL      W9,#4,W9
0AC0:  BCLR.B  42.0
0AC2:  BCLR    W9.F
0AC4:  BCLR    W3.4
0AC6:  XOR     W9,W3,W3
0AC8:  BTSC    W8.0
0ACA:  BSET    W3.F
0ACC:  MOV     #12,W5
0ACE:  REPEAT  #3
0AD0:  MOV     [--W15],[W5--]
0AD2:  MOV     [--W15],W5
0AD4:  RETURN  
0AD6:  MOV     W8,[W15++]
0AD8:  MOV     #12,W8
0ADA:  REPEAT  #4
0ADC:  MOV     [W8++],[W15++]
0ADE:  CLR     W11
0AE0:  MUL.UU  W12,#0,W12
0AE2:  MOV     W3,W8
0AE4:  MOV     W7,W9
0AE6:  MOV     #7FF,W10
0AE8:  BCLR.B  42.0
0AEA:  BCLR.B  42.1
0AEC:  ASR     W8,#4,W8
0AEE:  AND     W10,W8,W8
0AF0:  CP0     W8
0AF2:  BRA     Z,BD6
0AF4:  BCLR.B  42.0
0AF6:  BCLR.B  42.1
0AF8:  ASR     W9,#4,W9
0AFA:  AND     W10,W9,W9
0AFC:  CP0     W9
0AFE:  BRA     Z,BD6
0B00:  ADD     W9,W8,W8
0B02:  BTSC    W9.B
0B04:  BRA     B0E
0B06:  SUB     #3FF,W8
0B08:  BRA     Z,BD6
0B0A:  BRA     NC,BD6
0B0C:  BRA     B14
0B0E:  MOV     #401,W10
0B10:  ADD.B   W10L,W5L,W5L
0B12:  BRA     C,BD6
0B14:  XOR     W3,W7,W13
0B16:  BCLR.B  42.0
0B18:  BCLR.B  42.1
0B1A:  AND     #F,W3
0B1C:  BSET    W3.4
0B1E:  AND     #F,W7
0B20:  BSET    W7.4
0B22:  MOV     W8,[W15++]
0B24:  MUL.UU  W4,W1,W8
0B26:  MUL.UU  W5,W0,W10
0B28:  ADD     W8,W10,W10
0B2A:  ADDC    W9,W11,W11
0B2C:  ADDC    #0,W12
0B2E:  MUL.UU  W4,W2,W8
0B30:  ADD     W8,W11,W11
0B32:  ADDC    W9,W12,W12
0B34:  MUL.UU  W5,W1,W8
0B36:  CLR     W10
0B38:  ADD     W8,W11,W11
0B3A:  ADDC    W9,W12,W12
0B3C:  ADDC    #0,W10
0B3E:  MUL.UU  W6,W0,W8
0B40:  ADD     W8,W11,W11
0B42:  ADDC    W9,W12,W12
0B44:  ADDC    #0,W10
0B46:  CLR     W11
0B48:  MUL.UU  W4,W3,W8
0B4A:  ADD     W8,W12,W12
0B4C:  ADDC    W9,W10,W10
0B4E:  ADDC    #0,W11
0B50:  MUL.UU  W5,W2,W8
0B52:  ADD     W8,W12,W12
0B54:  ADDC    W9,W10,W10
0B56:  ADDC    #0,W11
0B58:  MUL.UU  W6,W1,W8
0B5A:  ADD     W8,W12,W12
0B5C:  ADDC    W9,W10,W10
0B5E:  ADDC    #0,W11
0B60:  MUL.UU  W7,W0,W8
0B62:  ADD     W8,W12,W12
0B64:  ADDC    W9,W10,W10
0B66:  ADDC    #0,W11
0B68:  MOV     W12,W0
0B6A:  CLR     W12
0B6C:  MUL.UU  W5,W3,W8
0B6E:  ADD     W8,W10,W10
0B70:  ADDC    W9,W11,W11
0B72:  ADDC    #0,W12
0B74:  MUL.UU  W6,W2,W8
0B76:  ADD     W8,W10,W10
0B78:  ADDC    W9,W11,W11
0B7A:  ADDC    #0,W12
0B7C:  MUL.UU  W6,W3,W8
0B7E:  ADD     W8,W11,W11
0B80:  ADDC    W9,W12,W12
0B82:  MUL.UU  W7,W1,W8
0B84:  ADD     W8,W10,W10
0B86:  ADDC    W9,W11,W11
0B88:  ADDC    #0,W12
0B8A:  MUL.UU  W7,W2,W8
0B8C:  ADD     W8,W11,W11
0B8E:  ADDC    W9,W12,W12
0B90:  MUL.UU  W7,W3,W8
0B92:  ADD     W8,W12,W12
0B94:  MOV     W10,W1
0B96:  MOV     W11,W2
0B98:  MOV     W12,W3
0B9A:  MOV     #5,W4
0B9C:  BCLR.B  42.0
0B9E:  RRC     W3,W3
0BA0:  RRC     W2,W2
0BA2:  RRC     W1,W1
0BA4:  RRC     W0,W0
0BA6:  DEC     W4,W4
0BA8:  BRA     NZ,B9C
0BAA:  MOV     [--W15],W8
0BAC:  INC     W8,W8
0BAE:  IOR      W0,  W1,W6
0BB0:  BRA     Z,BB4
0BB2:  BRA     BB8
0BB4:  IOR      W2,  W3,W6
0BB6:  BRA     Z,BC8
0BB8:  BTSC    W3.4
0BBA:  BRA     BC8
0BBC:  BCLR.B  42.0
0BBE:  RLC     W0,W0
0BC0:  RLC     W1,W1
0BC2:  RLC     W2,W2
0BC4:  RLC     W3,W3
0BC6:  DEC     W8,W8
0BC8:  SL      W8,#4,W8
0BCA:  BCLR    W3.F
0BCC:  BTSC    W13.F
0BCE:  BSET    W3.F
0BD0:  BCLR    W3.4
0BD2:  XOR     W8,W3,W3
0BD4:  BRA     BDC
0BD6:  MUL.UU  W0,#0,W0
0BD8:  MUL.UU  W0,#0,W2
0BDA:  BRA     BDC
0BDC:  MOV     #1A,W8
0BDE:  REPEAT  #4
0BE0:  MOV     [--W15],[W8--]
0BE2:  MOV     [--W15],W8
0BE4:  RETURN  
0BE6:  MOV     W8,[W15++]
0BE8:  MOV     #12,W8
0BEA:  REPEAT  #4
0BEC:  MOV     [W8++],[W15++]
0BEE:  XOR     W3,W7,W13
0BF0:  MOV     W3,W8
0BF2:  MOV     W7,W9
0BF4:  MOV     #7FF,W10
0BF6:  BCLR.B  42.0
0BF8:  BCLR.B  42.1
0BFA:  ASR     W8,#4,W8
0BFC:  AND     W10,W8,W8
0BFE:  CP0     W8
0C00:  BRA     Z,CDA
0C02:  BCLR.B  42.0
0C04:  BCLR.B  42.1
0C06:  ASR     W9,#4,W9
0C08:  AND     W10,W9,W9
0C0A:  CP0     W9
0C0C:  BRA     Z,CDA
0C0E:  CLR     W10
0C10:  SUB     W8,W9,W12
0C12:  BRA     NC,C1A
0C14:  ADD     #3FF,W12
0C16:  BRA     C,CDA
0C18:  BRA     C22
0C1A:  MOV     #401,W11
0C1C:  SUB     W12,W11,W12
0C1E:  BRA     NC,CDA
0C20:  BRA     Z,CDA
0C22:  CLR     W8
0C24:  CLR     W9
0C26:  CLR     W10
0C28:  CLR     W11
0C2A:  AND     #1F,W3
0C2C:  BSET    W3.4
0C2E:  AND     #1F,W7
0C30:  BSET    W7.4
0C32:  MOV     W12,[W15++]
0C34:  MOV     #36,W12
0C36:  SUB     W0,W4,W0
0C38:  SUBB    W1,W5,W1
0C3A:  SUBB    W2,W6,W2
0C3C:  SUBB    W3,W7,W3
0C3E:  BRA     N,C44
0C40:  BRA     C,C4E
0C42:  BRA     NZ,C50
0C44:  ADD     W0,W4,W0
0C46:  ADDC    W1,W5,W1
0C48:  ADDC    W2,W6,W2
0C4A:  ADDC    W3,W7,W3
0C4C:  BRA     C50
0C4E:  BSET    W8.0
0C50:  DEC     W12,W12
0C52:  BRA     Z,C6A
0C54:  BCLR.B  42.0
0C56:  RLC     W0,W0
0C58:  RLC     W1,W1
0C5A:  RLC     W2,W2
0C5C:  RLC     W3,W3
0C5E:  BCLR.B  42.0
0C60:  RLC     W8,W8
0C62:  RLC     W9,W9
0C64:  RLC     W10,W10
0C66:  RLC     W11,W11
0C68:  BRA     C36
0C6A:  MOV     [--W15],W12
0C6C:  BTSC    W11.5
0C6E:  BRA     C72
0C70:  BRA     C7E
0C72:  BCLR.B  42.0
0C74:  RRC     W11,W11
0C76:  RRC     W10,W10
0C78:  RRC     W9,W9
0C7A:  RRC     W8,W8
0C7C:  BRA     C84
0C7E:  DEC     W12,W12
0C80:  BCLR.B  42.0
0C82:  BRA     Z,CDA
0C84:  BTSC.B  42.0
0C86:  BRA     C9A
0C88:  RLC     W0,W0
0C8A:  RLC     W1,W1
0C8C:  RLC     W2,W2
0C8E:  RLC     W3,W3
0C90:  SUB     W0,W4,W4
0C92:  SUBB    W1,W5,W5
0C94:  SUBB    W2,W6,W6
0C96:  SUBB    W3,W7,W7
0C98:  BRA     NC,CC4
0C9A:  INC     W8,W8
0C9C:  BRA     NZ,CC4
0C9E:  INC     W9,W9
0CA0:  BRA     NZ,CC4
0CA2:  INC     W10,W10
0CA4:  BRA     NZ,CC4
0CA6:  INC     W11,W11
0CA8:  BRA     NZ,CC4
0CAA:  INC     W12,W12
0CAC:  BRA     Z,CDA
0CAE:  BRA     CC4
0CB0:  DEC     W12,W12
0CB2:  BRA     Z,CDA
0CB4:  BTSC    W11.4
0CB6:  BRA     CC4
0CB8:  BCLR.B  42.0
0CBA:  RLC     W8,W8
0CBC:  RLC     W9,W9
0CBE:  RLC     W10,W10
0CC0:  RLC     W11,W11
0CC2:  BRA     CB4
0CC4:  SL      W12,#4,W12
0CC6:  BCLR.B  42.0
0CC8:  BCLR    W12.F
0CCA:  BTSC    W13.F
0CCC:  BSET    W12.F
0CCE:  BCLR    W11.4
0CD0:  XOR     W12,W11,W3
0CD2:  MOV     W10,W2
0CD4:  MOV     W9,W1
0CD6:  MOV     W8,W0
0CD8:  BRA     CE4
0CDA:  MOV     #0,W0
0CDC:  MOV     #0,W1
0CDE:  MOV     #0,W2
0CE0:  MOV     #0,W3
0CE2:  BRA     CE4
0CE4:  MOV     #1A,W8
0CE6:  REPEAT  #4
0CE8:  MOV     [--W15],[W8--]
0CEA:  MOV     [--W15],W8
0CEC:  RETURN  
0CEE:  MOV     W8,[W15++]
0CF0:  MOV     #12,W8
0CF2:  REPEAT  #4
0CF4:  MOV     [W8++],[W15++]
0CF6:  MOV     #8000,W8
0CF8:  BTSC.B  43.0
0CFA:  XOR     W8,W7,W7
0CFC:  CP0     W0
0CFE:  BRA     NZ,D0E
0D00:  CP0     W1
0D02:  BRA     NZ,D0E
0D04:  CP0     W2
0D06:  BRA     NZ,D0E
0D08:  MOV     #7FFF,W10
0D0A:  AND     W3,W10,W10
0D0C:  BTSS.B  42.1
0D0E:  MOV     W3,W10
0D10:  XOR     W7,W10,W11
0D12:  MOV     W3,W8
0D14:  MOV     W7,W9
0D16:  MOV     W7,W12
0D18:  MOV     #7FF,W13
0D1A:  BCLR.B  42.1
0D1C:  BCLR.B  42.0
0D1E:  ASR     W8,#4,W8
0D20:  AND     W13,W8,W8
0D22:  CP0     W8
0D24:  BRA     Z,E9E
0D26:  BCLR.B  42.1
0D28:  BCLR.B  42.0
0D2A:  ASR     W9,#4,W9
0D2C:  AND     W13,W9,W9
0D2E:  CP0     W9
0D30:  BRA     Z,EAE
0D32:  CLR     W13
0D34:  BCLR.B  42.1
0D36:  BCLR.B  42.0
0D38:  CP      W9,W8
0D3A:  BRA     Z,EB0
0D3C:  BRA     N,EC0
0D3E:  BCLR    W13.0
0D40:  BSET    W13.1
0D42:  SUB     W9,W8,W8
0D44:  AND     #F,W3
0D46:  BSET    W3.4
0D48:  AND     #F,W7
0D4A:  BSET    W7.4
0D4C:  SUB     #34,W8
0D4E:  BRA     NN,D7C
0D50:  ADD     #34,W8
0D52:  BCLR.B  42.1
0D54:  BCLR.B  42.0
0D56:  RRC     W3,W3
0D58:  RRC     W2,W2
0D5A:  RRC     W1,W1
0D5C:  RRC     W0,W0
0D5E:  DEC     W8,W8
0D60:  BRA     NZ,D52
0D62:  BRA     D8C
0D64:  SUB     #34,W8
0D66:  BRA     NN,D86
0D68:  ADD     #34,W8
0D6A:  BCLR.B  42.1
0D6C:  BCLR.B  42.0
0D6E:  RRC     W7,W7
0D70:  RRC     W6,W6
0D72:  RRC     W5,W5
0D74:  RRC     W4,W4
0D76:  DEC     W8,W8
0D78:  BRA     NZ,D6A
0D7A:  BRA     DB2
0D7C:  MOV     W4,W0
0D7E:  MOV     W5,W1
0D80:  MOV     W6,W2
0D82:  MOV     W7,W3
0D84:  XOR     W11,W12,W12
0D86:  BTSC    W12.F
0D88:  BTG     W11.F
0D8A:  BRA     E7E
0D8C:  BTSS    W11.F
0D8E:  BRA     DCE
0D90:  BTSC    W13.4
0D92:  MOV     W12,W11
0D94:  COM     W0,W0
0D96:  COM     W1,W1
0D98:  COM     W2,W2
0D9A:  COM.B   W3L,W3L
0D9C:  AND.B   #1F,W3L
0D9E:  INC     W0,W0
0DA0:  BRA     NZ,DAC
0DA2:  INC     W1,W1
0DA4:  BRA     NZ,DAC
0DA6:  INC     W2,W2
0DA8:  BRA     NZ,DAC
0DAA:  INC.B   W3L,W3L
0DAC:  BTSC    W13.4
0DAE:  BRA     E14
0DB0:  BRA     DCE
0DB2:  BTSS    W11.F
0DB4:  BRA     DCE
0DB6:  COM     W4,W4
0DB8:  COM     W5,W5
0DBA:  COM     W6,W6
0DBC:  COM.B   W7L,W7L
0DBE:  AND.B   #1F,W7L
0DC0:  INC     W4,W4
0DC2:  BRA     NZ,DCE
0DC4:  INC     W5,W5
0DC6:  BRA     NZ,DCE
0DC8:  INC     W6,W6
0DCA:  BRA     NZ,DCE
0DCC:  INC.B   W7L,W7L
0DCE:  BCLR.B  42.1
0DD0:  BCLR.B  42.0
0DD2:  ADD     W0,W4,W0
0DD4:  ADDC    W1,W5,W1
0DD6:  ADDC    W2,W6,W2
0DD8:  ADDC.B  W3L,W7L,W3L
0DDA:  BTSC    W3.5
0DDC:  BSET    W13.3
0DDE:  BTSC    W13.0
0DE0:  BRA     DF4
0DE2:  BTSC    W13.1
0DE4:  BRA     DE8
0DE6:  BRA     DFE
0DE8:  BTSC    W11.F
0DEA:  BRA     E14
0DEC:  BTSC    W13.3
0DEE:  BRA     E42
0DF0:  BSET    W13.6
0DF2:  BRA     E36
0DF4:  BTSC    W11.F
0DF6:  BRA     E14
0DF8:  BTSC    W13.3
0DFA:  BRA     E42
0DFC:  BRA     E36
0DFE:  BTSC    W11.F
0E00:  BRA     E0A
0E02:  MOV     W10,W11
0E04:  BTSC    W13.3
0E06:  BRA     E42
0E08:  BRA     E7E
0E0A:  BSET    W13.4
0E0C:  XOR.B   #10,W3L
0E0E:  BTSC    W3.4
0E10:  BRA     D90
0E12:  MOV     W10,W11
0E14:  AND     #1F,W3
0E16:  IOR      W3,  W2,W8
0E18:  BRA     NZ,E1E
0E1A:  IOR      W1,  W0,W8
0E1C:  BRA     Z,E36
0E1E:  BTSC    W3.4
0E20:  BRA     E36
0E22:  BCLR.B  42.1
0E24:  BCLR.B  42.0
0E26:  RLC     W0,W0
0E28:  RLC     W1,W1
0E2A:  RLC     W2,W2
0E2C:  RLC     W3,W3
0E2E:  DEC     W9,W9
0E30:  BTSC.B  42.1
0E32:  BRA     E98
0E34:  BRA     E1E
0E36:  BTSC    W13.0
0E38:  MOV     W10,W11
0E3A:  BTSC    W13.1
0E3C:  MOV     W12,W11
0E3E:  BTSS    W13.5
0E40:  BRA     E7E
0E42:  BCLR.B  42.0
0E44:  RRC.B   W3L,W3L
0E46:  RRC     W2,W2
0E48:  RRC     W1,W1
0E4A:  RRC     W0,W0
0E4C:  BTSC.B  42.0
0E4E:  BSET    W13.5
0E50:  INC     W9,W9
0E52:  BTSC.B  42.1
0E54:  BRA     E98
0E56:  BTSS    W13.5
0E58:  BRA     E76
0E5A:  INC     W0,W0
0E5C:  BRA     NZ,E76
0E5E:  INC     W1,W1
0E60:  BRA     NZ,E76
0E62:  INC     W2,W2
0E64:  BRA     NZ,E76
0E66:  INC     W3,W3
0E68:  BRA     NZ,E76
0E6A:  RRC.B   W3L,W3L
0E6C:  RRC     W2,W2
0E6E:  RRC     W1,W1
0E70:  RRC     W0,W0
0E72:  INC     W9,W9
0E74:  BRA     Z,E98
0E76:  BTSC    W13.0
0E78:  MOV     W10,W11
0E7A:  BTSC    W13.1
0E7C:  MOV     W12,W11
0E7E:  IOR      W0,  W1,W4
0E80:  BRA     NZ,E86
0E82:  IOR      W2,  W3,W4
0E84:  BRA     Z,ED2
0E86:  BCLR    W3.4
0E88:  BCLR.B  42.1
0E8A:  BCLR.B  42.0
0E8C:  SL      W9,#4,W9
0E8E:  XOR     W9,W3,W3
0E90:  BSET    W3.F
0E92:  BTSS    W11.F
0E94:  BCLR    W3.F
0E96:  BRA     ED2
0E98:  MUL.UU  W0,#0,W0
0E9A:  MUL.UU  W2,#0,W2
0E9C:  BRA     ED2
0E9E:  MOV     #8000,W8
0EA0:  BTSC    W10.F
0EA2:  XOR     W8,W7,W7
0EA4:  MOV     W5,W1
0EA6:  MOV     W4,W0
0EA8:  MOV     W6,W2
0EAA:  MOV     W7,W3
0EAC:  BRA     ED2
0EAE:  BRA     ED2
0EB0:  AND     #F,W7
0EB2:  BSET    W7.4
0EB4:  AND     #F,W3
0EB6:  BSET    W3.4
0EB8:  BTSC    W11.F
0EBA:  BCLR    W7.4
0EBC:  BSET    W13.2
0EBE:  BRA     DB2
0EC0:  AND     #F,W3
0EC2:  BSET    W3.4
0EC4:  AND     #F,W7
0EC6:  BSET    W7.4
0EC8:  SUB     W8,W9,W8
0ECA:  ADD     W8,W9,W9
0ECC:  BCLR    W13.1
0ECE:  BSET    W13.0
0ED0:  BRA     D64
0ED2:  MOV     #1A,W8
0ED4:  REPEAT  #4
0ED6:  MOV     [--W15],[W8--]
0ED8:  MOV     [--W15],W8
0EDA:  RETURN  
0EDC:  MOV     W8,[W15++]
0EDE:  MOV     W9,[W15++]
0EE0:  MOV     W10,[W15++]
0EE2:  XOR     W3,W7,W9
0EE4:  BTSS    W9.F
0EE6:  BRA     EF4
0EE8:  BCLR.B  42.0
0EEA:  BCLR.B  42.1
0EEC:  BTSS    W3.F
0EEE:  BRA     F58
0EF0:  BSET.B  42.0
0EF2:  BRA     F58
0EF4:  MOV     #7FF,W10
0EF6:  MOV     W3,W8
0EF8:  MOV     W7,W9
0EFA:  ASR     W8,#4,W8
0EFC:  AND     W10,W8,W8
0EFE:  ASR     W9,#4,W9
0F00:  AND     W10,W9,W9
0F02:  SUB     W9,W8,W10
0F04:  BRA     Z,F10
0F06:  BTSS    W3.F
0F08:  BRA     F58
0F0A:  MOV     #1,W0
0F0C:  XOR.B   42
0F0E:  BRA     F58
0F10:  MOV     W3,W8
0F12:  MOV     W7,W9
0F14:  AND     #1F,W3
0F16:  AND     #1F,W7
0F18:  BCLR    W3.4
0F1A:  BCLR    W7.4
0F1C:  SUB.B   W7L,W3L,W10L
0F1E:  BRA     Z,F2A
0F20:  BTSS    W8.F
0F22:  BRA     F58
0F24:  MOV     #1,W0
0F26:  XOR.B   42
0F28:  BRA     F58
0F2A:  SUB     W6,W2,W10
0F2C:  BRA     Z,F38
0F2E:  BTSS    W8.F
0F30:  BRA     F58
0F32:  MOV     #1,W0
0F34:  XOR.B   42
0F36:  BRA     F58
0F38:  SUB     W5,W1,W10
0F3A:  BRA     Z,F46
0F3C:  BTSS    W8.F
0F3E:  BRA     F58
0F40:  MOV     #1,W0
0F42:  XOR.B   42
0F44:  BRA     F58
0F46:  SUB     W4,W0,W10
0F48:  BRA     Z,F54
0F4A:  BTSS    W8.F
0F4C:  BRA     F58
0F4E:  MOV     #1,W0
0F50:  XOR.B   42
0F52:  BRA     F58
0F54:  BCLR.B  42.0
0F56:  BRA     F58
0F58:  MOV     [--W15],W10
0F5A:  MOV     [--W15],W9
0F5C:  MOV     [--W15],W8
0F5E:  RETURN  
0F60:  MOV     W5,[W15++]
0F62:  MOV     #C,W5
0F64:  REPEAT  #5
0F66:  MOV     [W5++],[W15++]
0F68:  MOV     W3,W8
0F6A:  MOV     W2,W7
0F6C:  MOV     W1,W6
0F6E:  MOV     W0,W5
0F70:  MOV     W3,W9
0F72:  MOV     #473,W11
0F74:  ASR     W3,#4,W3
0F76:  MOV     #7FF,W10
0F78:  AND     W10,W3,W3
0F7A:  SUB     W11,W3,W11
0F7C:  AND     #1F,W8
0F7E:  BSET    W8.4
0F80:  CLR     W0
0F82:  CLR     W1
0F84:  CLR     W2
0F86:  CLR     W3
0F88:  BCLR.B  42.0
0F8A:  RRC     W8,W8
0F8C:  RRC     W7,W7
0F8E:  RRC     W6,W6
0F90:  RRC     W5,W5
0F92:  RRC     W3,W3
0F94:  RRC     W2,W2
0F96:  RRC     W1,W1
0F98:  RRC     W0,W0
0F9A:  DEC     W11,W11
0F9C:  BRA     NZ,F88
0F9E:  BTSS    W9.F
0FA0:  BRA     FB4
0FA2:  COM     W0,W0
0FA4:  COM     W1,W1
0FA6:  COM     W2,W2
0FA8:  COM     W3,W3
0FAA:  INC     W0,W0
0FAC:  ADDC    #0,W1
0FAE:  ADDC    #0,W2
0FB0:  ADDC    #0,W3
0FB2:  BRA     FB4
0FB4:  MOV     #16,W5
0FB6:  REPEAT  #5
0FB8:  MOV     [--W15],[W5--]
0FBA:  MOV     [--W15],W5
0FBC:  RETURN  
*
12A2:  MOV     W5,[W15++]
12A4:  MOV     #C,W5
12A6:  REPEAT  #5
12A8:  MOV     [W5++],[W15++]
12AA:  MOV     W3,W8
12AC:  MOV     W2,W7
12AE:  MOV     W1,W6
12B0:  MOV     W0,W5
12B2:  MOV     W3,W9
12B4:  MOV     #473,W11
12B6:  ASR     W3,#4,W3
12B8:  MOV     #7FF,W10
12BA:  AND     W10,W3,W3
12BC:  SUB     W11,W3,W11
12BE:  AND     #1F,W8
12C0:  BSET    W8.4
12C2:  CLR     W0
12C4:  CLR     W1
12C6:  CLR     W2
12C8:  CLR     W3
12CA:  BCLR.B  42.0
12CC:  RRC     W8,W8
12CE:  RRC     W7,W7
12D0:  RRC     W6,W6
12D2:  RRC     W5,W5
12D4:  RRC     W3,W3
12D6:  RRC     W2,W2
12D8:  RRC     W1,W1
12DA:  RRC     W0,W0
12DC:  DEC     W11,W11
12DE:  BRA     NZ,12CA
12E0:  BTSS    W9.F
12E2:  BRA     12F6
12E4:  COM     W0,W0
12E6:  COM     W1,W1
12E8:  COM     W2,W2
12EA:  COM     W3,W3
12EC:  INC     W0,W0
12EE:  ADDC    #0,W1
12F0:  ADDC    #0,W2
12F2:  ADDC    #0,W3
12F4:  BRA     12F6
12F6:  MOV     #16,W5
12F8:  REPEAT  #5
12FA:  MOV     [--W15],[W5--]
12FC:  MOV     [--W15],W5
12FE:  RETURN  
*
13C8:  MOV     W6,[W15++]
13CA:  MOV     W7,[W15++]
13CC:  MOV     W8,[W15++]
13CE:  MOV     W9,[W15++]
13D0:  CLR     W4
13D2:  CLR     W5
13D4:  CLR     W6
13D6:  CLR     W7
13D8:  XOR     W2,W3,W8
13DA:  BRA     Z,13FE
13DC:  MOV     #20,W8
13DE:  BCLR.B  42.0
13E0:  RLC     W0,W0
13E2:  RLC     W1,W1
13E4:  RLC     W4,W4
13E6:  RLC     W5,W5
13E8:  CP      W5,W3
13EA:  BRA     NZ,13EE
13EC:  CPB     W4,W2
13EE:  BRA     NC,13F6
13F0:  SUB     W4,W2,W4
13F2:  SUBB    W5,W3,W5
13F4:  BSET.B  42.0
13F6:  RLC     W6,W6
13F8:  RLC     W7,W7
13FA:  DEC     W8,W8
13FC:  BRA     NZ,13DE
13FE:  MOV     W7,W1
1400:  MOV     W6,W0
1402:  MOV     [--W15],W9
1404:  MOV     [--W15],W8
1406:  MOV     [--W15],W7
1408:  MOV     [--W15],W6
140A:  RETURN  
140C:  MOV     W5,[W15++]
140E:  MOV     #C,W5
1410:  REPEAT  #7
1412:  MOV     [W5++],[W15++]
1414:  BTSS    W1.F
1416:  BRA     1426
1418:  NEG     W0,W0
141A:  BRA     Z,141E
141C:  BRA     NZ,1422
141E:  NEG     W1,W1
1420:  BRA     1424
1422:  COM     W1,W1
1424:  BSET    W4.8
1426:  CLR     W5
1428:  MOV     W0,W6
142A:  MOV     W1,W7
142C:  MOV     W4,W12
142E:  BCLR    W4.F
1430:  CP0.B   W4L
1432:  BRA     NZ,1436
1434:  BRA     147E
1436:  SUB.B   W4L,#B,W5L
1438:  BRA     NC,147E
143A:  SUB.B   W4L,W5L,W4L
143C:  BTSS    W12.F
143E:  BRA     1460
1440:  BTSS    W4.8
1442:  BRA     145C
1444:  MOV     #2D,W0
1446:  MOV     W1,[W15++]
1448:  MOV     W4,[W15++]
144A:  MOV     W0,[W15++]
144C:  MOV     [--W15],W0
144E:  CALL    A06
1452:  MOV     [--W15],W4
1454:  MOV     [--W15],W1
1456:  BCLR    W4.8
1458:  DEC     W5,W5
145A:  BRA     N,147E
145C:  MOV     #30,W0
145E:  BRA     1462
1460:  MOV     #20,W0
1462:  MOV     W0,[W15++]
1464:  MOV     W1,[W15++]
1466:  MOV     W4,[W15++]
1468:  MOV     W0,[W15++]
146A:  MOV     [--W15],W0
146C:  CALL    A06
1470:  MOV     [--W15],W4
1472:  MOV     [--W15],W1
1474:  MOV     [--W15],W0
1476:  DEC     W5,W5
1478:  BRA     NN,1462
147A:  BTSC    W4.8
147C:  DEC.B   W4L,W4L
147E:  MOV     #E,W8
1480:  MOV     #0,W9
1482:  LNK     #10
1484:  MOV     W12,[W14+W8]
1486:  DEC2    W8,W8
1488:  BRA     NN,1484
148A:  MOV     W4,W5
148C:  MOV     #A,W4
148E:  BTSC    W5.8
1490:  INC     W4,W4
1492:  BSET    W5.E
1494:  BTSC    W12.F
1496:  BSET    W5.F
1498:  CP0.B   W5L
149A:  BRA     Z,149E
149C:  DEC.B   W5L,W5L
149E:  MOV     W4,[W14]
14A0:  MOV     W5,[W14+#2]
14A2:  MOV     W6,W0
14A4:  MOV     W7,W1
14A6:  MOV     #CA00,W2
14A8:  MOV     #3B9A,W3
14AA:  MOV     #2710,W8
14AC:  BCLR    W13.F
14AE:  BCLR.B  43.0
14B0:  CALL    13C8
14B4:  BTG     W13.F
14B6:  BTSC    W13.F
14B8:  BRA     14C8
14BA:  MOV     W0,[W14+#8]
14BC:  MOV     W1,[W14+#A]
14BE:  MOV     W0,W2
14C0:  MOV     W1,W3
14C2:  MOV     [W14+#4],W0
14C4:  MOV     [W14+#6],W1
14C6:  BRA     14AE
14C8:  MOV     W2,[W14+#8]
14CA:  MOV     W3,[W14+#A]
14CC:  MOV     W4,[W14+#4]
14CE:  MOV     W5,[W14+#6]
14D0:  MOV     [W14],W4
14D2:  MOV     [W14+#2],W5
14D4:  MOV     #30,W6
14D6:  CP0     W0
14D8:  BRA     NZ,14FC
14DA:  BTSS    W5.E
14DC:  BRA     1500
14DE:  DEC     W4,W4
14E0:  MOV     W4,[W14]
14E2:  CP0     W4
14E4:  BRA     Z,1500
14E6:  CP.B    W4L,W5L
14E8:  BRA     Z,14EE
14EA:  BTSC.B  42.0
14EC:  BRA     152A
14EE:  BTSS    W5.F
14F0:  BRA     14F8
14F2:  BTSS    W5.8
14F4:  BRA     151C
14F6:  BRA     1506
14F8:  MOV     #20,W6
14FA:  BRA     151C
14FC:  BCLR    W5.E
14FE:  MOV     W5,[W14+#2]
1500:  MOV     [W14+#2],W5
1502:  BTSS    W5.8
1504:  BRA     151C
1506:  BCLR    W5.8
1508:  MOV     W5,[W14+#2]
150A:  MOV     W0,W10
150C:  MOV     #2D,W0
150E:  MOV     W4,[W15++]
1510:  MOV     W0,[W15++]
1512:  MOV     [--W15],W0
1514:  CALL    A06
1518:  MOV     [--W15],W4
151A:  MOV     W10,W0
151C:  ADD.B   W6L,W0L,W0L
151E:  MOV     W4,[W15++]
1520:  MOV     W0,[W15++]
1522:  MOV     [--W15],W0
1524:  CALL    A06
1528:  MOV     [--W15],W4
152A:  MOV     [W14+#8],W0
152C:  MOV     [W14+#A],W1
152E:  MOV     #A,W2
1530:  CLR     W3
1532:  CP      W0,#1
1534:  BRA     Z,1538
1536:  BRA     14AE
1538:  ULNK    
153A:  MOV     #1A,W5
153C:  REPEAT  #7
153E:  MOV     [--W15],[W5--]
1540:  MOV     [--W15],W5
1542:  RETURN  
1544:  MOV     W5,[W15++]
1546:  MOV     #C,W5
1548:  REPEAT  #3
154A:  MOV     [W5++],[W15++]
154C:  BTSS    W0.F
154E:  BRA     156E
1550:  NEG     W0,W0
1552:  BSET    W4.8
1554:  BTSS    W4.F
1556:  BRA     156E
1558:  MOV     W0,[W15++]
155A:  MOV     #2D,W0
155C:  MOV     W4,[W15++]
155E:  MOV     W0,[W15++]
1560:  MOV     [--W15],W0
1562:  CALL    A06
1566:  MOV     [--W15],W4
1568:  MOV     [--W15],W0
156A:  BCLR    W4.8
156C:  DEC.B   0008
156E:  CLR     W5
1570:  MOV     W0,W7
1572:  MOV     W4,W9
1574:  BCLR    W4.F
1576:  CP0.B   W4L
1578:  BRA     NZ,1586
157A:  BTSC    W9.F
157C:  BRA     1582
157E:  MOV     #0,W5
1580:  BRA     15B0
1582:  MOV     #0,W5
1584:  BRA     15B0
1586:  BTSS    W9.8
1588:  SUB.B   W4L,#6,W5L
158A:  BTSC    W9.8
158C:  SUB.B   W4L,#7,W5L
158E:  BRA     NC,15AE
1590:  MOV     #30,W0
1592:  BTSS    W9.F
1594:  MOV     #20,W0
1596:  MOV     W0,[W15++]
1598:  MOV     W4,[W15++]
159A:  MOV     W0,[W15++]
159C:  MOV     [--W15],W0
159E:  CALL    A06
15A2:  MOV     [--W15],W4
15A4:  MOV     [--W15],W0
15A6:  DEC     W5,W5
15A8:  BRA     NN,1596
15AA:  MOV     #5,W5
15AC:  BRA     15B0
15AE:  MOV     W4,W5
15B0:  MOV     #6,W4
15B2:  BTSC    W5.8
15B4:  INC     W4,W4
15B6:  BSET    W5.E
15B8:  BTSC    W9.F
15BA:  BSET    W5.F
15BC:  MOV     #2710,W8
15BE:  REPEAT  #11
15C0:  DIV.U   W7,W8
15C2:  CALL    1616
15C6:  MOV     W1,W7
15C8:  MOV     #3E8,W8
15CA:  REPEAT  #11
15CC:  DIV.U   W7,W8
15CE:  CALL    1616
15D2:  MOV     W1,W7
15D4:  MOV     #64,W8
15D6:  REPEAT  #11
15D8:  DIV.U   W7,W8
15DA:  CALL    1616
15DE:  MOV     W1,W7
15E0:  MOV     #A,W8
15E2:  REPEAT  #11
15E4:  DIV.U   W7,W8
15E6:  CALL    1616
15EA:  BTSS    W9.8
15EC:  BRA     1602
15EE:  MOV     #2D,W0
15F0:  MOV     W1,[W15++]
15F2:  MOV     W4,[W15++]
15F4:  MOV     W0,[W15++]
15F6:  MOV     [--W15],W0
15F8:  CALL    A06
15FC:  MOV     [--W15],W4
15FE:  MOV     [--W15],W1
1600:  BCLR    W9.8
1602:  MOV     #30,W0
1604:  ADD.B   W1L,W0L,W0L
1606:  MOV     W0,2A
1608:  MOV     W4,[W15++]
160A:  MOV     W0,[W15++]
160C:  MOV     [--W15],W0
160E:  CALL    A06
1612:  MOV     [--W15],W4
1614:  BRA     166A
1616:  MOV     #30,W6
1618:  CP0     W0
161A:  BRA     NZ,1638
161C:  BTSS    W5.E
161E:  BRA     1656
1620:  DEC     W4,W4
1622:  CP.B    W4L,W5L
1624:  BRA     Z,162A
1626:  BTSC.B  42.0
1628:  RETURN  
162A:  CP0     W0
162C:  BRA     NZ,1638
162E:  BTSS    W5.E
1630:  BRA     1656
1632:  BTSS    W5.F
1634:  MOV     #20,W6
1636:  BRA     1656
1638:  BCLR    W5.E
163A:  BTSS    W9.8
163C:  BRA     1656
163E:  MOV     W0,W10
1640:  MOV     #2D,W0
1642:  MOV     W1,[W15++]
1644:  MOV     W4,[W15++]
1646:  MOV     W0,[W15++]
1648:  MOV     [--W15],W0
164A:  CALL    A06
164E:  MOV     [--W15],W4
1650:  MOV     [--W15],W1
1652:  BCLR    W9.8
1654:  MOV     W10,W0
1656:  ADD.B   W6L,W0L,W0L
1658:  MOV     W1,[W15++]
165A:  MOV     W4,[W15++]
165C:  MOV     W0,[W15++]
165E:  MOV     [--W15],W0
1660:  CALL    A06
1664:  MOV     [--W15],W4
1666:  MOV     [--W15],W1
1668:  RETURN  
166A:  MOV     #12,W5
166C:  REPEAT  #3
166E:  MOV     [--W15],[W5--]
1670:  MOV     [--W15],W5
1672:  RETURN  
.................... 
.................... #list
.................... 
.................... #include <Inc/lookup_tables.h>
.................... // lookup table for 16bit timer
.................... //!const int timer_table[] = {
.................... //!1036,1036,1036,1036,1036,1036,1036,1036,1036,1036,
.................... //!1036,1036,1036,1036,1036,1036,1036,1036,1036,1036,
.................... //!1036,1021,1006,992,978,964,950,936,923,910,897,884,
.................... //!871,859,847,835,823,811,799,788,777,766,755,744,733,
.................... //!723,713,703,693,683,673,663,654,645,636,627,618,609,
.................... //!600,591,583,575,567,559,551,543,535,527,519,512,505,
.................... //!498,491,484,477,470,463,456,449,443,437,431,425,419,
.................... //!413,407,401,395,389,383,378,373,368,363,358,353,348,
.................... //!343,338,333,328,323,318,313,309,305,301,297,293,289,
.................... //!285,281,277,273,269,265,261,257,253,249,245, 241,238,
.................... //!235,232,229,226,223,220,217,214,211,208,205,202,199,
.................... //!196,193,190,187,184,181,178,175,172,170,168,166,164,
.................... //!162,160,158,156,154,152,150,148,146,144,142,140,138,
.................... //!136,134,132,130,128,126,124,122,120,118,116,114,112,
.................... //!110,108,106,104,102,101,100,99,98,97,96,95,94,93,92,
.................... //!91,90,89,88,87,86,85,84,83,82,81,80,79,78,77,76,75,
.................... //!74,73,72,71,70,69,68,67,66,65,64,63,62,61,60,59,58,
.................... //!57,56,55,54,53,52,51,50,49,48,47,46,45,44,43,42,41,
.................... //!40,39,38,37,36,35,34,33,33,33,33,33,33,33,33};
.................... 
.................... //!const int freq_table[] = {
.................... //!8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,17,17,18,18,19,19,20,
.................... //!20,21,21,22,22,23,23,24,24,25,25,26,27,27,28,28,29,29,30,30,31,31,32,32,33,34,34,35,35,36,36,37,
.................... //!37,38,39,39,40,40,41,41,42,42,43,44,44,45,45,46,46,47,48,48,49,49,50,50,51,52,52,53,53,54,55,55,
.................... //!56,56,57,58,58,59,60,60,61,61,62,63,63,64,65,65,66,67,67,68,69,69,70,71,71,72,73,73,74,75,75,76,
.................... //!77,78,78,79,80,81,81,82,83,84,84,85,86,87,87,88,89,90,91,92,92,93,94,95,96,97,98,98,99,100,101,102,
.................... //!103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,121,122,123,124,125,126,128,129,
.................... //!130,131,133,134,135,137,138,140,141,142,144,145,147,148,150,151,153,155,156,158,160,161,163,165,166,
.................... //!168,170,172,174,176,178,180,182,184,186,188,190,193,195,197,199,202,204,207,209,212,214,217,220,222,
.................... //!225,228,231,234,237,240,243,246,250
.................... //!};
.................... 
.................... //!
.................... //!const int ascend_speed_table[] = {
.................... //!23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,26,26,30,30,33,33,36,36,39,39,
.................... //!42,42,45,45,48,51,51,54,54,57,57,60,60,63,63,66,66,69,69,73,73,76,76,79,82,82,85,85,88,88,91,91,94,
.................... //!94,97,97,100,103,103,106,106,109,109,112,112,116,119,119,122,122,125,125,128,128,131,134,134,137,137,
.................... //!140,140,143,146,146,149,149,152,152,155,159,159,162,162,165,168,168,171,171,174,177,177,180,183,183,
.................... //!186,186,189,192,192,195,198,198,202,205,205,208,211,211,214,217,217,220,223,223,226,229,229,232,235,
.................... //!238,238,241,245,248,248,251,254,257,257,260,263,266,266,269,272,275,278,281,281,284,288,291,294,297,
.................... //!300,300,303,306,309,312,315,318,321,324,327,331,334,337,340,343,346,349,352,355,358,361,364,370,374,
.................... //!377,380,383,386,392,395,398,401,407,410,413,420,423,429,432,435,441,444,450,453,459,463,469,475,478,
.................... //!484,490,493,499,506,509,515,521,527,533,539,545,552,558,564,570,576,582,592,598,604,610,619,625,635,
.................... //!641,650,656,665,674,681,690,699,708,717,727,736,745,754,767
.................... //!};
.................... //!
.................... 
.................... const int ascend_speed_table[] = 
.................... {
.................... 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,23,26,26,29,29,32,32,34,34,37,37,40,40,43,43,46,49,49,51,
.................... 51,54,54,57,57,60,60,63,63,66,66,68,68,71,71,74,77,77,80,80,83,83,86,86,88,88,91,91,95,97,97,100,100,
.................... 103,103,105,105,108,112,112,114,114,117,117,120,120,122,126,126,129,129,131,131,134,137,137,140,140,
.................... 143,143,146,149,149,151,151,154,157,157,160,160,163,166,166,168,171,171,174,174,177,180,180,183,185,
.................... 185,188,191,191,194,197,197,200,203,203,205,208,208,212,214,214,217,220,222,222,226,229,231,231,234,
.................... 237,239,239,243,246,248,248,251,254,257,260,263,263,266,268,271,274,277,280,280,283,285,288,291,294,
.................... 297,300,302,305,308,311,314,317,320,322,325,329,331,334,337,339,346,348,351,354,356,360,365,368,371,
.................... 374,380,383,385,391,394,400,402,405,411,414,419,422,428,431,437,442,446,451,456,460,465,471,473,480,
.................... 485,491,497,502,508,514,519,525,531,536,542,551,556,563,568,577,582,590,597,605,611,619,628,634,642,
.................... 651,659,668,677,685,694,702,714
.................... };
.................... 
.................... const int descend_speed_table[] = 
.................... {
.................... 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,25,29,29,32,32,35,35,37,37,41,41,44,44,47,47,51,54,54,56,
.................... 56,59,59,63,63,66,66,69,69,73,73,75,75,78,78,81,85,85,88,88,91,91,95,95,97,97,100,100,105,107,107,
.................... 110,110,113,113,116,116,119,123,123,125,125,129,129,132,132,134,139,139,142,142,144,144,147,151,151,
.................... 154,154,157,157,161,164,164,166,166,169,173,173,176,176,179,183,183,185,188,188,191,191,195,198,198,
.................... 201,204,204,207,210,210,213,217,217,220,223,223,226,229,229,233,235,235,239,242,244,244,249,252,254,
.................... 254,257,261,263,263,267,271,273,273,276,279,283,286,289,289,293,295,298,301,305,308,308,311,314,317,
.................... 320,323,327,330,332,336,339,342,345,349,352,354,358,362,364,367,371,373,381,383,386,389,392,396,402,
.................... 405,408,411,418,421,424,430,433,440,442,446,452,455,461,464,471,474,481,486,491,496,502,506,512,518,
.................... 520,528,534,540,547,552,559,565,571,578,584,590,596,606,612,619,625,635,640,649,657,666,672,681,691,
.................... 697,706,716,725,735,745,754,763,772,785
.................... 
.................... };
.................... 
.................... const int timer_table[] = {
.................... 65068,65068,65068,65068,65068,65068,65068,65068,65068,65068,65068,65068,65068,65068,65068,65068,
.................... 65068,65068,65068,65068,65068,61218,57795,54733,51977,49484,47217,45148,43251,41505,39894,38402,
.................... 37016,35726,34522,33395,32339,31346,30412,29531,28699,27912,27165,26458,25785,25145,24535,23954,
.................... 23399,22868,22360,21874,21408,20961,20531,20118,19721,19339,18971,18616,18273,17943,17624,17315,
.................... 17017,16728,16448,16177,15915,15660,15413,15173,14940,14714,14494,14280,14072,13869,13672,13480,
.................... 13292,13110,12932,12758,12589,12423,12262,12104,11950,11799,11652,11508,11367,11229,11094,10962,
.................... 10832,10705,10581,10459,10340,10223,10108,9995,9884,9776,9669,9564,9461,9360,9261,9163,9067,8973,
.................... 8880,8789,8699,8611,8523,8438,8353,8270,8188,8108,8028,7950,7873,7796,7721,7647,7574,7502,7431,7361,
.................... 7291,7223,7155,7089,7023,6958,6893,6830,6767,6705,6643,6582,6522,6463,6404,6346,6289,6232,6175,6120,
.................... 6064,6010,5955,5902,5849,5796,5744,5692,5641,5590,5540,5490,5441,5392,5343,5295,5247,5200,5153,5106,
.................... 5059,5013,4968,4923,4878,4833,4789,4745,4701,4657,4614,4572,4529,4487,4445,4403,4362,4321,4280,4239,
.................... 4199,4159,4119,4079,4040,4000,3961,3923,3884,3846,3808,3770,3732,3695,3658,3621,3584,3547,3511,3475,
.................... 3439,3403,3368,3332,3297,3262,3227,3193,3158,3124,3090,3056,3023,2989,2956,2923,2890,2858,2825,2793,
.................... 2761,2729,2697,2666,2634,2603,2572,2542,2511,2481,2451,2421,2391,2361,2332,2303,2274,2245,2217,2188,
.................... 2160,2132};
.................... 
.................... const unsigned int16 gain_table[256] = {
.................... 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,85,85,85,86,
.................... 86,86,86,86,86,87,87,87,87,87,88,88,88,88,88,89,89,
.................... 89,89,90,90,90,90,91,91,91,91,92,92,92,92,93,93,93,
.................... 94,94,94,95,95,95,95,96,96,96,97,97,97,98,98,98,99,
.................... 99,100,100,101,101,101,102,102,102,103,103,104,104,
.................... 105,105,106,106,106,107,107,108,108,109,110,110,111,
.................... 111,112,112,113,113,114,114,115,116,116,117,117,118,
.................... 119,120,120,121,122,122,123,124,125,125,126,127,127,
.................... 128,129,130,130,131,132,133,134,135,136,137,138,139,
.................... 140,141,142,143,144,145,146,147,148,149,150,151,152,
.................... 153,154,155,156,157,158,159,161,162,163,164,166,167,
.................... 169,170,172,173,175,177,178,180,182,184,186,188,191,
.................... 193,194,195,196,198,199,200,201,203,204,206,207,209,
.................... 210,212,213,215,216,218,220,222,223,225,227,229,231,
.................... 233,235,237,240,242,244,247,249,252,254,257,260,263,
.................... 266,269,272,275,279,282,286,289,293,297,301,306,310,
.................... 315,320,325,330,335,341,347,353,360,367,374,381,389,
.................... 397,406,415,425,436,436,436,436,436,436,436,436
.................... };
.................... 
.................... #DEVICE ADC=10
.................... #device ICSP=1
.................... #use delay(clock=64000000,crystal=8000000)
.................... #use rs232(UART1, baud=9600, RECEIVE_BUFFER=100 , stream=UART_PORT1)
.................... 
.................... #FUSES NOWDT                    //No Watch Dog Timer
.................... #FUSES CKSFSM                   //Clock Switching is enabled, fail Safe clock monitor is enabled
.................... #FUSES BORV42                   //Brownout reset at 4.5V
.................... #FUSES WRT                      //Program Memory Write Protected
.................... #FUSES PROTECT                  //Code protected from reads
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float32)(unsigned int16)y;
.................... 
....................  else if (y < 10000000.0)
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
....................       res = 32768.0*(float32)l;
....................       res += (float32)(unsigned int16)y;
....................    }
.................... 
....................  else
....................   res = y;
.................... 
....................  y = y - (float32)(unsigned int16)y;
.................... 
....................  if (s)
....................   res = -res;
.................... 
....................  if (y != 0)
....................  {
....................   if (s == 1 && n == 0)
....................    res -= 1.0;
.................... 
....................   if (s == 0 && n == 1)
....................    res += 1.0;
....................  }
....................  if (x == 0)
....................     res = 0;
.................... 
....................  return (res);
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl[0]*y2 + pl[1];
.................... 
....................       r = ql[0]*y2 + ql[1];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
....................          r = -(float32)-n;
....................       else
....................          r = (float32)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
*
0FBE:  MOV     W5,[W15++]
0FC0:  MOV     W6,[W15++]
0FC2:  MOV     W7,[W15++]
0FC4:  MOV     W8,[W15++]
0FC6:  CLR     A1E
0FC8:  CLR     A20
0FCA:  CLR     A22
0FCC:  MOV     #3FF0,W4
0FCE:  MOV     W4,A24
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
0FD0:  MOV     #FF1F,W4
0FD2:  MOV     W4,A2E
0FD4:  SETM    A30
0FD6:  SETM    A32
0FD8:  MOV     #BFDF,W4
0FDA:  MOV     W4,A34
0FDC:  MOV     #1C35,W4
0FDE:  MOV     W4,A36
0FE0:  MOV     #5555,W4
0FE2:  MOV     W4,A38
0FE4:  MOV     #5555,W4
0FE6:  MOV     W4,A3A
0FE8:  MOV     #3FA5,W4
0FEA:  MOV     W4,A3C
0FEC:  MOV     #3F1C,W4
0FEE:  MOV     W4,A3E
0FF0:  MOV     #16A7,W4
0FF2:  MOV     W4,A40
0FF4:  MOV     #C16C,W4
0FF6:  MOV     W4,A42
0FF8:  MOV     #BF56,W4
0FFA:  MOV     W4,A44
0FFC:  MOV     #F3E6,W4
0FFE:  MOV     W4,A46
1000:  MOV     #D65,W4
1002:  MOV     W4,A48
1004:  MOV     #1A0,W4
1006:  MOV     W4,A4A
1008:  MOV     #3EFA,W4
100A:  MOV     W4,A4C
100C:  MOV     #A3E,W4
100E:  MOV     W4,A4E
1010:  MOV     #3931,W4
1012:  MOV     W4,A50
1014:  MOV     #7E4C,W4
1016:  MOV     W4,A52
1018:  MOV     #BE92,W4
101A:  MOV     W4,A54
101C:  MOV     #DDFB,W4
101E:  MOV     W4,A56
1020:  MOV     #2B77,W4
1022:  MOV     W4,A58
1024:  MOV     #EDB1,W4
1026:  MOV     W4,A5A
1028:  MOV     #3E21,W4
102A:  MOV     W4,A5C
102C:  MOV     #6FCC,W4
102E:  MOV     W4,A5E
1030:  MOV     #8FF7,W4
1032:  MOV     W4,A60
1034:  MOV     #C610,W4
1036:  MOV     W4,A62
1038:  MOV     #BDA8,W4
103A:  MOV     W4,A64
103C:  MOV     #124C,W4
103E:  MOV     W4,A66
1040:  MOV     #8E1C,W4
1042:  MOV     W4,A68
1044:  MOV     #3AF9,W4
1046:  MOV     W4,A6A
1048:  MOV     #3CF3,W4
104A:  MOV     W4,A6C
104C:  MOV     #7676,W4
104E:  MOV     W4,A6E
1050:  MOV     #350F,W4
1052:  MOV     W4,A70
1054:  MOV     #C0DE,W4
1056:  MOV     W4,A72
1058:  MOV     #3CF0,W4
105A:  MOV     W4,A74
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
105C:  MOV     A04,W0
105E:  MOV     A06,W1
1060:  MOV     A08,W2
1062:  MOV     A0A,W3
1064:  MOV     #0,W4
1066:  MOV     #0,W5
1068:  MOV     #0,W6
106A:  MOV     #0,W7
106C:  CALL    EDC
1070:  BRA     NC,107C
1072:  MOV     #A04,W0
1074:  MOV     #A04,W1
1076:  REPEAT  #7
1078:  MOV     [W0++],[W1++]
107A:  BTG.B   A0B.7
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
107C:  MOV     A04,W0
107E:  MOV     A06,W1
1080:  MOV     A08,W2
1082:  MOV     A0A,W3
1084:  MOV     #C884,W4
1086:  MOV     #6DC9,W5
1088:  MOV     #5F30,W6
108A:  MOV     #3FE4,W7
108C:  CALL    AD6
1090:  CALL    F60
1094:  MOV.B   W0L,A0C
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
1096:  MOV     A04,W0
1098:  MOV     A06,W1
109A:  MOV     A08,W2
109C:  MOV     A0A,W3
109E:  MOV     #C884,W4
10A0:  MOV     #6DC9,W5
10A2:  MOV     #5F30,W6
10A4:  MOV     #3FE4,W7
10A6:  CALL    AD6
10AA:  MOV     W0,W5
10AC:  MOV     W1,W6
10AE:  MOV     W2,W7
10B0:  MOV     W3,W8
10B2:  MOV     #0,W1
10B4:  MOV     #0,W2
10B6:  MOV     #0,W3
10B8:  MOV.B   A0C,W0L
10BA:  CLR.B   1
10BC:  CALL    A6C
10C0:  BSET.B  43.0
10C2:  MOV     W5,[W15++]
10C4:  MOV     W6,[W15++]
10C6:  MOV     W7,[W15++]
10C8:  MOV     W0,W4
10CA:  MOV     W5,W0
10CC:  MOV     W1,W5
10CE:  MOV     W6,W1
10D0:  MOV     W2,W6
10D2:  MOV     W7,W2
10D4:  MOV     W3,W7
10D6:  MOV     W8,W3
10D8:  CALL    CEE
10DC:  MOV     [--W15],W7
10DE:  MOV     [--W15],W6
10E0:  MOV     [--W15],W5
10E2:  MOV     W0,A26
10E4:  MOV     W1,A28
10E6:  MOV     W2,A2A
10E8:  MOV     W3,A2C
....................    quad = quad % 4;                    // quadrant (0 to 3)
10EA:  MOV.B   A0C,W0L
10EC:  AND.B   W0L,#3,W0L
10EE:  MOV.B   W0L,A0C
.................... 
....................    if (quad == 0 || quad == 2)
10F0:  CP0.B   A0C
10F2:  BRA     Z,10FA
10F4:  MOV     A0C,W4
10F6:  CP.B    W4L,#2
10F8:  BRA     NZ,1118
....................       t = frac * PI_DIV_BY_TWO;
10FA:  MOV     A26,W0
10FC:  MOV     A28,W1
10FE:  MOV     A2A,W2
1100:  MOV     A2C,W3
1102:  MOV     #2D18,W4
1104:  MOV     #5444,W5
1106:  MOV     #21FB,W6
1108:  MOV     #3FF9,W7
110A:  CALL    AD6
110E:  MOV     W0,A16
1110:  MOV     W1,A18
1112:  MOV     W2,A1A
1114:  MOV     W3,A1C
1116:  BRA     11AC
....................    else if (quad == 1)
1118:  MOV     A0C,W4
111A:  CP.B    W4L,#1
111C:  BRA     NZ,1166
....................       t = (1-frac) * PI_DIV_BY_TWO;
111E:  BSET.B  43.0
1120:  MOV     #0,W0
1122:  MOV     #0,W1
1124:  MOV     #0,W2
1126:  MOV     #3FF0,W3
1128:  MOV     A26,W4
112A:  MOV     A28,W5
112C:  MOV     A2A,W6
112E:  MOV     A2C,W7
1130:  CALL    CEE
1134:  MOV     W0,W5
1136:  MOV     W1,W6
1138:  MOV     W2,W7
113A:  MOV     W3,W8
113C:  MOV     W5,[W15++]
113E:  MOV     W6,[W15++]
1140:  MOV     W7,[W15++]
1142:  MOV     W5,W0
1144:  MOV     W6,W1
1146:  MOV     W7,W2
1148:  MOV     W8,W3
114A:  MOV     #2D18,W4
114C:  MOV     #5444,W5
114E:  MOV     #21FB,W6
1150:  MOV     #3FF9,W7
1152:  CALL    AD6
1156:  MOV     [--W15],W7
1158:  MOV     [--W15],W6
115A:  MOV     [--W15],W5
115C:  MOV     W0,A16
115E:  MOV     W1,A18
1160:  MOV     W2,A1A
1162:  MOV     W3,A1C
1164:  BRA     11AC
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
1166:  BSET.B  43.0
1168:  MOV     A26,W0
116A:  MOV     A28,W1
116C:  MOV     A2A,W2
116E:  MOV     A2C,W3
1170:  MOV     #0,W4
1172:  MOV     #0,W5
1174:  MOV     #0,W6
1176:  MOV     #3FF0,W7
1178:  CALL    CEE
117C:  MOV     W0,W5
117E:  MOV     W1,W6
1180:  MOV     W2,W7
1182:  MOV     W3,W8
1184:  MOV     W5,[W15++]
1186:  MOV     W6,[W15++]
1188:  MOV     W7,[W15++]
118A:  MOV     W5,W0
118C:  MOV     W6,W1
118E:  MOV     W7,W2
1190:  MOV     W8,W3
1192:  MOV     #2D18,W4
1194:  MOV     #5444,W5
1196:  MOV     #21FB,W6
1198:  MOV     #3FF9,W7
119A:  CALL    AD6
119E:  MOV     [--W15],W7
11A0:  MOV     [--W15],W6
11A2:  MOV     [--W15],W5
11A4:  MOV     W0,A16
11A6:  MOV     W1,A18
11A8:  MOV     W2,A1A
11AA:  MOV     W3,A1C
.................... 
....................    y = 1.0;
11AC:  CLR     A0E
11AE:  CLR     A10
11B0:  CLR     A12
11B2:  MOV     #3FF0,W4
11B4:  MOV     W4,A14
....................    t = t * t;
11B6:  MOV     A16,W0
11B8:  MOV     A18,W1
11BA:  MOV     A1A,W2
11BC:  MOV     A1C,W3
11BE:  MOV     A16,W4
11C0:  MOV     A18,W5
11C2:  MOV     A1A,W6
11C4:  MOV     A1C,W7
11C6:  CALL    AD6
11CA:  MOV     W0,A16
11CC:  MOV     W1,A18
11CE:  MOV     W2,A1A
11D0:  MOV     W3,A1C
....................    for (i = 0; i <= 8; i++)
11D2:  CLR.B   A0D
11D4:  MOV     A0C,W4
11D6:  LSR     W4,#8,W4
11D8:  CP.B    W4L,#8
11DA:  BRA     GTU,123E
....................    {
....................       t2 = t2 * t;
11DC:  MOV     A1E,W0
11DE:  MOV     A20,W1
11E0:  MOV     A22,W2
11E2:  MOV     A24,W3
11E4:  MOV     A16,W4
11E6:  MOV     A18,W5
11E8:  MOV     A1A,W6
11EA:  MOV     A1C,W7
11EC:  CALL    AD6
11F0:  MOV     W0,A1E
11F2:  MOV     W1,A20
11F4:  MOV     W2,A22
11F6:  MOV     W3,A24
....................       y = y + p_64[i] * t2;
11F8:  MOV.B   A0D,W0L
11FA:  CLR.B   1
11FC:  SL      W0,#3,W0
11FE:  MOV     #A2E,W4
1200:  ADD     W0,W4,W0
1202:  MOV     W0,W5
1204:  MOV     W5,[W15++]
1206:  MOV     [W5],W0
1208:  MOV     [++W5],W1
120A:  MOV     [++W5],W2
120C:  MOV     [++W5],W3
120E:  MOV     A1E,W4
1210:  MOV     A20,W5
1212:  MOV     A22,W6
1214:  MOV     A24,W7
1216:  CALL    AD6
121A:  MOV     [--W15],W5
121C:  BCLR.B  43.0
121E:  MOV     W0,W4
1220:  MOV     W1,W5
1222:  MOV     W2,W6
1224:  MOV     W3,W7
1226:  MOV     A0E,W0
1228:  MOV     A10,W1
122A:  MOV     A12,W2
122C:  MOV     A14,W3
122E:  CALL    CEE
1232:  MOV     W0,A0E
1234:  MOV     W1,A10
1236:  MOV     W2,A12
1238:  MOV     W3,A14
123A:  INC.B   0A0D
123C:  BRA     11D4
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
123E:  MOV     A0C,W4
1240:  CP.B    W4L,#2
1242:  BRA     Z,124A
1244:  MOV     A0C,W4
1246:  CP.B    W4L,#1
1248:  BRA     NZ,1254
....................       y = -y;  // correct sign
124A:  MOV     #A0E,W0
124C:  MOV     #A0E,W1
124E:  REPEAT  #7
1250:  MOV     [W0++],[W1++]
1252:  BTG.B   A15.7
.................... 
....................    return (y);
1254:  MOV     A0E,W0
1256:  MOV     A10,W1
1258:  MOV     A12,W2
125A:  MOV     A14,W3
125C:  MOV     [--W15],W8
125E:  MOV     [--W15],W7
1260:  MOV     [--W15],W6
1262:  MOV     [--W15],W5
1264:  RETURN  
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
1266:  MOV     W5,[W15++]
1268:  MOV     W6,[W15++]
126A:  MOV     W7,[W15++]
126C:  MOV     W8,[W15++]
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
126E:  BSET.B  43.0
1270:  MOV     9F4,W0
1272:  MOV     9F6,W1
1274:  MOV     9F8,W2
1276:  MOV     9FA,W3
1278:  MOV     #2D18,W4
127A:  MOV     #5444,W5
127C:  MOV     #21FB,W6
127E:  MOV     #3FF9,W7
1280:  CALL    CEE
1284:  MOV     W0,W5
1286:  MOV     W1,W6
1288:  MOV     W2,W7
128A:  MOV     W3,W8
128C:  MOV     W5,A04
128E:  MOV     W6,A06
1290:  MOV     W7,A08
1292:  MOV     W8,A0A
1294:  CALL    FBE
1298:  MOV     [--W15],W8
129A:  MOV     [--W15],W7
129C:  MOV     [--W15],W6
129E:  MOV     [--W15],W5
12A0:  RETURN  
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... #include <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];
....................             c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
....................        result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #ifndef __PCB__
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
....................    goto StrtoulGO;
.................... 
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(; sd!=0; )
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtoulGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
....................    }
....................    if (endptr)
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... #endif
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #define P1TCON    0x01C0
.................... #define P1TMR     0x01C2 
.................... #define P1TPER    0x01C4
.................... #define P1SECMP   0x01C6
.................... #define PWM1CON1  0x01C8 
.................... #define PWM1CON2  0x01CA
.................... #define P1DTCON1  0x01CC
.................... #define P1DTCON2  0x01CE  
.................... #define P1FLTACON 0x01D0
.................... #define P1OVDCON  0x01D4   
.................... #define P1DC1     0x01D6   
.................... #define P1DC2     0x01D8
.................... #define P1DC3     0x01DA
.................... #define IPC14     0x00C0  
.................... #define CLKDIV    0x0744 
.................... #define PLLFBD    0x0746
.................... 
.................... 
.................... /*------------QUADRATURE ENCODER REGISTERS-------------------*/
.................... #define QEICON  0x0122       // Control/Status Register.
.................... #define DFLTCON 0x0124      // Digital Filter Control Register.
.................... #define POSCNT  0x0126     // Position Count Register.
.................... #define MAXCNT  0x0128    // Maximum Count Register.
.................... #define ADPCFG  0x02A8   // Encoder Multiplexed pins.
.................... #define IEC2    0x0090  // for enabling the QE interrupt.
.................... #define IPC10   0x00A8 // QEI interrupt priority Register.
.................... 
.................... #define UPDN 3       // Direction testing flag.
.................... /*------------QUADRATURE ENCODER REGISTERS-------------------*/
.................... #define TIM_OVERFLOW_VAL 65535
.................... #define POLES 4
.................... 
.................... #define ADC_pin sAN1
.................... #define LED_PIN PIN_C13
.................... 
.................... #define voltage_offset 1000//1248
.................... #define low_duty_limit 50
.................... #define high_duty_limit 1950
.................... #define SLOPE 0
.................... 
.................... #define break_level 5
.................... #define sustain_level 200  
.................... #define break_amplitude 0 
.................... 
.................... #define pedestal_amplitude 500
.................... #define peak_amplitude 950
.................... 
.................... 
.................... #define throttle_PIN PIN_B1
.................... #define PWM_tick_pin PIN_B2
.................... #define TIM_tick_pin PIN_B3
.................... 
.................... #define kalman_up 18
.................... #define kalman_diff_down 8
.................... 
.................... #define init_freq 30
.................... 
....................   
....................   
.................... void initMCPWM(void);
.................... void fill_sine_table(void);  
.................... int1 QEI_get_direction(void); 
.................... 
.................... unsigned int16 duty[3]={voltage_offset,voltage_offset,voltage_offset},sample=0;
.................... signed int16 peak_voltage =0;//  1184; 
.................... signed int32 reference[3] = {0,0,0};
.................... 
.................... const unsigned max_samples=30.0;
.................... signed int16 sine_table[max_samples];
.................... unsigned int16 sine_index,phase_angle[3] = {0 , 0 , 0};  
.................... double theeta;
.................... 
.................... const unsigned max_freq = 250; //Hz
.................... 
.................... unsigned int16 raw_adc =0 ;
.................... signed int16 throttle_level = 0;
.................... unsigned int16 freq = 1;
.................... unsigned int16 temp = 0;
.................... 
.................... int32 position_count = 0;
.................... int32 prev_count = 0;
.................... int32 enc_count = 0;
.................... int1 direction_flag = 0;
.................... int1 str_capture_flg = 0;
.................... 
.................... int1 tick = 0;
.................... int1 enc_tick = 0;
.................... int1 uart_tick = 0;
.................... int8 tick_count = 0;
.................... unsigned long millis_count = 0;
.................... unsigned long current_millis = 0;
.................... 
.................... char Serial_OutputBuffer[60];
.................... 
.................... unsigned int16 ascending_speed , descending_speed , attained_speed ,attained_throttle;  
.................... 
.................... 
.................... signed int32 kalman_big_1=0, kalman_big_2=0, kalman_diff=0;
.................... 
.................... #int_PWM1
.................... void  PWM1_isr(void) 
*
0742:  PUSH    42
0744:  PUSH    36
0746:  PUSH    32
0748:  MOV     W0,[W15++]
074A:  MOV     #2,W0
074C:  REPEAT  #C
074E:  MOV     [W0++],[W15++]
.................... {
.................... 
....................    tick_count++;
0750:  INC.B   0995
....................    if(tick_count >= 8)
0752:  MOV     994,W4
0754:  LSR     W4,#8,W4
0756:  CP.B    W4L,#8
0758:  BRA     LT,764
....................    {     
....................       millis_count++;
075A:  INC     0996
075C:  BTSC.B  42.1
075E:  INC     0998
....................       tick = 1;
0760:  BSET.B  994.2
....................       tick_count=0;
0762:  CLR.B   995
....................    
....................    }
....................    if ((millis_count - current_millis) >= 100) 
0764:  MOV     996,W4
0766:  MOV     99A,W3
0768:  SUB     W4,W3,W5
076A:  MOV     998,W4
076C:  MOV     99C,W3
076E:  SUBB    W4,W3,W6
0770:  CP      W6,#0
0772:  BRA     NC,786
0774:  BRA     GTU,77C
0776:  MOV     #64,W4
0778:  CP      W4,W5
077A:  BRA     GTU,786
....................    {
....................       enc_tick = 1;
077C:  BSET.B  994.3
....................       current_millis = millis_count;
077E:  PUSH    996
0780:  POP     99A
0782:  PUSH    998
0784:  POP     99C
....................    
....................    
....................    }
....................    if (millis_count >= 500) {
0786:  MOV     998,W4
0788:  CP      W4,#0
078A:  BRA     NC,7A0
078C:  BRA     GTU,796
078E:  MOV     996,W4
0790:  MOV     #1F4,W3
0792:  CP      W3,W4
0794:  BRA     GTU,7A0
....................       output_toggle(LED_PIN);
0796:  BCLR.B  2CD.5
0798:  BTG.B   2D1.5
....................       uart_tick = 1;
079A:  BSET.B  994.4
....................       millis_count = 0;
079C:  CLR     996
079E:  CLR     998
....................       
....................    }  
....................   
.................... 
.................... }
.................... 
07A0:  BCLR.B  88.7
07A2:  MOV     #1A,W0
07A4:  REPEAT  #C
07A6:  MOV     [--W15],[W0--]
07A8:  MOV     [--W15],W0
07AA:  POP     32
07AC:  POP     36
07AE:  POP     42
07B0:  RETFIE  
.................... #INT_TIMER3
.................... void  timer3_isr(void) 
*
07F4:  PUSH    42
07F6:  PUSH    36
07F8:  PUSH    32
07FA:  MOV     W0,[W15++]
07FC:  MOV     #2,W0
07FE:  REPEAT  #C
0800:  MOV     [W0++],[W15++]
.................... {
....................  
....................    sample = (sample+1)%max_samples;
0802:  MOV     924,W4
0804:  ADD     W4,#1,W5
0806:  MOV     #1E,W4
0808:  REPEAT  #11
080A:  DIV.U   W5,W4
080C:  MOV     W1,924
....................    phase_angle[0] = sample;
080E:  PUSH    924
0810:  POP     972
....................    phase_angle[1] = (sample+10)%max_samples;
0812:  MOV     924,W4
0814:  ADD     W4,#A,W5
0816:  MOV     #1E,W4
0818:  REPEAT  #11
081A:  DIV.U   W5,W4
081C:  MOV     W1,974
....................    phase_angle[2] = (sample+20)%max_samples; 
081E:  MOV     924,W4
0820:  ADD     W4,#14,W5
0822:  MOV     #1E,W4
0824:  REPEAT  #11
0826:  DIV.U   W5,W4
0828:  MOV     W1,976
.................... 
....................    for (int i = 0 ; i < 3 ; i++) {
082A:  CLR     AB6
082C:  MOV     AB6,W4
082E:  CP      W4,#3
0830:  BRA     GE,9C8
....................       
....................       reference[i] = sine_table[phase_angle[i]];
0832:  MOV     AB6,W4
0834:  MUL.UU  W4,#4,W0
0836:  MOV     #928,W4
0838:  ADD     W0,W4,W5
083A:  MOV     AB6,W4
083C:  MUL.UU  W4,#2,W0
083E:  MOV     #972,W4
0840:  ADD     W0,W4,W0
0842:  MOV     [W0],W6
0844:  SL      W6,#1,W0
0846:  MOV     #934,W4
0848:  ADD     W0,W4,W0
084A:  MOV     W0,W4
084C:  MOV     [W4],W0
084E:  CLR     W1
0850:  BTSC    W0.F
0852:  SETM    W1
0854:  MOV     #0,W4
0856:  MOV     [W4++],[W5++]
0858:  MOV     [W4++],[W5++]
....................       reference[i] = reference[i] * peak_voltage; 
085A:  MOV     AB6,W4
085C:  MUL.UU  W4,#4,W0
085E:  MOV     #928,W4
0860:  ADD     W0,W4,W5
0862:  MOV     AB6,W4
0864:  MUL.UU  W4,#4,W0
0866:  MOV     #928,W4
0868:  ADD     W0,W4,W0
086A:  MOV     #C,W4
086C:  MOV     [W0++],[W4++]
086E:  MOV     [W0++],[W4++]
0870:  MOV     926,W0
0872:  CLR     W1
0874:  BTSC    W0.F
0876:  SETM    W1
0878:  MOV     W0,W2
087A:  MOV     W1,W3
087C:  MOV     W6,W0
087E:  MOV     W7,W1
0880:  CALL    7B2
0884:  MOV     #0,W4
0886:  MOV     [W4++],[W5++]
0888:  MOV     [W4++],[W5++]
....................       if( reference[i] > 0)
088A:  MOV     AB6,W4
088C:  MUL.UU  W4,#4,W0
088E:  MOV     #928,W4
0890:  ADD     W0,W4,W0
0892:  MOV     #A,W4
0894:  MOV     [W0++],[W4++]
0896:  MOV     [W0++],[W4++]
0898:  CP      W6,#0
089A:  BRA     LT,8C8
089C:  BRA     GT,8A2
089E:  CP      W5,#0
08A0:  BRA     LEU,8C8
....................       {
....................          reference[i] = reference[i] >> 8; 
08A2:  MOV     AB6,W4
08A4:  MUL.UU  W4,#4,W0
08A6:  MOV     #928,W4
08A8:  ADD     W0,W4,W5
08AA:  MOV     AB6,W4
08AC:  MUL.UU  W4,#4,W0
08AE:  MOV     #928,W4
08B0:  ADD     W0,W4,W0
08B2:  MOV     #C,W4
08B4:  MOV     [W0++],[W4++]
08B6:  MOV     [W0++],[W4++]
08B8:  MOV.B   D,W0L
08BA:  MOV.B   W0L,[W5]
08BC:  MOV.B   W7L,[W5+#1]
08BE:  MOV.B   F,W0L
08C0:  MOV.B   W0L,[W5+#2]
08C2:  MOV.B   #0,W0L
08C4:  MOV.B   W0L,[W5+#3]
....................       }
08C6:  BRA     944
....................       else if( reference[i] < 0)
08C8:  MOV     AB6,W4
08CA:  MUL.UU  W4,#4,W0
08CC:  MOV     #928,W4
08CE:  ADD     W0,W4,W0
08D0:  MOV     #A,W4
08D2:  MOV     [W0++],[W4++]
08D4:  MOV     [W0++],[W4++]
08D6:  CP      W6,#0
08D8:  BRA     GT,944
08DA:  BRA     LT,8E0
08DC:  CP      W5,#0
08DE:  BRA     C,944
....................       {
....................          reference[i] = 0 - reference[i];
08E0:  MOV     AB6,W4
08E2:  MUL.UU  W4,#4,W0
08E4:  MOV     #928,W4
08E6:  ADD     W0,W4,W5
08E8:  MOV     AB6,W4
08EA:  MUL.UU  W4,#4,W0
08EC:  MOV     #928,W4
08EE:  ADD     W0,W4,W0
08F0:  MOV     W0,W4
08F2:  MOV     #0,W3
08F4:  MOV     [W4++],[W3++]
08F6:  MOV     [W4++],[W3++]
08F8:  MOV     #0,W4
08FA:  SUB     W4,W0,[W5]
08FC:  MOV     #0,W4
08FE:  SUBB    W4,W1,[++W5]
....................          reference[i] = reference[i] >> 8;
0900:  MOV     AB6,W4
0902:  MUL.UU  W4,#4,W0
0904:  MOV     #928,W4
0906:  ADD     W0,W4,W5
0908:  MOV     AB6,W4
090A:  MUL.UU  W4,#4,W0
090C:  MOV     #928,W4
090E:  ADD     W0,W4,W0
0910:  MOV     #C,W4
0912:  MOV     [W0++],[W4++]
0914:  MOV     [W0++],[W4++]
0916:  MOV.B   D,W0L
0918:  MOV.B   W0L,[W5]
091A:  MOV.B   W7L,[W5+#1]
091C:  MOV.B   F,W0L
091E:  MOV.B   W0L,[W5+#2]
0920:  MOV.B   #0,W0L
0922:  MOV.B   W0L,[W5+#3]
....................          reference[i] = 0 - reference[i];
0924:  MOV     AB6,W4
0926:  MUL.UU  W4,#4,W0
0928:  MOV     #928,W4
092A:  ADD     W0,W4,W5
092C:  MOV     AB6,W4
092E:  MUL.UU  W4,#4,W0
0930:  MOV     #928,W4
0932:  ADD     W0,W4,W0
0934:  MOV     W0,W4
0936:  MOV     #0,W3
0938:  MOV     [W4++],[W3++]
093A:  MOV     [W4++],[W3++]
093C:  MOV     #0,W4
093E:  SUB     W4,W0,[W5]
0940:  MOV     #0,W4
0942:  SUBB    W4,W1,[++W5]
....................       }
....................       
....................       reference[i] = reference[i] + voltage_offset;
0944:  MOV     AB6,W4
0946:  MUL.UU  W4,#4,W0
0948:  MOV     #928,W4
094A:  ADD     W0,W4,W5
094C:  MOV     AB6,W4
094E:  MUL.UU  W4,#4,W0
0950:  MOV     #928,W4
0952:  ADD     W0,W4,W0
0954:  MOV     #C,W4
0956:  MOV     [W0++],[W4++]
0958:  MOV     [W0++],[W4++]
095A:  MOV     #3E8,W4
095C:  ADD     W6,W4,[W5]
095E:  ADDC    W7,#0,[++W5]
....................       if(reference[i] > high_duty_limit )
0960:  MOV     AB6,W4
0962:  MUL.UU  W4,#4,W0
0964:  MOV     #928,W4
0966:  ADD     W0,W4,W0
0968:  MOV     #A,W4
096A:  MOV     [W0++],[W4++]
096C:  MOV     [W0++],[W4++]
096E:  CP      W6,#0
0970:  BRA     LT,992
0972:  BRA     GT,97A
0974:  MOV     #79E,W4
0976:  CP      W4,W5
0978:  BRA     C,992
....................       { 
....................          reference[i] = high_duty_limit;
097A:  MOV     AB6,W4
097C:  MUL.UU  W4,#4,W0
097E:  MOV     #928,W4
0980:  ADD     W0,W4,W5
0982:  MOV.B   #9E,W0L
0984:  MOV.B   W0L,[W5]
0986:  MOV.B   #7,W0L
0988:  MOV.B   W0L,[W5+#1]
098A:  MOV.B   #0,W0L
098C:  MOV.B   W0L,[W5+#2]
098E:  MOV.B   #0,W0L
0990:  MOV.B   W0L,[W5+#3]
....................       }
....................       if(reference[i] < low_duty_limit)
0992:  MOV     AB6,W4
0994:  MUL.UU  W4,#4,W0
0996:  MOV     #928,W4
0998:  ADD     W0,W4,W0
099A:  MOV     #A,W4
099C:  MOV     [W0++],[W4++]
099E:  MOV     [W0++],[W4++]
09A0:  CP      W6,#0
09A2:  BRA     GT,9C4
09A4:  BRA     LT,9AC
09A6:  MOV     #32,W4
09A8:  CP      W4,W5
09AA:  BRA     LEU,9C4
....................       { 
....................          reference[i] = low_duty_limit;
09AC:  MOV     AB6,W4
09AE:  MUL.UU  W4,#4,W0
09B0:  MOV     #928,W4
09B2:  ADD     W0,W4,W5
09B4:  MOV.B   #32,W0L
09B6:  MOV.B   W0L,[W5]
09B8:  MOV.B   #0,W0L
09BA:  MOV.B   W0L,[W5+#1]
09BC:  MOV.B   #0,W0L
09BE:  MOV.B   W0L,[W5+#2]
09C0:  MOV.B   #0,W0L
09C2:  MOV.B   W0L,[W5+#3]
....................       }
09C4:  INC     0AB6
09C6:  BRA     82C
....................    }
....................       
....................    *P1DC1 = reference[0];  *(P1DC1+1) = reference[0]>>8;
09C8:  MOV.B   928,W0L
09CA:  MOV.B   W0L,1D6
09CC:  MOV.B   929,W0L
09CE:  MOV.B   W0L,1D7
....................    *P1DC2 = reference[1];  *(P1DC2+1) = reference[1]>>8;
09D0:  MOV.B   92C,W0L
09D2:  MOV.B   W0L,1D8
09D4:  MOV.B   92D,W0L
09D6:  MOV.B   W0L,1D9
....................    *P1DC3 = reference[2];  *(P1DC3+1) = reference[2]>>8;
09D8:  MOV.B   930,W0L
09DA:  MOV.B   W0L,1DA
09DC:  MOV.B   931,W0L
09DE:  MOV.B   W0L,1DB
.................... 
....................    setup_timer2(TMR_INTERNAL | TMR_DIV_BY_1 | TMR_32_BIT , timer_table[freq]);
09E0:  MOV     984,W0
09E2:  SL      W0,#1,W0
09E4:  CALL    3F0
09E8:  MOV     W0,W5
09EA:  CLR     110
09EC:  MOV     W5,10C
09EE:  MOV     W6,10E
09F0:  MOV     #8008,W4
09F2:  MOV     W4,110
.................... //!   output_bit(TIM_tick_pin , 0);
....................    
09F4:  BCLR.B  84.7
09F6:  MOV     #1A,W0
09F8:  REPEAT  #C
09FA:  MOV     [--W15],[W0--]
09FC:  MOV     [--W15],W0
09FE:  POP     32
0A00:  POP     36
0A02:  POP     42
0A04:  RETFIE  
.................... }
.................... 
.................... 
....................    
.................... void main()
*
1682:  MOV     #F80,W15
1684:  MOV     #FFF,W0
1686:  MOV     W0,20
1688:  NOP     
168A:  MOV     #4444,W0
168C:  MOV     W0,96
168E:  MOV     #4444,W0
1690:  MOV     W0,A6
1692:  BSET.B  81.7
1694:  MOV     #8000,W4
1696:  MOV     W4,20C
1698:  MOV     #400,W4
169A:  MOV     W4,20E
169C:  MOV     #67,W4
169E:  MOV     W4,214
16A0:  CLR     864
16A2:  CLR     866
16A4:  CLR     864
16A6:  CLR     866
16A8:  BSET.B  8D.1
16AA:  CLR     924
16AC:  CLR     926
16AE:  CLR     980
16B0:  CLR     982
16B2:  MOV     #1,W4
16B4:  MOV     W4,984
16B6:  CLR     986
16B8:  CLR     988
16BA:  CLR     98A
16BC:  CLR     98C
16BE:  CLR     98E
16C0:  CLR     990
16C2:  CLR     992
16C4:  BCLR.B  994.0
16C6:  BCLR.B  994.1
16C8:  BCLR.B  994.2
16CA:  BCLR.B  994.3
16CC:  BCLR.B  994.4
16CE:  CLR.B   995
16D0:  CLR     996
16D2:  CLR     998
16D4:  CLR     99A
16D6:  CLR     99C
16D8:  CLR     9E2
16DA:  CLR     9E4
16DC:  CLR     9E6
16DE:  CLR     9E8
16E0:  CLR     9EA
16E2:  CLR     9EC
16E4:  CLR     9EE
16E6:  SETM    2A8
16E8:  BRA     178C
16EA:  DATA    C0,06,08
16EC:  DATA    68,00,00
16EE:  DATA    4B,F0,3F
16F0:  DATA    5C,0A,58
16F2:  DATA    F6,3B,8F
16F4:  DATA    00,C0,3C
16F6:  DATA    8B,28,AC
16F8:  DATA    3C,BE,F6
16FA:  DATA    3F,D2,D5
16FC:  DATA    44,16,8C
16FE:  DATA    15,D7,BF
1700:  DATA    69,00,5A
1702:  DATA    2E,1B,87
1704:  DATA    99,3F,9A
1706:  DATA    5F,AD,4B
1708:  DATA    91,E4,01
170A:  DATA    C0,5D,11
170C:  DATA    2F,92,E4
170E:  DATA    81,FB,3F
1710:  DATA    38,DA,91
1712:  DATA    80,9D,C5
1714:  DATA    E0,BF,6F
1716:  DATA    12,C0,B4
1718:  DATA    C3,09,AB
171A:  DATA    3F,6B,C1
171C:  DATA    03,4E,C1
171E:  DATA    B5,45,BF
1720:  DATA    F7,40,05
1722:  DATA    FF,00,5C
1724:  DATA    EF,3F,F3
1726:  DATA    A3,E2,F7
1728:  DATA    D7,FF,01
172A:  DATA    40,C0,B4
172C:  DATA    FF,05,3C
172E:  DATA    58,FC,3F
1730:  DATA    3B,D3,C0
1732:  DATA    B5,BA,8C
1734:  DATA    E2,3F,39
1736:  DATA    D3,C7,3D
1738:  DATA    41,79,B2
173A:  DATA    3F,87,0D
173C:  DATA    3C,50,D0
173E:  DATA    AF,62,3F
1740:  DATA    30,4B,8D
1742:  DATA    A2,82,AA
1744:  DATA    04,40,09
1746:  DATA    A0,40,4A
1748:  DATA    05,76,03
174A:  DATA    40,EC,9E
174C:  DATA    37,88,A6
174E:  DATA    44,F0,3F
1750:  DATA    8F,12,8D
1752:  DATA    29,9A,5B
1754:  DATA    C7,3F,0E
1756:  DATA    E0,80,7C
1758:  DATA    A1,D8,86
175A:  DATA    3F,29,4B
175C:  DATA    FB,95,C2
175E:  DATA    37,1A,3F
1760:  DATA    00,00,80
1762:  DATA    06,09,1E
1764:  DATA    E8,03,E8
1766:  DATA    03,E8,03
1768:  DATA    C0,0C,09
176A:  DATA    28,00,C0
176C:  DATA    06,09,72
176E:  DATA    00,00,00
1770:  INC     W2,W2
1772:  CP      W2,#1
1774:  BRA     NZ,177E
1776:  TBLRDL  [W1],W3
1778:  TBLRDH  [W1++],W4
177A:  MOV.B   6,W0L
177C:  RETURN  
177E:  CP      W2,#2
1780:  BRA     NZ,1786
1782:  MOV.B   7,W0L
1784:  RETURN  
1786:  MOV.B   8,W0L
1788:  CLR     W2
178A:  RETURN  
178C:  MOV     #0,W6
178E:  MOV     #0,W0
1790:  MOV     W0,32
1792:  MOV     #16EA,W0
1794:  MOV     W0,W1
1796:  CLR     W2
1798:  CALL    1770
179C:  MOV.B   W0L,B
179E:  CALL    1770
17A2:  MOV.B   W0L,A
17A4:  CP0     W5
17A6:  BRA     Z,17DA
17A8:  BTSS    W5.F
17AA:  BRA     17BA
17AC:  CALL    1770
17B0:  MOV.B   W0L,D
17B2:  CALL    1770
17B6:  MOV.B   W0L,C
17B8:  BCLR    W5.F
17BA:  BTSS    W5.E
17BC:  BRA     17CE
17BE:  BCLR    W5.E
17C0:  DEC     W5,W5
17C2:  CALL    1770
17C6:  MOV.B   W0L,W7L
17C8:  REPEAT  W5
17CA:  MOV.B   W7L,[W6++]
17CC:  BRA     1798
17CE:  CALL    1770
17D2:  MOV.B   W0L,[W6++]
17D4:  DEC     W5,W5
17D6:  BRA     NZ,17CE
17D8:  BRA     1798
.................... { 
....................    sprintf(Serial_OutputBuffer, "\nMotor Control Unit v0.1\r\n");
17DA:  MOV     #99E,W4
17DC:  MOV     W4,9EE
17DE:  MOV     #0,W1
17E0:  MOV     W1,W0
17E2:  CLR.B   1
17E4:  CALL    6E0
17E8:  INC     W1,W1
17EA:  MOV     W1,[W15++]
17EC:  MOV     W0,[W15++]
17EE:  MOV     [--W15],W0
17F0:  CALL    A06
17F4:  MOV     [--W15],W1
17F6:  MOV     #19,W0
17F8:  CPSGT   W1,W0
17FA:  BRA     17E0
....................    printf(Serial_OutputBuffer);
17FC:  MOV     #99E,W1
17FE:  CP0.B   [W1]
1800:  BRA     Z,1810
1802:  BTSC.B  20F.1
1804:  BRA     1802
1806:  MOV.B   [W1+#0],W0L
1808:  MOV.B   W0L,210
180A:  CLR.B   211
180C:  INC     W1,W1
180E:  BRA     17FE
....................    attained_throttle = 20;
1810:  MOV     #14,W4
1812:  MOV     W4,9E0
....................    freq = 1;
1814:  MOV     #1,W4
1816:  MOV     W4,984
....................    
....................    initMCPWM();
1818:  CALL    A14
....................    fill_sine_table();
181C:  CALL    1300
.................... 
....................    output_drive(LED_PIN);
1820:  BCLR.B  2CD.5
....................    output_drive(PWM_tick_pin);
1822:  BCLR.B  2C6.2
....................    output_drive(TIM_tick_pin);   
1824:  BCLR.B  2C6.3
....................    
....................    setup_adc(ADC_CLOCK_DIV_32);
1826:  MOV     #1F1F,W4
1828:  MOV     W4,2A4
182A:  MOV     #80E0,W4
182C:  MOV     W4,2A0
....................    setup_adc_ports(ADC_pin);
182E:  MOV     #FFFD,W4
1830:  MOV     W4,2A8
1832:  CLR     2A2
....................    set_adc_channel(1);
1834:  MOV     #1,W4
1836:  MOV     W4,2A6
....................    delay_us(10);
1838:  REPEAT  #9E
183A:  NOP     
....................    
....................    setup_qei( QEI_MODE_X2 , QEI_FILTER_DIV_1 ,0);
183C:  MOV     #400,W4
183E:  MOV     W4,122
1840:  CLR     124
1842:  CLR     128
1844:  CLR     126
....................    setup_timer2(TMR_INTERNAL | TMR_DIV_BY_1 | TMR_32_BIT , timer_table[freq]);
1846:  MOV     984,W0
1848:  SL      W0,#1,W0
184A:  CALL    3F0
184E:  MOV     W0,W5
1850:  CLR     110
1852:  MOV     W5,10C
1854:  MOV     W6,10E
1856:  MOV     #8008,W4
1858:  MOV     W4,110
....................    enable_interrupts(INT_TIMER3);   // enable interrupt in timer3 register (in case of 32bit mode) 
185A:  BSET.B  8C.7
.................... 
....................    enable_interrupts(INT_PWM1);  
185C:  BSET.B  90.7
....................    enable_interrupts(INTR_GLOBAL);
185E:  BCLR.B  81.7
1860:  CLR     42
1862:  BSET.B  81.7
....................    
.................... 
....................    while(TRUE)         
....................    {
....................    
....................       
....................       if (tick) {
1864:  BTSS.B  994.2
1866:  BRA     1910
....................          output_bit(TIM_tick_pin , 1);
1868:  BSET.B  2CA.3
186A:  BCLR.B  2C6.3
....................          
....................          raw_adc = read_adc();
186C:  BCLR.B  2A0.0
186E:  BSET.B  2A0.1
1870:  BTSS.B  2A0.0
1872:  BRA     1870
1874:  PUSH    280
1876:  POP     980
....................          
....................          output_bit(TIM_tick_pin , 0);
1878:  BCLR.B  2CA.3
187A:  BCLR.B  2C6.3
....................          if (raw_adc > 1023) 
187C:  MOV     980,W4
187E:  MOV     #3FF,W3
1880:  CP      W3,W4
1882:  BRA     C,1888
....................          {
....................             raw_adc = 1023;
1884:  MOV     #3FF,W4
1886:  MOV     W4,980
....................          }
....................          
.................... //------------- KALMAN FILTER IMPLEMENTATION---------------//
.................... //!         kalman_big_1 =  raw_adc << kalman_up;
.................... //!         kalman_diff = kalman_big_1 - kalman_big_2;
.................... //!         if(kalman_diff > 0)
.................... //!         {
.................... //!            kalman_diff = kalman_diff >> kalman_diff_down;
.................... //!            kalman_big_2 = kalman_big_2 + kalman_diff; 
.................... //!         }
.................... //!         else if(kalman_diff < 0)
.................... //!         {
.................... //!            kalman_diff = 0 - kalman_diff;
.................... //!            kalman_diff = kalman_diff >> kalman_diff_down;
.................... //!            kalman_big_2 = kalman_big_2 - kalman_diff;   
.................... //!         }
.................... //!         if(kalman_big_2 < 0)
.................... //!         {
.................... //!            kalman_big_2 = 0 ;
.................... //!         }
.................... //!         raw_adc = kalman_big_2 >> kalman_up;
.................... //------------- KALMAN FILTER IMPLEMENTATION---------------//
.................... 
....................         
....................          raw_adc = raw_adc -200;
1888:  MOV     980,W4
188A:  SUB     #C8,W4
188C:  MOV     W4,980
....................          throttle_level = raw_adc;
188E:  PUSH    980
1890:  POP     982
....................         
....................          
....................          if (throttle_level > 255)
1892:  MOV     982,W4
1894:  MOV     #FF,W3
1896:  CP      W3,W4
1898:  BRA     GE,189E
....................          {
....................             throttle_level = 255;
189A:  MOV     #FF,W4
189C:  MOV     W4,982
....................          }
....................          if (throttle_level < 0)   
189E:  MOV     982,W4
18A0:  CP      W4,#0
18A2:  BRA     GE,18A6
....................          {  
....................             throttle_level = 0; 
18A4:  CLR     982
....................          }  
....................          
....................          if (throttle_level > 20) 
18A6:  MOV     982,W4
18A8:  CP      W4,#14
18AA:  BRA     LE,18FC
....................          {
....................             if(throttle_level > attained_throttle)
18AC:  MOV     9E0,W0
18AE:  MOV     982,W4
18B0:  CP      W4,W0
18B2:  BRA     LE,18CC
....................             {
....................                ascending_speed  = ascend_speed_table[attained_throttle];
18B4:  MOV     9E0,W0
18B6:  SL      W0,#1,W0
18B8:  CALL    100
18BC:  MOV     W0,9DA
....................                attained_speed = enc_count;
18BE:  PUSH    990
18C0:  POP     9DE
....................                if (attained_speed >= ascending_speed) 
18C2:  MOV     9DA,W0
18C4:  MOV     9DE,W4
18C6:  CP      W4,W0
18C8:  BRA     NC,18CC
....................                {
....................                   attained_throttle++; 
18CA:  INC     09E0
....................                }
....................             }
....................             if(throttle_level < attained_throttle)
18CC:  MOV     982,W0
18CE:  MOV     9E0,W4
18D0:  CP      W4,W0
18D2:  BRA     LE,18F6
....................             {
....................                descending_speed = descend_speed_table[attained_throttle];
18D4:  MOV     9E0,W0
18D6:  SL      W0,#1,W0
18D8:  CALL    278
18DC:  MOV     W0,9DC
....................                attained_speed = enc_count;
18DE:  PUSH    990
18E0:  POP     9DE
....................                if (attained_speed < descending_speed) 
18E2:  MOV     9DE,W0
18E4:  MOV     9DC,W4
18E6:  CP      W4,W0
18E8:  BRA     LEU,18F6
....................                {
....................                   attained_throttle--; 
18EA:  DEC     09E0
....................                   if (attained_throttle < 20)
18EC:  MOV     9E0,W4
18EE:  CP      W4,#14
18F0:  BRA     C,18F6
....................                   {
....................                      attained_throttle = 20;
18F2:  MOV     #14,W4
18F4:  MOV     W4,9E0
....................                   }
....................                }
....................             }
....................             if(throttle_level == attained_throttle)
18F6:  MOV     982,W0
18F8:  CP      9E0
18FA:  BRA     NZ,18FC
....................             {
....................             //
....................             }
....................          }
.................... 
....................          freq = attained_throttle;
18FC:  PUSH    9E0
18FE:  POP     984
....................        
....................          peak_voltage = gain_table[attained_throttle]; 
1900:  MOV     9E0,W0
1902:  SL      W0,#1,W0
1904:  CALL    568
1908:  MOV     W0,926
....................          
....................          output_bit(PWM_tick_pin , 0);
190A:  BCLR.B  2CA.2
190C:  BCLR.B  2C6.2
....................          tick = 0;      
190E:  BCLR.B  994.2
....................       } 
....................       
....................       if (uart_tick) 
1910:  BTSS.B  994.4
1912:  BRA     197E
....................       {
....................          
....................          //!         sprintf(Serial_OutputBuffer, "\r\n %d , %d , %d , %d", raw_adc , throttle_level , freq , peak_voltage);
....................          sprintf(Serial_OutputBuffer, "\r\n %d , %d , %d" , enc_count , throttle_level , attained_throttle);
1914:  MOV     #99E,W4
1916:  MOV     W4,9EE
1918:  MOV.B   #D,W0L
191A:  CALL    A06
191E:  MOV.B   #A,W0L
1920:  CALL    A06
1924:  MOV.B   #20,W0L
1926:  CALL    A06
192A:  MOV     990,W0
192C:  MOV     992,W1
192E:  MOV     #0,W4
1930:  CALL    140C
1934:  MOV.B   #20,W0L
1936:  CALL    A06
193A:  MOV.B   #2C,W0L
193C:  CALL    A06
1940:  MOV.B   #20,W0L
1942:  CALL    A06
1946:  MOV     982,W0
1948:  MOV     #0,W4
194A:  CALL    1544
194E:  MOV.B   #20,W0L
1950:  CALL    A06
1954:  MOV.B   #2C,W0L
1956:  CALL    A06
195A:  MOV.B   #20,W0L
195C:  CALL    A06
1960:  MOV     9E0,W0
1962:  MOV     #0,W4
1964:  CALL    1544
....................          printf(Serial_OutputBuffer);
1968:  MOV     #99E,W1
196A:  CP0.B   [W1]
196C:  BRA     Z,197C
196E:  BTSC.B  20F.1
1970:  BRA     196E
1972:  MOV.B   [W1+#0],W0L
1974:  MOV.B   W0L,210
1976:  CLR.B   211
1978:  INC     W1,W1
197A:  BRA     196A
....................          
....................          uart_tick = 0;
197C:  BCLR.B  994.4
....................       
....................       }
....................       if (enc_tick) 
197E:  BTSS.B  994.3
1980:  BRA     1A1E
....................       {
....................          position_count = *(POSCNT +1);
1982:  MOV.B   127,W0L
1984:  MOV.B   W0L,988
1986:  CLR.B   989
1988:  CLR     98A
....................          position_count = position_count << 8;
198A:  MOV.B   98A,W0L
198C:  MOV.B   W0L,98B
198E:  MOV.B   989,W0L
1990:  MOV.B   W0L,98A
1992:  MOV.B   988,W0L
1994:  MOV.B   W0L,989
1996:  CLR.B   988
....................          position_count = position_count | *POSCNT; 
1998:  MOV.B   126,W0L
199A:  CLR.B   1
199C:  IOR     988
.................... 
.................... 
....................          direction_flag = QEI_get_direction();
199E:  CALL    1674
19A2:  BCLR.B  994.0
19A4:  BTSC.B  0.0
19A6:  BSET.B  994.0
.................... 
....................          enc_count = position_count - prev_count;
19A8:  MOV     988,W4
19AA:  MOV     98C,W3
19AC:  SUB     W4,W3,W0
19AE:  MOV     W0,990
19B0:  MOV     98A,W4
19B2:  MOV     98E,W3
19B4:  SUBB    W4,W3,W0
19B6:  MOV     W0,992
....................      
....................          if (direction_flag == 1 && enc_count < 0) 
19B8:  BTSS.B  994.0
19BA:  BRA     19D8
19BC:  MOV     992,W4
19BE:  CP      W4,#0
19C0:  BRA     GT,19D8
19C2:  BRA     LT,19CA
19C4:  MOV     990,W4
19C6:  CP      W4,#0
19C8:  BRA     C,19D8
....................          {
....................             enc_count = enc_count + TIM_OVERFLOW_VAL ;
19CA:  MOV     #FFFF,W4
19CC:  MOV     990,W3
19CE:  ADD     W3,W4,W0
19D0:  MOV     W0,990
19D2:  MOV     992,W4
19D4:  ADDC    W4,#0,W0
19D6:  MOV     W0,992
.................... 
....................          }
.................... 
....................          if (direction_flag == 0 && enc_count > 0) 
19D8:  BTSC.B  994.0
19DA:  BRA     19F8
19DC:  MOV     992,W4
19DE:  CP      W4,#0
19E0:  BRA     LT,19F8
19E2:  BRA     GT,19EA
19E4:  MOV     990,W4
19E6:  CP      W4,#0
19E8:  BRA     LEU,19F8
....................          {
....................             enc_count = enc_count - TIM_OVERFLOW_VAL ;
19EA:  MOV     990,W4
19EC:  MOV     #FFFF,W3
19EE:  SUB     W4,W3,W0
19F0:  MOV     W0,990
19F2:  MOV     992,W4
19F4:  SUBB    W4,#0,W0
19F6:  MOV     W0,992
....................          }
....................    
....................          enc_count = abs(enc_count);
19F8:  MOV     990,W0
19FA:  MOV     992,W1
19FC:  BTSS    W1.F
19FE:  BRA     1A0C
1A00:  MOV     #0,W4
1A02:  MOV     990,W3
1A04:  SUB     W4,W3,W0
1A06:  MOV     #0,W4
1A08:  MOV     992,W3
1A0A:  SUBB    W4,W3,W1
1A0C:  MOV     W0,990
1A0E:  MOV     W1,992
....................          enc_count = enc_count >> 1;
1A10:  LSR     992
1A12:  RRC     990
....................          prev_count = position_count;
1A14:  PUSH    988
1A16:  POP     98C
1A18:  PUSH    98A
1A1A:  POP     98E
....................          
....................          enc_tick = 0;
1A1C:  BCLR.B  994.3
.................... 
....................       }
1A1E:  BRA     1864
....................     } 
.................... }    
.................... 
1A20:  PWRSAV  #0
.................... 
.................... void initMCPWM(void) 
.................... {    
....................    *(P1TCON+1)  =  0x80;  *P1TCON =  0x02;
*
0A14:  MOV.B   #80,W0L
0A16:  MOV.B   W0L,1C1
0A18:  MOV.B   #2,W0L
0A1A:  MOV.B   W0L,1C0
....................    *(P1TPER+1)  =  0x03;  *P1TPER =  0xE7;  
0A1C:  MOV.B   #3,W0L
0A1E:  MOV.B   W0L,1C5
0A20:  MOV.B   #E7,W0L
0A22:  MOV.B   W0L,1C4
....................    *(P1SECMP+1) =  0x00;  *P1SECMP=  0x01; //
0A24:  CLR.B   1C7
0A26:  MOV.B   #1,W0L
0A28:  MOV.B   W0L,1C6
....................    *(PWM1CON1+1)=  0x00;  *PWM1CON1= 0x77;  
0A2A:  CLR.B   1C9
0A2C:  MOV.B   #77,W0L
0A2E:  MOV.B   W0L,1C8
....................    *(PWM1CON2+1)=  0x00;  *PWM1CON2= 0x02;
0A30:  CLR.B   1CB
0A32:  MOV.B   #2,W0L
0A34:  MOV.B   W0L,1CA
....................    *(P1DTCON1+1)=  0x00;  *P1DTCON1= 0x10; //0x09
0A36:  CLR.B   1CD
0A38:  MOV.B   #10,W0L
0A3A:  MOV.B   W0L,1CC
....................    *(P1DTCON2+1)=  0x00;  *P1DTCON2= 0x00;
0A3C:  CLR.B   1CF
0A3E:  CLR.B   1CE
....................    *(P1FLTACON+1)= 0x00;  *P1FLTACON=0x00; //0x0000
0A40:  CLR.B   1D1
0A42:  CLR.B   1D0
....................    *(P1OVDCON+1)=  0x3F;  *P1OVDCON= 0x0F;
0A44:  MOV.B   #3F,W0L
0A46:  MOV.B   W0L,1D5
0A48:  MOV.B   #F,W0L
0A4A:  MOV.B   W0L,1D4
....................    
....................    *(P1DC1+1) = duty[0]>>8;   *P1DC1 = duty[0]; 
0A4C:  MOV.B   91F,W0L
0A4E:  MOV.B   W0L,1D7
0A50:  MOV.B   91E,W0L
0A52:  MOV.B   W0L,1D6
....................    *(P1DC2+1) = duty[1]>>8;   *P1DC2 = duty[1];
0A54:  MOV.B   921,W0L
0A56:  MOV.B   W0L,1D9
0A58:  MOV.B   920,W0L
0A5A:  MOV.B   W0L,1D8
....................    *(P1DC3+1) = duty[2]>>8;   *P1DC3 = duty[2];  
0A5C:  MOV.B   923,W0L
0A5E:  MOV.B   W0L,1DB
0A60:  MOV.B   922,W0L
0A62:  MOV.B   W0L,1DA
....................    *(IPC14+1) =0x00;*(IPC14) =0x70;
0A64:  CLR.B   C1
0A66:  MOV.B   #70,W0L
0A68:  MOV.B   W0L,C0
0A6A:  RETURN  
.................... }
.................... 
.................... 
....................    
.................... void fill_sine_table(void)
*
1300:  MOV     W5,[W15++]
1302:  MOV     W6,[W15++]
1304:  MOV     W7,[W15++]
1306:  MOV     W8,[W15++]
.................... {
....................    for(sine_index=0;sine_index < max_samples;sine_index++)  
1308:  CLR     970
130A:  MOV     970,W4
130C:  CP      W4,#1E
130E:  BRA     C,13BE
....................    {
....................       theeta=sine_index*2.0*PI/max_samples;
1310:  MOV     970,W0
1312:  MOV     #0,W1
1314:  MOV     #0,W2
1316:  MOV     #0,W3
1318:  CALL    A6C
131C:  MOV     #0,W4
131E:  MOV     #0,W5
1320:  MOV     #0,W6
1322:  MOV     #4000,W7
1324:  CALL    AD6
1328:  MOV     W0,W5
132A:  MOV     W1,W6
132C:  MOV     W2,W7
132E:  MOV     W3,W8
1330:  MOV     W5,[W15++]
1332:  MOV     W6,[W15++]
1334:  MOV     W7,[W15++]
1336:  MOV     W5,W0
1338:  MOV     W6,W1
133A:  MOV     W7,W2
133C:  MOV     W8,W3
133E:  MOV     #2D18,W4
1340:  MOV     #5444,W5
1342:  MOV     #21FB,W6
1344:  MOV     #4009,W7
1346:  CALL    AD6
134A:  MOV     [--W15],W7
134C:  MOV     [--W15],W6
134E:  MOV     [--W15],W5
1350:  MOV     W0,W5
1352:  MOV     W1,W6
1354:  MOV     W2,W7
1356:  MOV     W3,W8
1358:  MOV     W5,[W15++]
135A:  MOV     W6,[W15++]
135C:  MOV     W7,[W15++]
135E:  MOV     W5,W0
1360:  MOV     W6,W1
1362:  MOV     W7,W2
1364:  MOV     W8,W3
1366:  MOV     #0,W4
1368:  MOV     #0,W5
136A:  MOV     #0,W6
136C:  MOV     #403E,W7
136E:  CALL    BE6
1372:  MOV     [--W15],W7
1374:  MOV     [--W15],W6
1376:  MOV     [--W15],W5
1378:  MOV     W0,978
137A:  MOV     W1,97A
137C:  MOV     W2,97C
137E:  MOV     W3,97E
....................       sine_table[sine_index]=255*sin(theeta);
1380:  MOV     970,W0
1382:  SL      W0,#1,W0
1384:  MOV     #934,W4
1386:  ADD     W0,W4,W5
1388:  PUSH    978
138A:  POP     9F4
138C:  PUSH    97A
138E:  POP     9F6
1390:  PUSH    97C
1392:  POP     9F8
1394:  PUSH    97E
1396:  POP     9FA
1398:  CALL    1266
139C:  MOV     W5,[W15++]
139E:  MOV     W0,W4
13A0:  MOV     W1,W5
13A2:  MOV     W2,W6
13A4:  MOV     W3,W7
13A6:  MOV     #0,W0
13A8:  MOV     #0,W1
13AA:  MOV     #E000,W2
13AC:  MOV     #406F,W3
13AE:  CALL    AD6
13B2:  MOV     [--W15],W5
13B4:  CALL    12A2
13B8:  MOV     W0,[W5]
13BA:  INC     0970
13BC:  BRA     130A
....................    }
13BE:  MOV     [--W15],W8
13C0:  MOV     [--W15],W7
13C2:  MOV     [--W15],W6
13C4:  MOV     [--W15],W5
13C6:  RETURN  
.................... }
.................... 
.................... int1 QEI_get_direction(void) 
.................... {
....................    if (*(QEICON +1) & (1 << UPDN)) return 1;
*
1674:  BTSS.B  123.3
1676:  BRA     167E
1678:  MOV.B   #1,W0L
167A:  MOV.B   W0L,0
167C:  BRA     1680
....................    
....................    return 0;
167E:  CLR.B   0
1680:  RETURN  
.................... 
.................... }
.................... 
.................... //-----------------IMPLEMENATION REQUIRED--------------//
.................... 
.................... //==========RESPONSE ON BREAK INPUT===========
.................... // DRIVE PWM TO 0 ON BREAK INPUT...
.................... 
.................... 
.................... //=========INPUT FREQUENCY VS MOTOR SPEED DIFFERENCE CALCULATION====
.................... /*
....................    speed  = (freq_table[throttle_level] * 120) / poles
....................    enc_freq = (speed * 64) / 60
....................    
....................    slip = motor_enc_freq - enc_freq;
....................    
.................... */
.................... /*
.................... ==========FOLLOW UP MOTOR SPEED ALGORITHM===========
.................... - sending throttle value from serial.
.................... - is speed_table[throttle_level] == motor_enc
.................... - if yes go to next speed value.
.................... 
.................... if (current_speed != set_speed && current_speed == next_speed)
....................          {
....................             next_speed++;
....................             throttle_level++;
....................             prev_speed = current_speed;
....................          }
....................          
....................          if (current_speed <= prev_speed)
....................          {
....................             // speed is decreasing.
....................             prev_speed = current_speed;
....................             
....................          }
.................... 
.................... */

Configuration Fuses:
   Word  1L: 0306   XT_PLL8 PR CKSFSM
          H: 0000  
   Word  2L: 003F   WPSB16 WPSA512 NOWDT
          H: 0000  
   Word  3L: 8793   PUT64 BORV42 BROWNOUT LPOL_HIGH HPOL_HIGH NOPWMPIN MCLR
          H: 0000  
   Word  4L: 310F  
          H: 0000  
   Word  5L: 330F  
          H: 0000  
   Word  6L: 0004   WRT PROTECT
          H: 0000  
   Word  7L: C003   ICSP1 NODEBUG
          H: 0000  
