CCS PCD C Compiler, Version 5.112, 5967               01-Jul-24 15:14

               Filename:   C:\Users\eelab\Documents\[2024-05-15] MOTOR_CONTROL\main.lst

               ROM used:   6338 bytes (19%)
                           Largest free fragment is 26430
               RAM used:   660 (32%) at main() level
                           867 (42%) worst case
               Stack used: 96 locations (46 in main + 50 for interrupts)
               Stack size: 128

*
0000:  GOTO    14FC
*
0022:  DATA    E6,07,00
*
0026:  DATA    08,07,00
*
0062:  DATA    42,07,00
.................... #include <30F4011.h>
.................... //////////// Standard Header file for the DSPIC30F4011 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
*
0732:  MOV     #1A,W0
0734:  REPEAT  #C
0736:  MOV     [--W15],[W0--]
0738:  MOV     [--W15],W0
073A:  POP     32
073C:  POP     36
073E:  POP     42
0740:  RETFIE  
.................... #device DSPIC30F4011
*
0100:  CLR     32
0102:  MOV     #156,W3
0104:  SUB     W0,W3,W3
0106:  BRA     C,110
0108:  MOV     #122,W3
010A:  ADD     W3,W0,W0
010C:  TBLRDL  [W0],W0
010E:  RETURN  
0110:  MOV     #122,W0
0112:  BCLR.B  6.0
0114:  ADD     W3,W3,W3
0116:  ADD     W3,W0,W3
0118:  TBLRDH  [W3++],W0
011A:  TBLRDH  [W3],W3
011C:  SL      W3,#8,W3
011E:  IOR      W3,  W0,W0
0120:  RETURN  
0122:  DATA    00,00,23
0124:  DATA    00,00,01
0126:  DATA    00,00,26
0128:  DATA    00,00,01
012A:  DATA    00,00,29
012C:  DATA    00,00,01
012E:  DATA    00,00,2C
0130:  DATA    00,00,01
0132:  DATA    00,00,2E
0134:  DATA    00,00,01
0136:  DATA    00,00,31
0138:  DATA    00,00,01
013A:  DATA    00,00,34
013C:  DATA    00,00,01
013E:  DATA    00,00,37
0140:  DATA    00,00,01
0142:  DATA    00,00,3A
0144:  DATA    00,00,01
0146:  DATA    00,00,3D
0148:  DATA    00,00,01
014A:  DATA    00,00,40
014C:  DATA    17,00,01
014E:  DATA    1A,00,42
0150:  DATA    1A,00,01
0152:  DATA    1D,00,45
0154:  DATA    1D,00,01
0156:  DATA    20,00,49
0158:  DATA    20,00,01
015A:  DATA    22,00,4B
015C:  DATA    22,00,01
015E:  DATA    25,00,4E
0160:  DATA    25,00,01
0162:  DATA    28,00,51
0164:  DATA    28,00,01
0166:  DATA    2B,00,53
0168:  DATA    2B,00,01
016A:  DATA    2E,00,5A
016C:  DATA    31,00,01
016E:  DATA    31,00,5C
0170:  DATA    33,00,01
0172:  DATA    33,00,5F
0174:  DATA    36,00,01
0176:  DATA    36,00,62
0178:  DATA    39,00,01
017A:  DATA    39,00,64
017C:  DATA    3C,00,01
017E:  DATA    3C,00,68
0180:  DATA    3F,00,01
0182:  DATA    3F,00,6D
0184:  DATA    42,00,01
0186:  DATA    42,00,70
0188:  DATA    44,00,01
018A:  DATA    44,00,73
018C:  DATA    47,00,01
018E:  DATA    47,00,76
0190:  DATA    4A,00,01
0192:  DATA    4D,00,7C
0194:  DATA    4D,00,01
0196:  DATA    50,00,7F
0198:  DATA    50,00,01
019A:  DATA    53,00,81
019C:  DATA    53,00,01
019E:  DATA    56,00,87
01A0:  DATA    56,00,01
01A2:  DATA    58,00,8A
01A4:  DATA    58,00,01
01A6:  DATA    5B,00,90
01A8:  DATA    5B,00,01
01AA:  DATA    5F,00,92
01AC:  DATA    61,00,01
01AE:  DATA    61,00,95
01B0:  DATA    64,00,01
01B2:  DATA    64,00,9B
01B4:  DATA    67,00,01
01B6:  DATA    67,00,9E
01B8:  DATA    69,00,01
01BA:  DATA    69,00,A3
01BC:  DATA    6C,00,01
01BE:  DATA    70,00,A6
01C0:  DATA    70,00,01
01C2:  DATA    72,00,AC
01C4:  DATA    72,00,01
01C6:  DATA    75,00,AF
01C8:  DATA    75,00,01
01CA:  DATA    78,00,B5
01CC:  DATA    78,00,01
01CE:  DATA    7A,00,BA
01D0:  DATA    7E,00,01
01D2:  DATA    7E,00,BE
01D4:  DATA    81,00,01
01D6:  DATA    81,00,C3
01D8:  DATA    83,00,01
01DA:  DATA    83,00,C8
01DC:  DATA    86,00,01
01DE:  DATA    89,00,CC
01E0:  DATA    89,00,01
01E2:  DATA    8C,00,D1
01E4:  DATA    8C,00,01
01E6:  DATA    8F,00,D7
01E8:  DATA    8F,00,01
01EA:  DATA    92,00,D9
01EC:  DATA    95,00,01
01EE:  DATA    95,00,E0
01F0:  DATA    97,00,01
01F2:  DATA    97,00,E5
01F4:  DATA    9A,00,01
01F6:  DATA    9D,00,EB
01F8:  DATA    9D,00,01
01FA:  DATA    A0,00,F1
01FC:  DATA    A0,00,01
01FE:  DATA    A3,00,F6
0200:  DATA    A6,00,01
0202:  DATA    A6,00,FC
0204:  DATA    A8,00,01
0206:  DATA    AB,00,02
0208:  DATA    AB,00,02
020A:  DATA    AE,00,07
020C:  DATA    AE,00,02
020E:  DATA    B1,00,0D
0210:  DATA    B4,00,02
0212:  DATA    B4,00,13
0214:  DATA    B7,00,02
0216:  DATA    B9,00,18
0218:  DATA    B9,00,02
021A:  DATA    BC,00,1E
021C:  DATA    BF,00,02
021E:  DATA    BF,00,27
0220:  DATA    C2,00,02
0222:  DATA    C5,00,2C
0224:  DATA    C5,00,02
0226:  DATA    C8,00,33
0228:  DATA    CB,00,02
022A:  DATA    CB,00,38
022C:  DATA    CD,00,02
022E:  DATA    D0,00,41
0230:  DATA    D0,00,02
0232:  DATA    D4,00,46
0234:  DATA    D6,00,02
0236:  DATA    D6,00,4E
0238:  DATA    D9,00,02
023A:  DATA    DC,00,55
023C:  DATA    DE,00,02
023E:  DATA    DE,00,5D
0240:  DATA    E2,00,02
0242:  DATA    E5,00,63
0244:  DATA    E7,00,02
0246:  DATA    E7,00,6B
0248:  DATA    EA,00,02
024A:  DATA    ED,00,74
024C:  DATA    EF,00,02
024E:  DATA    EF,00,7A
0250:  DATA    F3,00,02
0252:  DATA    F6,00,82
0254:  DATA    F8,00,02
0256:  DATA    F8,00,8B
0258:  DATA    FB,00,02
025A:  DATA    FE,00,93
025C:  DATA    01,01,02
025E:  DATA    04,01,9C
0260:  DATA    07,01,02
0262:  DATA    07,01,A5
0264:  DATA    0A,01,02
0266:  DATA    0C,01,AD
0268:  DATA    0F,01,02
026A:  DATA    12,01,B6
026C:  DATA    15,01,02
026E:  DATA    18,01,BE
0270:  DATA    18,01,02
0272:  DATA    1B,01,CA
0274:  DATA    1D,01,02
0276:  DATA    20,01,00
0278:  CLR     32
027A:  MOV     #156,W3
027C:  SUB     W0,W3,W3
027E:  BRA     C,288
0280:  MOV     #29A,W3
0282:  ADD     W3,W0,W0
0284:  TBLRDL  [W0],W0
0286:  RETURN  
0288:  MOV     #29A,W0
028A:  BCLR.B  6.0
028C:  ADD     W3,W3,W3
028E:  ADD     W3,W0,W3
0290:  TBLRDH  [W3++],W0
0292:  TBLRDH  [W3],W3
0294:  SL      W3,#8,W3
0296:  IOR      W3,  W0,W0
0298:  RETURN  
029A:  DATA    00,00,63
029C:  DATA    00,00,01
029E:  DATA    00,00,68
02A0:  DATA    00,00,01
02A2:  DATA    00,00,6B
02A4:  DATA    00,00,01
02A6:  DATA    00,00,6E
02A8:  DATA    00,00,01
02AA:  DATA    00,00,72
02AC:  DATA    00,00,01
02AE:  DATA    00,00,75
02B0:  DATA    00,00,01
02B2:  DATA    00,00,78
02B4:  DATA    00,00,01
02B6:  DATA    00,00,7D
02B8:  DATA    00,00,01
02BA:  DATA    00,00,80
02BC:  DATA    00,00,01
02BE:  DATA    00,00,83
02C0:  DATA    00,00,01
02C2:  DATA    00,00,87
02C4:  DATA    1C,00,01
02C6:  DATA    20,00,8A
02C8:  DATA    20,00,01
02CA:  DATA    23,00,8D
02CC:  DATA    23,00,01
02CE:  DATA    27,00,92
02D0:  DATA    27,00,01
02D2:  DATA    2A,00,95
02D4:  DATA    2A,00,01
02D6:  DATA    2D,00,98
02D8:  DATA    2D,00,01
02DA:  DATA    30,00,9B
02DC:  DATA    30,00,01
02DE:  DATA    35,00,9F
02E0:  DATA    35,00,01
02E2:  DATA    38,00,A6
02E4:  DATA    3B,00,01
02E6:  DATA    3B,00,AA
02E8:  DATA    3F,00,01
02EA:  DATA    3F,00,AD
02EC:  DATA    42,00,01
02EE:  DATA    42,00,B0
02F0:  DATA    45,00,01
02F2:  DATA    45,00,B4
02F4:  DATA    4A,00,01
02F6:  DATA    4A,00,B8
02F8:  DATA    4D,00,01
02FA:  DATA    4D,00,BF
02FC:  DATA    50,00,01
02FE:  DATA    50,00,C2
0300:  DATA    54,00,01
0302:  DATA    54,00,C5
0304:  DATA    57,00,01
0306:  DATA    57,00,C9
0308:  DATA    5A,00,01
030A:  DATA    5F,00,D0
030C:  DATA    5F,00,01
030E:  DATA    62,00,D4
0310:  DATA    62,00,01
0312:  DATA    65,00,D7
0314:  DATA    65,00,01
0316:  DATA    69,00,DD
0318:  DATA    69,00,01
031A:  DATA    6C,00,E2
031C:  DATA    6C,00,01
031E:  DATA    6F,00,E8
0320:  DATA    6F,00,01
0322:  DATA    74,00,EC
0324:  DATA    77,00,01
0326:  DATA    77,00,EF
0328:  DATA    7A,00,01
032A:  DATA    7A,00,F7
032C:  DATA    7D,00,01
032E:  DATA    7D,00,FA
0330:  DATA    81,00,01
0332:  DATA    81,00,01
0334:  DATA    84,00,02
0336:  DATA    88,00,04
0338:  DATA    88,00,02
033A:  DATA    8C,00,0C
033C:  DATA    8C,00,02
033E:  DATA    8F,00,0F
0340:  DATA    8F,00,02
0342:  DATA    92,00,16
0344:  DATA    92,00,02
0346:  DATA    96,00,1C
0348:  DATA    9A,00,02
034A:  DATA    9A,00,21
034C:  DATA    9D,00,02
034E:  DATA    9D,00,27
0350:  DATA    A1,00,02
0352:  DATA    A1,00,2E
0354:  DATA    A4,00,02
0356:  DATA    A7,00,32
0358:  DATA    A7,00,02
035A:  DATA    AB,00,39
035C:  DATA    AB,00,02
035E:  DATA    AF,00,3F
0360:  DATA    AF,00,02
0362:  DATA    B2,00,43
0364:  DATA    B6,00,02
0366:  DATA    B6,00,4A
0368:  DATA    B9,00,02
036A:  DATA    B9,00,51
036C:  DATA    BC,00,02
036E:  DATA    BF,00,58
0370:  DATA    BF,00,02
0372:  DATA    C4,00,5F
0374:  DATA    C4,00,02
0376:  DATA    C7,00,66
0378:  DATA    CA,00,02
037A:  DATA    CA,00,6C
037C:  DATA    CE,00,02
037E:  DATA    D1,00,74
0380:  DATA    D1,00,02
0382:  DATA    D4,00,7B
0384:  DATA    D4,00,02
0386:  DATA    D9,00,81
0388:  DATA    DC,00,02
038A:  DATA    DC,00,89
038C:  DATA    DF,00,02
038E:  DATA    E3,00,90
0390:  DATA    E3,00,02
0392:  DATA    E6,00,96
0394:  DATA    E9,00,02
0396:  DATA    E9,00,A1
0398:  DATA    EE,00,02
039A:  DATA    F1,00,A8
039C:  DATA    F1,00,02
039E:  DATA    F4,00,B0
03A0:  DATA    F8,00,02
03A2:  DATA    F8,00,B6
03A4:  DATA    FB,00,02
03A6:  DATA    FE,00,C1
03A8:  DATA    FE,00,02
03AA:  DATA    03,01,C8
03AC:  DATA    06,01,02
03AE:  DATA    06,01,D2
03B0:  DATA    09,01,02
03B2:  DATA    0C,01,D9
03B4:  DATA    10,01,02
03B6:  DATA    10,01,E3
03B8:  DATA    14,01,02
03BA:  DATA    17,01,EB
03BC:  DATA    1B,01,02
03BE:  DATA    1B,01,F5
03C0:  DATA    1E,01,02
03C2:  DATA    21,01,00
03C4:  DATA    25,01,03
03C6:  DATA    25,01,06
03C8:  DATA    29,01,03
03CA:  DATA    2C,01,10
03CC:  DATA    30,01,03
03CE:  DATA    30,01,1B
03D0:  DATA    33,01,03
03D2:  DATA    36,01,25
03D4:  DATA    3A,01,03
03D6:  DATA    3E,01,30
03D8:  DATA    41,01,03
03DA:  DATA    41,01,3B
03DC:  DATA    45,01,03
03DE:  DATA    48,01,45
03E0:  DATA    4B,01,03
03E2:  DATA    4E,01,50
03E4:  DATA    53,01,03
03E6:  DATA    56,01,5A
03E8:  DATA    56,01,03
03EA:  DATA    59,01,68
03EC:  DATA    5D,01,03
03EE:  DATA    60,01,00
03F0:  CLR     32
03F2:  MOV     #156,W3
03F4:  SUB     W0,W3,W3
03F6:  BRA     C,400
03F8:  MOV     #412,W3
03FA:  ADD     W3,W0,W0
03FC:  TBLRDL  [W0],W0
03FE:  RETURN  
0400:  MOV     #412,W0
0402:  BCLR.B  6.0
0404:  ADD     W3,W3,W3
0406:  ADD     W3,W0,W3
0408:  TBLRDH  [W3++],W0
040A:  TBLRDH  [W3],W3
040C:  SL      W3,#8,W3
040E:  IOR      W3,  W0,W0
0410:  RETURN  
0412:  DATA    2C,FE,50
0414:  DATA    2C,FE,14
0416:  DATA    2C,FE,21
0418:  DATA    2C,FE,14
041A:  DATA    2C,FE,F2
041C:  DATA    2C,FE,13
041E:  DATA    2C,FE,C3
0420:  DATA    2C,FE,13
0422:  DATA    2C,FE,95
0424:  DATA    2C,FE,13
0426:  DATA    2C,FE,68
0428:  DATA    2C,FE,13
042A:  DATA    2C,FE,3B
042C:  DATA    2C,FE,13
042E:  DATA    2C,FE,0E
0430:  DATA    2C,FE,13
0432:  DATA    2C,FE,E1
0434:  DATA    2C,FE,12
0436:  DATA    2C,FE,B5
0438:  DATA    2C,FE,12
043A:  DATA    2C,FE,89
043C:  DATA    22,EF,12
043E:  DATA    C3,E1,5D
0440:  DATA    CD,D5,12
0442:  DATA    09,CB,31
0444:  DATA    4C,C1,12
0446:  DATA    71,B8,06
0448:  DATA    5C,B0,12
044A:  DATA    F3,A8,DC
044C:  DATA    21,A2,11
044E:  DATA    D6,9B,B1
0450:  DATA    02,96,11
0452:  DATA    98,90,87
0454:  DATA    8E,8B,11
0456:  DATA    DA,86,5D
0458:  DATA    73,82,11
045A:  DATA    53,7E,33
045C:  DATA    72,7A,11
045E:  DATA    CC,76,0A
0460:  DATA    5B,73,11
0462:  DATA    1B,70,E1
0464:  DATA    08,6D,10
0466:  DATA    1D,6A,B8
0468:  DATA    5A,67,10
046A:  DATA    B9,64,8F
046C:  DATA    39,62,10
046E:  DATA    D7,5F,67
0470:  DATA    92,5D,10
0472:  DATA    67,5B,3F
0474:  DATA    54,59,10
0476:  DATA    58,57,17
0478:  DATA    72,55,10
047A:  DATA    A0,53,EF
047C:  DATA    E1,51,0F
047E:  DATA    33,50,C8
0480:  DATA    96,4E,0F
0482:  DATA    09,4D,A0
0484:  DATA    8B,4B,0F
0486:  DATA    1B,4A,79
0488:  DATA    B8,48,0F
048A:  DATA    61,47,53
048C:  DATA    17,46,0F
048E:  DATA    D8,44,2C
0490:  DATA    A3,43,0F
0492:  DATA    79,42,06
0494:  DATA    58,41,0F
0496:  DATA    40,40,E0
0498:  DATA    31,3F,0E
049A:  DATA    2B,3E,BA
049C:  DATA    2C,3D,0E
049E:  DATA    35,3C,94
04A0:  DATA    45,3B,0E
04A2:  DATA    5C,3A,6F
04A4:  DATA    7A,39,0E
04A6:  DATA    9E,38,4A
04A8:  DATA    C8,37,0E
04AA:  DATA    F8,36,25
04AC:  DATA    2D,36,0E
04AE:  DATA    68,35,00
04B0:  DATA    A8,34,0E
04B2:  DATA    EC,33,DB
04B4:  DATA    36,33,0D
04B6:  DATA    84,32,B7
04B8:  DATA    D6,31,0D
04BA:  DATA    2D,31,93
04BC:  DATA    87,30,0D
04BE:  DATA    E6,2F,6F
04C0:  DATA    48,2F,0D
04C2:  DATA    AE,2E,4B
04C4:  DATA    17,2E,0D
04C6:  DATA    84,2D,28
04C8:  DATA    F4,2C,0D
04CA:  DATA    67,2C,04
04CC:  DATA    DD,2B,0D
04CE:  DATA    56,2B,E1
04D0:  DATA    D2,2A,0C
04D2:  DATA    50,2A,BE
04D4:  DATA    D1,29,0C
04D6:  DATA    55,29,9B
04D8:  DATA    DB,28,0C
04DA:  DATA    64,28,79
04DC:  DATA    EF,27,0C
04DE:  DATA    7C,27,56
04E0:  DATA    0B,27,0C
04E2:  DATA    9C,26,34
04E4:  DATA    30,26,0C
04E6:  DATA    C5,25,12
04E8:  DATA    5C,25,0C
04EA:  DATA    F5,24,F0
04EC:  DATA    90,24,0B
04EE:  DATA    2D,24,CF
04F0:  DATA    CB,23,0B
04F2:  DATA    6B,23,AD
04F4:  DATA    0D,23,0B
04F6:  DATA    B0,22,8C
04F8:  DATA    55,22,0B
04FA:  DATA    FB,21,6B
04FC:  DATA    A3,21,0B
04FE:  DATA    4B,21,4A
0500:  DATA    F6,20,0B
0502:  DATA    A1,20,2A
0504:  DATA    4E,20,0B
0506:  DATA    FC,1F,09
0508:  DATA    AC,1F,0B
050A:  DATA    5C,1F,E9
050C:  DATA    0E,1F,0A
050E:  DATA    C1,1E,C9
0510:  DATA    74,1E,0A
0512:  DATA    29,1E,A9
0514:  DATA    DF,1D,0A
0516:  DATA    96,1D,89
0518:  DATA    4E,1D,0A
051A:  DATA    07,1D,6A
051C:  DATA    C1,1C,0A
051E:  DATA    7B,1C,4A
0520:  DATA    37,1C,0A
0522:  DATA    F3,1B,2B
0524:  DATA    B1,1B,0A
0526:  DATA    6F,1B,0C
0528:  DATA    2E,1B,0A
052A:  DATA    ED,1A,EE
052C:  DATA    AE,1A,09
052E:  DATA    6F,1A,CF
0530:  DATA    31,1A,09
0532:  DATA    F3,19,B1
0534:  DATA    B6,19,09
0536:  DATA    7A,19,93
0538:  DATA    3F,19,09
053A:  DATA    04,19,75
053C:  DATA    CA,18,09
053E:  DATA    91,18,57
0540:  DATA    58,18,09
0542:  DATA    1F,18,39
0544:  DATA    E8,17,09
0546:  DATA    B0,17,1C
0548:  DATA    7A,17,09
054A:  DATA    43,17,FF
054C:  DATA    0E,17,08
054E:  DATA    D9,16,E2
0550:  DATA    A4,16,08
0552:  DATA    70,16,C5
0554:  DATA    3C,16,08
0556:  DATA    09,16,A9
0558:  DATA    D6,15,08
055A:  DATA    A4,15,8C
055C:  DATA    72,15,08
055E:  DATA    41,15,70
0560:  DATA    10,15,08
0562:  DATA    DF,14,54
0564:  DATA    AF,14,08
0566:  DATA    7F,14,00
0568:  CLR     32
056A:  MOV     #156,W3
056C:  SUB     W0,W3,W3
056E:  BRA     C,578
0570:  MOV     #58A,W3
0572:  ADD     W3,W0,W0
0574:  TBLRDL  [W0],W0
0576:  RETURN  
0578:  MOV     #58A,W0
057A:  BCLR.B  6.0
057C:  ADD     W3,W3,W3
057E:  ADD     W3,W0,W3
0580:  TBLRDH  [W3++],W0
0582:  TBLRDH  [W3],W3
0584:  SL      W3,#8,W3
0586:  IOR      W3,  W0,W0
0588:  RETURN  
058A:  DATA    00,00,B7
058C:  DATA    00,00,00
058E:  DATA    00,00,B9
0590:  DATA    00,00,00
0592:  DATA    00,00,BB
0594:  DATA    00,00,00
0596:  DATA    00,00,BD
0598:  DATA    00,00,00
059A:  DATA    00,00,BF
059C:  DATA    00,00,00
059E:  DATA    00,00,C1
05A0:  DATA    00,00,00
05A2:  DATA    00,00,C3
05A4:  DATA    00,00,00
05A6:  DATA    00,00,C6
05A8:  DATA    00,00,00
05AA:  DATA    00,00,C8
05AC:  DATA    00,00,00
05AE:  DATA    00,00,C9
05B0:  DATA    00,00,00
05B2:  DATA    55,00,CB
05B4:  DATA    55,00,00
05B6:  DATA    55,00,CC
05B8:  DATA    56,00,00
05BA:  DATA    56,00,CD
05BC:  DATA    56,00,00
05BE:  DATA    56,00,CF
05C0:  DATA    56,00,00
05C2:  DATA    57,00,D0
05C4:  DATA    57,00,00
05C6:  DATA    57,00,D1
05C8:  DATA    57,00,00
05CA:  DATA    57,00,D3
05CC:  DATA    58,00,00
05CE:  DATA    58,00,D4
05D0:  DATA    58,00,00
05D2:  DATA    58,00,D6
05D4:  DATA    59,00,00
05D6:  DATA    59,00,D8
05D8:  DATA    59,00,00
05DA:  DATA    59,00,D9
05DC:  DATA    59,00,00
05DE:  DATA    5A,00,DB
05E0:  DATA    5A,00,00
05E2:  DATA    5A,00,DC
05E4:  DATA    5A,00,00
05E6:  DATA    5B,00,DE
05E8:  DATA    5B,00,00
05EA:  DATA    5B,00,E0
05EC:  DATA    5C,00,00
05EE:  DATA    5C,00,E1
05F0:  DATA    5C,00,00
05F2:  DATA    5C,00,E3
05F4:  DATA    5D,00,00
05F6:  DATA    5D,00,E5
05F8:  DATA    5D,00,00
05FA:  DATA    5E,00,E7
05FC:  DATA    5E,00,00
05FE:  DATA    5E,00,E9
0600:  DATA    5F,00,00
0602:  DATA    5F,00,EB
0604:  DATA    5F,00,00
0606:  DATA    60,00,ED
0608:  DATA    60,00,00
060A:  DATA    60,00,EF
060C:  DATA    60,00,00
060E:  DATA    61,00,F1
0610:  DATA    61,00,00
0612:  DATA    62,00,F3
0614:  DATA    62,00,00
0616:  DATA    62,00,F6
0618:  DATA    63,00,00
061A:  DATA    63,00,F8
061C:  DATA    63,00,00
061E:  DATA    64,00,FA
0620:  DATA    64,00,00
0622:  DATA    65,00,FD
0624:  DATA    65,00,00
0626:  DATA    66,00,FF
0628:  DATA    66,00,00
062A:  DATA    66,00,02
062C:  DATA    67,00,01
062E:  DATA    67,00,04
0630:  DATA    68,00,01
0632:  DATA    68,00,07
0634:  DATA    69,00,01
0636:  DATA    69,00,0A
0638:  DATA    6A,00,01
063A:  DATA    6A,00,0D
063C:  DATA    6B,00,01
063E:  DATA    6B,00,10
0640:  DATA    6B,00,01
0642:  DATA    6C,00,13
0644:  DATA    6D,00,01
0646:  DATA    6D,00,16
0648:  DATA    6D,00,01
064A:  DATA    6E,00,19
064C:  DATA    6F,00,01
064E:  DATA    6F,00,1D
0650:  DATA    70,00,01
0652:  DATA    70,00,20
0654:  DATA    71,00,01
0656:  DATA    72,00,24
0658:  DATA    72,00,01
065A:  DATA    73,00,28
065C:  DATA    73,00,01
065E:  DATA    74,00,2C
0660:  DATA    74,00,01
0662:  DATA    75,00,2F
0664:  DATA    76,00,01
0666:  DATA    76,00,34
0668:  DATA    77,00,01
066A:  DATA    78,00,38
066C:  DATA    78,00,01
066E:  DATA    79,00,3C
0670:  DATA    7A,00,01
0672:  DATA    7B,00,41
0674:  DATA    7B,00,01
0676:  DATA    7C,00,46
0678:  DATA    7D,00,01
067A:  DATA    7E,00,4B
067C:  DATA    7F,00,01
067E:  DATA    7F,00,50
0680:  DATA    80,00,01
0682:  DATA    81,00,55
0684:  DATA    82,00,01
0686:  DATA    82,00,5B
0688:  DATA    83,00,01
068A:  DATA    84,00,61
068C:  DATA    85,00,01
068E:  DATA    86,00,67
0690:  DATA    86,00,01
0692:  DATA    87,00,6D
0694:  DATA    88,00,01
0696:  DATA    89,00,74
0698:  DATA    8A,00,01
069A:  DATA    8B,00,7B
069C:  DATA    8C,00,01
069E:  DATA    8D,00,82
06A0:  DATA    8E,00,01
06A2:  DATA    8F,00,8A
06A4:  DATA    91,00,01
06A6:  DATA    92,00,92
06A8:  DATA    93,00,01
06AA:  DATA    94,00,9A
06AC:  DATA    95,00,01
06AE:  DATA    96,00,A3
06B0:  DATA    97,00,01
06B2:  DATA    98,00,AC
06B4:  DATA    99,00,01
06B6:  DATA    9A,00,B6
06B8:  DATA    9B,00,01
06BA:  DATA    9C,00,C1
06BC:  DATA    9D,00,01
06BE:  DATA    9E,00,CC
06C0:  DATA    A0,00,01
06C2:  DATA    A1,00,CC
06C4:  DATA    A2,00,01
06C6:  DATA    A3,00,CC
06C8:  DATA    A4,00,01
06CA:  DATA    A6,00,CC
06CC:  DATA    A7,00,01
06CE:  DATA    A8,00,CC
06D0:  DATA    AA,00,01
06D2:  DATA    AB,00,CC
06D4:  DATA    AD,00,01
06D6:  DATA    AE,00,CC
06D8:  DATA    B0,00,01
06DA:  DATA    B2,00,CC
06DC:  DATA    B3,00,01
06DE:  DATA    B5,00,00
06E0:  CLR     32
06E2:  MOV     #6EC,W3
06E4:  ADD     W3,W0,W0
06E6:  TBLRDL.B[W0],W0L
06E8:  CLR.B   1
06EA:  RETURN  
06EC:  DATA    0A,4D,00
06EE:  DATA    6F,74,00
06F0:  DATA    6F,72,00
06F2:  DATA    20,43,00
06F4:  DATA    6F,6E,00
06F6:  DATA    74,72,00
06F8:  DATA    6F,6C,00
06FA:  DATA    20,55,00
06FC:  DATA    6E,69,00
06FE:  DATA    74,20,00
0700:  DATA    76,30,00
0702:  DATA    2E,31,00
0704:  DATA    0D,0A,00
0706:  DATA    00,00,00
0708:  PUSH    42
070A:  PUSH    36
070C:  PUSH    32
070E:  MOV     W0,[W15++]
0710:  MOV     #2,W0
0712:  REPEAT  #C
0714:  MOV     [W0++],[W15++]
0716:  MOV     #800,W0
0718:  MOV     864,W4
071A:  ADD     W0,W4,W1
071C:  MOV     212,W0
071E:  BCLR.B  85.1
0720:  MOV.B   W0L,[W1++]
0722:  INC     0864
0724:  MOV     #63,W4
0726:  MOV     864,W3
0728:  SUB     W4,W3,W0
072A:  BRA     C,72E
072C:  CLR     864
072E:  BTSC.B  20E.0
0730:  BRA     71C
*
07A4:  MOV     W5,[W15++]
07A6:  MOV     #C,W5
07A8:  REPEAT  #3
07AA:  MOV     [W5++],[W15++]
07AC:  MUL.UU  W0,W2,W4
07AE:  BTSS    W3.F
07B0:  BRA     7B6
07B2:  MUL.SS  W0,W3,W6
07B4:  BRA     7B8
07B6:  MUL.UU  W0,W3,W6
07B8:  BCLR.B  42.0
07BA:  ADD     W6,W5,W5
07BC:  ADDC    W7,#0,W8
07BE:  BTSS    W1.F
07C0:  BRA     7C6
07C2:  MUL.SS  W1,W2,W6
07C4:  BRA     7C8
07C6:  MUL.UU  W1,W2,W6
07C8:  ADDC    W6,W5,W5
07CA:  ADDC    W7,W8,W8
07CC:  ADDC    #0,W9
07CE:  MUL.SS  W1,W3,W6
07D0:  ADDC    W6,W8,W8
07D2:  ADDC    W9,W7,W7
07D4:  MOV     W7,W3
07D6:  MOV     W8,W2
07D8:  MOV     W5,W1
07DA:  MOV     W4,W0
07DC:  MOV     #12,W5
07DE:  REPEAT  #3
07E0:  MOV     [--W15],[W5--]
07E2:  MOV     [--W15],W5
07E4:  RETURN  
*
09FC:  MOV     W1,[W15++]
09FE:  MOV     A12,W1
0A00:  MOV.B   W0L,[W1++]
0A02:  CLR.B   [W1]
0A04:  MOV     [--W15],W1
0A06:  INC     0A12
0A08:  RETURN  
*
0A62:  MOV     W5,[W15++]
0A64:  MOV     #C,W5
0A66:  REPEAT  #3
0A68:  MOV     [W5++],[W15++]
0A6A:  MOV     W0,W4
0A6C:  MOV     W1,W5
0A6E:  MOV     W2,W6
0A70:  MOV     W3,W7
0A72:  CLR     W0
0A74:  CLR     W1
0A76:  CLR     W2
0A78:  CLR     W3
0A7A:  BCLR    W8.0
0A7C:  BTSS    W7.F
0A7E:  BRA     A90
0A80:  BSET    W8.0
0A82:  COM     W7,W7
0A84:  COM     W6,W6
0A86:  COM     W5,W5
0A88:  NEG     W4,W4
0A8A:  ADDC    W5,#0,W5
0A8C:  ADDC    W6,#0,W6
0A8E:  ADDC    W7,#0,W7
0A90:  IOR      W4,  W5,W9
0A92:  BRA     NZ,A98
0A94:  IOR      W6,  W7,W9
0A96:  BRA     Z,AC2
0A98:  MOV     #473,W9
0A9A:  BTSC    W3.4
0A9C:  BRA     AB4
0A9E:  BCLR.B  42.0
0AA0:  RLC     W4,W4
0AA2:  RLC     W5,W5
0AA4:  RLC     W6,W6
0AA6:  RLC     W7,W7
0AA8:  RLC     W0,W0
0AAA:  RLC     W1,W1
0AAC:  RLC     W2,W2
0AAE:  RLC     W3,W3
0AB0:  DEC     W9,W9
0AB2:  BRA     NZ,A9A
0AB4:  SL      W9,#4,W9
0AB6:  BCLR.B  42.0
0AB8:  BCLR    W9.F
0ABA:  BCLR    W3.4
0ABC:  XOR     W9,W3,W3
0ABE:  BTSC    W8.0
0AC0:  BSET    W3.F
0AC2:  MOV     #12,W5
0AC4:  REPEAT  #3
0AC6:  MOV     [--W15],[W5--]
0AC8:  MOV     [--W15],W5
0ACA:  RETURN  
0ACC:  MOV     W8,[W15++]
0ACE:  MOV     #12,W8
0AD0:  REPEAT  #4
0AD2:  MOV     [W8++],[W15++]
0AD4:  CLR     W11
0AD6:  MUL.UU  W12,#0,W12
0AD8:  MOV     W3,W8
0ADA:  MOV     W7,W9
0ADC:  MOV     #7FF,W10
0ADE:  BCLR.B  42.0
0AE0:  BCLR.B  42.1
0AE2:  ASR     W8,#4,W8
0AE4:  AND     W10,W8,W8
0AE6:  CP0     W8
0AE8:  BRA     Z,BCC
0AEA:  BCLR.B  42.0
0AEC:  BCLR.B  42.1
0AEE:  ASR     W9,#4,W9
0AF0:  AND     W10,W9,W9
0AF2:  CP0     W9
0AF4:  BRA     Z,BCC
0AF6:  ADD     W9,W8,W8
0AF8:  BTSC    W9.B
0AFA:  BRA     B04
0AFC:  SUB     #3FF,W8
0AFE:  BRA     Z,BCC
0B00:  BRA     NC,BCC
0B02:  BRA     B0A
0B04:  MOV     #401,W10
0B06:  ADD.B   W10L,W5L,W5L
0B08:  BRA     C,BCC
0B0A:  XOR     W3,W7,W13
0B0C:  BCLR.B  42.0
0B0E:  BCLR.B  42.1
0B10:  AND     #F,W3
0B12:  BSET    W3.4
0B14:  AND     #F,W7
0B16:  BSET    W7.4
0B18:  MOV     W8,[W15++]
0B1A:  MUL.UU  W4,W1,W8
0B1C:  MUL.UU  W5,W0,W10
0B1E:  ADD     W8,W10,W10
0B20:  ADDC    W9,W11,W11
0B22:  ADDC    #0,W12
0B24:  MUL.UU  W4,W2,W8
0B26:  ADD     W8,W11,W11
0B28:  ADDC    W9,W12,W12
0B2A:  MUL.UU  W5,W1,W8
0B2C:  CLR     W10
0B2E:  ADD     W8,W11,W11
0B30:  ADDC    W9,W12,W12
0B32:  ADDC    #0,W10
0B34:  MUL.UU  W6,W0,W8
0B36:  ADD     W8,W11,W11
0B38:  ADDC    W9,W12,W12
0B3A:  ADDC    #0,W10
0B3C:  CLR     W11
0B3E:  MUL.UU  W4,W3,W8
0B40:  ADD     W8,W12,W12
0B42:  ADDC    W9,W10,W10
0B44:  ADDC    #0,W11
0B46:  MUL.UU  W5,W2,W8
0B48:  ADD     W8,W12,W12
0B4A:  ADDC    W9,W10,W10
0B4C:  ADDC    #0,W11
0B4E:  MUL.UU  W6,W1,W8
0B50:  ADD     W8,W12,W12
0B52:  ADDC    W9,W10,W10
0B54:  ADDC    #0,W11
0B56:  MUL.UU  W7,W0,W8
0B58:  ADD     W8,W12,W12
0B5A:  ADDC    W9,W10,W10
0B5C:  ADDC    #0,W11
0B5E:  MOV     W12,W0
0B60:  CLR     W12
0B62:  MUL.UU  W5,W3,W8
0B64:  ADD     W8,W10,W10
0B66:  ADDC    W9,W11,W11
0B68:  ADDC    #0,W12
0B6A:  MUL.UU  W6,W2,W8
0B6C:  ADD     W8,W10,W10
0B6E:  ADDC    W9,W11,W11
0B70:  ADDC    #0,W12
0B72:  MUL.UU  W6,W3,W8
0B74:  ADD     W8,W11,W11
0B76:  ADDC    W9,W12,W12
0B78:  MUL.UU  W7,W1,W8
0B7A:  ADD     W8,W10,W10
0B7C:  ADDC    W9,W11,W11
0B7E:  ADDC    #0,W12
0B80:  MUL.UU  W7,W2,W8
0B82:  ADD     W8,W11,W11
0B84:  ADDC    W9,W12,W12
0B86:  MUL.UU  W7,W3,W8
0B88:  ADD     W8,W12,W12
0B8A:  MOV     W10,W1
0B8C:  MOV     W11,W2
0B8E:  MOV     W12,W3
0B90:  MOV     #5,W4
0B92:  BCLR.B  42.0
0B94:  RRC     W3,W3
0B96:  RRC     W2,W2
0B98:  RRC     W1,W1
0B9A:  RRC     W0,W0
0B9C:  DEC     W4,W4
0B9E:  BRA     NZ,B92
0BA0:  MOV     [--W15],W8
0BA2:  INC     W8,W8
0BA4:  IOR      W0,  W1,W6
0BA6:  BRA     Z,BAA
0BA8:  BRA     BAE
0BAA:  IOR      W2,  W3,W6
0BAC:  BRA     Z,BBE
0BAE:  BTSC    W3.4
0BB0:  BRA     BBE
0BB2:  BCLR.B  42.0
0BB4:  RLC     W0,W0
0BB6:  RLC     W1,W1
0BB8:  RLC     W2,W2
0BBA:  RLC     W3,W3
0BBC:  DEC     W8,W8
0BBE:  SL      W8,#4,W8
0BC0:  BCLR    W3.F
0BC2:  BTSC    W13.F
0BC4:  BSET    W3.F
0BC6:  BCLR    W3.4
0BC8:  XOR     W8,W3,W3
0BCA:  BRA     BD2
0BCC:  MUL.UU  W0,#0,W0
0BCE:  MUL.UU  W0,#0,W2
0BD0:  BRA     BD2
0BD2:  MOV     #1A,W8
0BD4:  REPEAT  #4
0BD6:  MOV     [--W15],[W8--]
0BD8:  MOV     [--W15],W8
0BDA:  RETURN  
0BDC:  MOV     W8,[W15++]
0BDE:  MOV     #12,W8
0BE0:  REPEAT  #4
0BE2:  MOV     [W8++],[W15++]
0BE4:  XOR     W3,W7,W13
0BE6:  MOV     W3,W8
0BE8:  MOV     W7,W9
0BEA:  MOV     #7FF,W10
0BEC:  BCLR.B  42.0
0BEE:  BCLR.B  42.1
0BF0:  ASR     W8,#4,W8
0BF2:  AND     W10,W8,W8
0BF4:  CP0     W8
0BF6:  BRA     Z,CD0
0BF8:  BCLR.B  42.0
0BFA:  BCLR.B  42.1
0BFC:  ASR     W9,#4,W9
0BFE:  AND     W10,W9,W9
0C00:  CP0     W9
0C02:  BRA     Z,CD0
0C04:  CLR     W10
0C06:  SUB     W8,W9,W12
0C08:  BRA     NC,C10
0C0A:  ADD     #3FF,W12
0C0C:  BRA     C,CD0
0C0E:  BRA     C18
0C10:  MOV     #401,W11
0C12:  SUB     W12,W11,W12
0C14:  BRA     NC,CD0
0C16:  BRA     Z,CD0
0C18:  CLR     W8
0C1A:  CLR     W9
0C1C:  CLR     W10
0C1E:  CLR     W11
0C20:  AND     #1F,W3
0C22:  BSET    W3.4
0C24:  AND     #1F,W7
0C26:  BSET    W7.4
0C28:  MOV     W12,[W15++]
0C2A:  MOV     #36,W12
0C2C:  SUB     W0,W4,W0
0C2E:  SUBB    W1,W5,W1
0C30:  SUBB    W2,W6,W2
0C32:  SUBB    W3,W7,W3
0C34:  BRA     N,C3A
0C36:  BRA     C,C44
0C38:  BRA     NZ,C46
0C3A:  ADD     W0,W4,W0
0C3C:  ADDC    W1,W5,W1
0C3E:  ADDC    W2,W6,W2
0C40:  ADDC    W3,W7,W3
0C42:  BRA     C46
0C44:  BSET    W8.0
0C46:  DEC     W12,W12
0C48:  BRA     Z,C60
0C4A:  BCLR.B  42.0
0C4C:  RLC     W0,W0
0C4E:  RLC     W1,W1
0C50:  RLC     W2,W2
0C52:  RLC     W3,W3
0C54:  BCLR.B  42.0
0C56:  RLC     W8,W8
0C58:  RLC     W9,W9
0C5A:  RLC     W10,W10
0C5C:  RLC     W11,W11
0C5E:  BRA     C2C
0C60:  MOV     [--W15],W12
0C62:  BTSC    W11.5
0C64:  BRA     C68
0C66:  BRA     C74
0C68:  BCLR.B  42.0
0C6A:  RRC     W11,W11
0C6C:  RRC     W10,W10
0C6E:  RRC     W9,W9
0C70:  RRC     W8,W8
0C72:  BRA     C7A
0C74:  DEC     W12,W12
0C76:  BCLR.B  42.0
0C78:  BRA     Z,CD0
0C7A:  BTSC.B  42.0
0C7C:  BRA     C90
0C7E:  RLC     W0,W0
0C80:  RLC     W1,W1
0C82:  RLC     W2,W2
0C84:  RLC     W3,W3
0C86:  SUB     W0,W4,W4
0C88:  SUBB    W1,W5,W5
0C8A:  SUBB    W2,W6,W6
0C8C:  SUBB    W3,W7,W7
0C8E:  BRA     NC,CBA
0C90:  INC     W8,W8
0C92:  BRA     NZ,CBA
0C94:  INC     W9,W9
0C96:  BRA     NZ,CBA
0C98:  INC     W10,W10
0C9A:  BRA     NZ,CBA
0C9C:  INC     W11,W11
0C9E:  BRA     NZ,CBA
0CA0:  INC     W12,W12
0CA2:  BRA     Z,CD0
0CA4:  BRA     CBA
0CA6:  DEC     W12,W12
0CA8:  BRA     Z,CD0
0CAA:  BTSC    W11.4
0CAC:  BRA     CBA
0CAE:  BCLR.B  42.0
0CB0:  RLC     W8,W8
0CB2:  RLC     W9,W9
0CB4:  RLC     W10,W10
0CB6:  RLC     W11,W11
0CB8:  BRA     CAA
0CBA:  SL      W12,#4,W12
0CBC:  BCLR.B  42.0
0CBE:  BCLR    W12.F
0CC0:  BTSC    W13.F
0CC2:  BSET    W12.F
0CC4:  BCLR    W11.4
0CC6:  XOR     W12,W11,W3
0CC8:  MOV     W10,W2
0CCA:  MOV     W9,W1
0CCC:  MOV     W8,W0
0CCE:  BRA     CDA
0CD0:  MOV     #0,W0
0CD2:  MOV     #0,W1
0CD4:  MOV     #0,W2
0CD6:  MOV     #0,W3
0CD8:  BRA     CDA
0CDA:  MOV     #1A,W8
0CDC:  REPEAT  #4
0CDE:  MOV     [--W15],[W8--]
0CE0:  MOV     [--W15],W8
0CE2:  RETURN  
0CE4:  MOV     W8,[W15++]
0CE6:  MOV     #12,W8
0CE8:  REPEAT  #4
0CEA:  MOV     [W8++],[W15++]
0CEC:  MOV     #8000,W8
0CEE:  BTSC.B  43.0
0CF0:  XOR     W8,W7,W7
0CF2:  CP0     W0
0CF4:  BRA     NZ,D04
0CF6:  CP0     W1
0CF8:  BRA     NZ,D04
0CFA:  CP0     W2
0CFC:  BRA     NZ,D04
0CFE:  MOV     #7FFF,W10
0D00:  AND     W3,W10,W10
0D02:  BTSS.B  42.1
0D04:  MOV     W3,W10
0D06:  XOR     W7,W10,W11
0D08:  MOV     W3,W8
0D0A:  MOV     W7,W9
0D0C:  MOV     W7,W12
0D0E:  MOV     #7FF,W13
0D10:  BCLR.B  42.1
0D12:  BCLR.B  42.0
0D14:  ASR     W8,#4,W8
0D16:  AND     W13,W8,W8
0D18:  CP0     W8
0D1A:  BRA     Z,E94
0D1C:  BCLR.B  42.1
0D1E:  BCLR.B  42.0
0D20:  ASR     W9,#4,W9
0D22:  AND     W13,W9,W9
0D24:  CP0     W9
0D26:  BRA     Z,EA4
0D28:  CLR     W13
0D2A:  BCLR.B  42.1
0D2C:  BCLR.B  42.0
0D2E:  CP      W9,W8
0D30:  BRA     Z,EA6
0D32:  BRA     N,EB6
0D34:  BCLR    W13.0
0D36:  BSET    W13.1
0D38:  SUB     W9,W8,W8
0D3A:  AND     #F,W3
0D3C:  BSET    W3.4
0D3E:  AND     #F,W7
0D40:  BSET    W7.4
0D42:  SUB     #34,W8
0D44:  BRA     NN,D72
0D46:  ADD     #34,W8
0D48:  BCLR.B  42.1
0D4A:  BCLR.B  42.0
0D4C:  RRC     W3,W3
0D4E:  RRC     W2,W2
0D50:  RRC     W1,W1
0D52:  RRC     W0,W0
0D54:  DEC     W8,W8
0D56:  BRA     NZ,D48
0D58:  BRA     D82
0D5A:  SUB     #34,W8
0D5C:  BRA     NN,D7C
0D5E:  ADD     #34,W8
0D60:  BCLR.B  42.1
0D62:  BCLR.B  42.0
0D64:  RRC     W7,W7
0D66:  RRC     W6,W6
0D68:  RRC     W5,W5
0D6A:  RRC     W4,W4
0D6C:  DEC     W8,W8
0D6E:  BRA     NZ,D60
0D70:  BRA     DA8
0D72:  MOV     W4,W0
0D74:  MOV     W5,W1
0D76:  MOV     W6,W2
0D78:  MOV     W7,W3
0D7A:  XOR     W11,W12,W12
0D7C:  BTSC    W12.F
0D7E:  BTG     W11.F
0D80:  BRA     E74
0D82:  BTSS    W11.F
0D84:  BRA     DC4
0D86:  BTSC    W13.4
0D88:  MOV     W12,W11
0D8A:  COM     W0,W0
0D8C:  COM     W1,W1
0D8E:  COM     W2,W2
0D90:  COM.B   W3L,W3L
0D92:  AND.B   #1F,W3L
0D94:  INC     W0,W0
0D96:  BRA     NZ,DA2
0D98:  INC     W1,W1
0D9A:  BRA     NZ,DA2
0D9C:  INC     W2,W2
0D9E:  BRA     NZ,DA2
0DA0:  INC.B   W3L,W3L
0DA2:  BTSC    W13.4
0DA4:  BRA     E0A
0DA6:  BRA     DC4
0DA8:  BTSS    W11.F
0DAA:  BRA     DC4
0DAC:  COM     W4,W4
0DAE:  COM     W5,W5
0DB0:  COM     W6,W6
0DB2:  COM.B   W7L,W7L
0DB4:  AND.B   #1F,W7L
0DB6:  INC     W4,W4
0DB8:  BRA     NZ,DC4
0DBA:  INC     W5,W5
0DBC:  BRA     NZ,DC4
0DBE:  INC     W6,W6
0DC0:  BRA     NZ,DC4
0DC2:  INC.B   W7L,W7L
0DC4:  BCLR.B  42.1
0DC6:  BCLR.B  42.0
0DC8:  ADD     W0,W4,W0
0DCA:  ADDC    W1,W5,W1
0DCC:  ADDC    W2,W6,W2
0DCE:  ADDC.B  W3L,W7L,W3L
0DD0:  BTSC    W3.5
0DD2:  BSET    W13.3
0DD4:  BTSC    W13.0
0DD6:  BRA     DEA
0DD8:  BTSC    W13.1
0DDA:  BRA     DDE
0DDC:  BRA     DF4
0DDE:  BTSC    W11.F
0DE0:  BRA     E0A
0DE2:  BTSC    W13.3
0DE4:  BRA     E38
0DE6:  BSET    W13.6
0DE8:  BRA     E2C
0DEA:  BTSC    W11.F
0DEC:  BRA     E0A
0DEE:  BTSC    W13.3
0DF0:  BRA     E38
0DF2:  BRA     E2C
0DF4:  BTSC    W11.F
0DF6:  BRA     E00
0DF8:  MOV     W10,W11
0DFA:  BTSC    W13.3
0DFC:  BRA     E38
0DFE:  BRA     E74
0E00:  BSET    W13.4
0E02:  XOR.B   #10,W3L
0E04:  BTSC    W3.4
0E06:  BRA     D86
0E08:  MOV     W10,W11
0E0A:  AND     #1F,W3
0E0C:  IOR      W3,  W2,W8
0E0E:  BRA     NZ,E14
0E10:  IOR      W1,  W0,W8
0E12:  BRA     Z,E2C
0E14:  BTSC    W3.4
0E16:  BRA     E2C
0E18:  BCLR.B  42.1
0E1A:  BCLR.B  42.0
0E1C:  RLC     W0,W0
0E1E:  RLC     W1,W1
0E20:  RLC     W2,W2
0E22:  RLC     W3,W3
0E24:  DEC     W9,W9
0E26:  BTSC.B  42.1
0E28:  BRA     E8E
0E2A:  BRA     E14
0E2C:  BTSC    W13.0
0E2E:  MOV     W10,W11
0E30:  BTSC    W13.1
0E32:  MOV     W12,W11
0E34:  BTSS    W13.5
0E36:  BRA     E74
0E38:  BCLR.B  42.0
0E3A:  RRC.B   W3L,W3L
0E3C:  RRC     W2,W2
0E3E:  RRC     W1,W1
0E40:  RRC     W0,W0
0E42:  BTSC.B  42.0
0E44:  BSET    W13.5
0E46:  INC     W9,W9
0E48:  BTSC.B  42.1
0E4A:  BRA     E8E
0E4C:  BTSS    W13.5
0E4E:  BRA     E6C
0E50:  INC     W0,W0
0E52:  BRA     NZ,E6C
0E54:  INC     W1,W1
0E56:  BRA     NZ,E6C
0E58:  INC     W2,W2
0E5A:  BRA     NZ,E6C
0E5C:  INC     W3,W3
0E5E:  BRA     NZ,E6C
0E60:  RRC.B   W3L,W3L
0E62:  RRC     W2,W2
0E64:  RRC     W1,W1
0E66:  RRC     W0,W0
0E68:  INC     W9,W9
0E6A:  BRA     Z,E8E
0E6C:  BTSC    W13.0
0E6E:  MOV     W10,W11
0E70:  BTSC    W13.1
0E72:  MOV     W12,W11
0E74:  IOR      W0,  W1,W4
0E76:  BRA     NZ,E7C
0E78:  IOR      W2,  W3,W4
0E7A:  BRA     Z,EC8
0E7C:  BCLR    W3.4
0E7E:  BCLR.B  42.1
0E80:  BCLR.B  42.0
0E82:  SL      W9,#4,W9
0E84:  XOR     W9,W3,W3
0E86:  BSET    W3.F
0E88:  BTSS    W11.F
0E8A:  BCLR    W3.F
0E8C:  BRA     EC8
0E8E:  MUL.UU  W0,#0,W0
0E90:  MUL.UU  W2,#0,W2
0E92:  BRA     EC8
0E94:  MOV     #8000,W8
0E96:  BTSC    W10.F
0E98:  XOR     W8,W7,W7
0E9A:  MOV     W5,W1
0E9C:  MOV     W4,W0
0E9E:  MOV     W6,W2
0EA0:  MOV     W7,W3
0EA2:  BRA     EC8
0EA4:  BRA     EC8
0EA6:  AND     #F,W7
0EA8:  BSET    W7.4
0EAA:  AND     #F,W3
0EAC:  BSET    W3.4
0EAE:  BTSC    W11.F
0EB0:  BCLR    W7.4
0EB2:  BSET    W13.2
0EB4:  BRA     DA8
0EB6:  AND     #F,W3
0EB8:  BSET    W3.4
0EBA:  AND     #F,W7
0EBC:  BSET    W7.4
0EBE:  SUB     W8,W9,W8
0EC0:  ADD     W8,W9,W9
0EC2:  BCLR    W13.1
0EC4:  BSET    W13.0
0EC6:  BRA     D5A
0EC8:  MOV     #1A,W8
0ECA:  REPEAT  #4
0ECC:  MOV     [--W15],[W8--]
0ECE:  MOV     [--W15],W8
0ED0:  RETURN  
0ED2:  MOV     W8,[W15++]
0ED4:  MOV     W9,[W15++]
0ED6:  MOV     W10,[W15++]
0ED8:  XOR     W3,W7,W9
0EDA:  BTSS    W9.F
0EDC:  BRA     EEA
0EDE:  BCLR.B  42.0
0EE0:  BCLR.B  42.1
0EE2:  BTSS    W3.F
0EE4:  BRA     F4E
0EE6:  BSET.B  42.0
0EE8:  BRA     F4E
0EEA:  MOV     #7FF,W10
0EEC:  MOV     W3,W8
0EEE:  MOV     W7,W9
0EF0:  ASR     W8,#4,W8
0EF2:  AND     W10,W8,W8
0EF4:  ASR     W9,#4,W9
0EF6:  AND     W10,W9,W9
0EF8:  SUB     W9,W8,W10
0EFA:  BRA     Z,F06
0EFC:  BTSS    W3.F
0EFE:  BRA     F4E
0F00:  MOV     #1,W0
0F02:  XOR.B   42
0F04:  BRA     F4E
0F06:  MOV     W3,W8
0F08:  MOV     W7,W9
0F0A:  AND     #1F,W3
0F0C:  AND     #1F,W7
0F0E:  BCLR    W3.4
0F10:  BCLR    W7.4
0F12:  SUB.B   W7L,W3L,W10L
0F14:  BRA     Z,F20
0F16:  BTSS    W8.F
0F18:  BRA     F4E
0F1A:  MOV     #1,W0
0F1C:  XOR.B   42
0F1E:  BRA     F4E
0F20:  SUB     W6,W2,W10
0F22:  BRA     Z,F2E
0F24:  BTSS    W8.F
0F26:  BRA     F4E
0F28:  MOV     #1,W0
0F2A:  XOR.B   42
0F2C:  BRA     F4E
0F2E:  SUB     W5,W1,W10
0F30:  BRA     Z,F3C
0F32:  BTSS    W8.F
0F34:  BRA     F4E
0F36:  MOV     #1,W0
0F38:  XOR.B   42
0F3A:  BRA     F4E
0F3C:  SUB     W4,W0,W10
0F3E:  BRA     Z,F4A
0F40:  BTSS    W8.F
0F42:  BRA     F4E
0F44:  MOV     #1,W0
0F46:  XOR.B   42
0F48:  BRA     F4E
0F4A:  BCLR.B  42.0
0F4C:  BRA     F4E
0F4E:  MOV     [--W15],W10
0F50:  MOV     [--W15],W9
0F52:  MOV     [--W15],W8
0F54:  RETURN  
0F56:  MOV     W5,[W15++]
0F58:  MOV     #C,W5
0F5A:  REPEAT  #5
0F5C:  MOV     [W5++],[W15++]
0F5E:  MOV     W3,W8
0F60:  MOV     W2,W7
0F62:  MOV     W1,W6
0F64:  MOV     W0,W5
0F66:  MOV     W3,W9
0F68:  MOV     #473,W11
0F6A:  ASR     W3,#4,W3
0F6C:  MOV     #7FF,W10
0F6E:  AND     W10,W3,W3
0F70:  SUB     W11,W3,W11
0F72:  AND     #1F,W8
0F74:  BSET    W8.4
0F76:  CLR     W0
0F78:  CLR     W1
0F7A:  CLR     W2
0F7C:  CLR     W3
0F7E:  BCLR.B  42.0
0F80:  RRC     W8,W8
0F82:  RRC     W7,W7
0F84:  RRC     W6,W6
0F86:  RRC     W5,W5
0F88:  RRC     W3,W3
0F8A:  RRC     W2,W2
0F8C:  RRC     W1,W1
0F8E:  RRC     W0,W0
0F90:  DEC     W11,W11
0F92:  BRA     NZ,F7E
0F94:  BTSS    W9.F
0F96:  BRA     FAA
0F98:  COM     W0,W0
0F9A:  COM     W1,W1
0F9C:  COM     W2,W2
0F9E:  COM     W3,W3
0FA0:  INC     W0,W0
0FA2:  ADDC    #0,W1
0FA4:  ADDC    #0,W2
0FA6:  ADDC    #0,W3
0FA8:  BRA     FAA
0FAA:  MOV     #16,W5
0FAC:  REPEAT  #5
0FAE:  MOV     [--W15],[W5--]
0FB0:  MOV     [--W15],W5
0FB2:  RETURN  
*
1298:  MOV     W5,[W15++]
129A:  MOV     #C,W5
129C:  REPEAT  #5
129E:  MOV     [W5++],[W15++]
12A0:  MOV     W3,W8
12A2:  MOV     W2,W7
12A4:  MOV     W1,W6
12A6:  MOV     W0,W5
12A8:  MOV     W3,W9
12AA:  MOV     #473,W11
12AC:  ASR     W3,#4,W3
12AE:  MOV     #7FF,W10
12B0:  AND     W10,W3,W3
12B2:  SUB     W11,W3,W11
12B4:  AND     #1F,W8
12B6:  BSET    W8.4
12B8:  CLR     W0
12BA:  CLR     W1
12BC:  CLR     W2
12BE:  CLR     W3
12C0:  BCLR.B  42.0
12C2:  RRC     W8,W8
12C4:  RRC     W7,W7
12C6:  RRC     W6,W6
12C8:  RRC     W5,W5
12CA:  RRC     W3,W3
12CC:  RRC     W2,W2
12CE:  RRC     W1,W1
12D0:  RRC     W0,W0
12D2:  DEC     W11,W11
12D4:  BRA     NZ,12C0
12D6:  BTSS    W9.F
12D8:  BRA     12EC
12DA:  COM     W0,W0
12DC:  COM     W1,W1
12DE:  COM     W2,W2
12E0:  COM     W3,W3
12E2:  INC     W0,W0
12E4:  ADDC    #0,W1
12E6:  ADDC    #0,W2
12E8:  ADDC    #0,W3
12EA:  BRA     12EC
12EC:  MOV     #16,W5
12EE:  REPEAT  #5
12F0:  MOV     [--W15],[W5--]
12F2:  MOV     [--W15],W5
12F4:  RETURN  
*
13CC:  MOV     W5,[W15++]
13CE:  MOV     #C,W5
13D0:  REPEAT  #3
13D2:  MOV     [W5++],[W15++]
13D4:  BTSS    W0.F
13D6:  BRA     13F6
13D8:  NEG     W0,W0
13DA:  BSET    W4.8
13DC:  BTSS    W4.F
13DE:  BRA     13F6
13E0:  MOV     W0,[W15++]
13E2:  MOV     #2D,W0
13E4:  MOV     W4,[W15++]
13E6:  MOV     W0,[W15++]
13E8:  MOV     [--W15],W0
13EA:  CALL    9FC
13EE:  MOV     [--W15],W4
13F0:  MOV     [--W15],W0
13F2:  BCLR    W4.8
13F4:  DEC.B   0008
13F6:  CLR     W5
13F8:  MOV     W0,W7
13FA:  MOV     W4,W9
13FC:  BCLR    W4.F
13FE:  CP0.B   W4L
1400:  BRA     NZ,140E
1402:  BTSC    W9.F
1404:  BRA     140A
1406:  MOV     #0,W5
1408:  BRA     1438
140A:  MOV     #0,W5
140C:  BRA     1438
140E:  BTSS    W9.8
1410:  SUB.B   W4L,#6,W5L
1412:  BTSC    W9.8
1414:  SUB.B   W4L,#7,W5L
1416:  BRA     NC,1436
1418:  MOV     #30,W0
141A:  BTSS    W9.F
141C:  MOV     #20,W0
141E:  MOV     W0,[W15++]
1420:  MOV     W4,[W15++]
1422:  MOV     W0,[W15++]
1424:  MOV     [--W15],W0
1426:  CALL    9FC
142A:  MOV     [--W15],W4
142C:  MOV     [--W15],W0
142E:  DEC     W5,W5
1430:  BRA     NN,141E
1432:  MOV     #5,W5
1434:  BRA     1438
1436:  MOV     W4,W5
1438:  MOV     #6,W4
143A:  BTSC    W5.8
143C:  INC     W4,W4
143E:  BSET    W5.E
1440:  BTSC    W9.F
1442:  BSET    W5.F
1444:  MOV     #2710,W8
1446:  REPEAT  #11
1448:  DIV.U   W7,W8
144A:  CALL    149E
144E:  MOV     W1,W7
1450:  MOV     #3E8,W8
1452:  REPEAT  #11
1454:  DIV.U   W7,W8
1456:  CALL    149E
145A:  MOV     W1,W7
145C:  MOV     #64,W8
145E:  REPEAT  #11
1460:  DIV.U   W7,W8
1462:  CALL    149E
1466:  MOV     W1,W7
1468:  MOV     #A,W8
146A:  REPEAT  #11
146C:  DIV.U   W7,W8
146E:  CALL    149E
1472:  BTSS    W9.8
1474:  BRA     148A
1476:  MOV     #2D,W0
1478:  MOV     W1,[W15++]
147A:  MOV     W4,[W15++]
147C:  MOV     W0,[W15++]
147E:  MOV     [--W15],W0
1480:  CALL    9FC
1484:  MOV     [--W15],W4
1486:  MOV     [--W15],W1
1488:  BCLR    W9.8
148A:  MOV     #30,W0
148C:  ADD.B   W1L,W0L,W0L
148E:  MOV     W0,2A
1490:  MOV     W4,[W15++]
1492:  MOV     W0,[W15++]
1494:  MOV     [--W15],W0
1496:  CALL    9FC
149A:  MOV     [--W15],W4
149C:  BRA     14F2
149E:  MOV     #30,W6
14A0:  CP0     W0
14A2:  BRA     NZ,14C0
14A4:  BTSS    W5.E
14A6:  BRA     14DE
14A8:  DEC     W4,W4
14AA:  CP.B    W4L,W5L
14AC:  BRA     Z,14B2
14AE:  BTSC.B  42.0
14B0:  RETURN  
14B2:  CP0     W0
14B4:  BRA     NZ,14C0
14B6:  BTSS    W5.E
14B8:  BRA     14DE
14BA:  BTSS    W5.F
14BC:  MOV     #20,W6
14BE:  BRA     14DE
14C0:  BCLR    W5.E
14C2:  BTSS    W9.8
14C4:  BRA     14DE
14C6:  MOV     W0,W10
14C8:  MOV     #2D,W0
14CA:  MOV     W1,[W15++]
14CC:  MOV     W4,[W15++]
14CE:  MOV     W0,[W15++]
14D0:  MOV     [--W15],W0
14D2:  CALL    9FC
14D6:  MOV     [--W15],W4
14D8:  MOV     [--W15],W1
14DA:  BCLR    W9.8
14DC:  MOV     W10,W0
14DE:  ADD.B   W6L,W0L,W0L
14E0:  MOV     W1,[W15++]
14E2:  MOV     W4,[W15++]
14E4:  MOV     W0,[W15++]
14E6:  MOV     [--W15],W0
14E8:  CALL    9FC
14EC:  MOV     [--W15],W4
14EE:  MOV     [--W15],W1
14F0:  RETURN  
14F2:  MOV     #12,W5
14F4:  REPEAT  #3
14F6:  MOV     [--W15],[W5--]
14F8:  MOV     [--W15],W5
14FA:  RETURN  
.................... 
.................... #list
.................... 
.................... #include <Inc/lookup_tables.h>
.................... // lookup table for 16bit timer
.................... //!const int timer_table[] = {
.................... //!1036,1036,1036,1036,1036,1036,1036,1036,1036,1036,
.................... //!1036,1036,1036,1036,1036,1036,1036,1036,1036,1036,
.................... //!1036,1021,1006,992,978,964,950,936,923,910,897,884,
.................... //!871,859,847,835,823,811,799,788,777,766,755,744,733,
.................... //!723,713,703,693,683,673,663,654,645,636,627,618,609,
.................... //!600,591,583,575,567,559,551,543,535,527,519,512,505,
.................... //!498,491,484,477,470,463,456,449,443,437,431,425,419,
.................... //!413,407,401,395,389,383,378,373,368,363,358,353,348,
.................... //!343,338,333,328,323,318,313,309,305,301,297,293,289,
.................... //!285,281,277,273,269,265,261,257,253,249,245, 241,238,
.................... //!235,232,229,226,223,220,217,214,211,208,205,202,199,
.................... //!196,193,190,187,184,181,178,175,172,170,168,166,164,
.................... //!162,160,158,156,154,152,150,148,146,144,142,140,138,
.................... //!136,134,132,130,128,126,124,122,120,118,116,114,112,
.................... //!110,108,106,104,102,101,100,99,98,97,96,95,94,93,92,
.................... //!91,90,89,88,87,86,85,84,83,82,81,80,79,78,77,76,75,
.................... //!74,73,72,71,70,69,68,67,66,65,64,63,62,61,60,59,58,
.................... //!57,56,55,54,53,52,51,50,49,48,47,46,45,44,43,42,41,
.................... //!40,39,38,37,36,35,34,33,33,33,33,33,33,33,33};
.................... 
.................... //!const int freq_table[] = {
.................... //!8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,17,17,18,18,19,19,20,
.................... //!20,21,21,22,22,23,23,24,24,25,25,26,27,27,28,28,29,29,30,30,31,31,32,32,33,34,34,35,35,36,36,37,
.................... //!37,38,39,39,40,40,41,41,42,42,43,44,44,45,45,46,46,47,48,48,49,49,50,50,51,52,52,53,53,54,55,55,
.................... //!56,56,57,58,58,59,60,60,61,61,62,63,63,64,65,65,66,67,67,68,69,69,70,71,71,72,73,73,74,75,75,76,
.................... //!77,78,78,79,80,81,81,82,83,84,84,85,86,87,87,88,89,90,91,92,92,93,94,95,96,97,98,98,99,100,101,102,
.................... //!103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,121,122,123,124,125,126,128,129,
.................... //!130,131,133,134,135,137,138,140,141,142,144,145,147,148,150,151,153,155,156,158,160,161,163,165,166,
.................... //!168,170,172,174,176,178,180,182,184,186,188,190,193,195,197,199,202,204,207,209,212,214,217,220,222,
.................... //!225,228,231,234,237,240,243,246,250
.................... //!};
.................... 
.................... //!
.................... //!const int ascend_speed_table[] = {
.................... //!23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,26,26,30,30,33,33,36,36,39,39,
.................... //!42,42,45,45,48,51,51,54,54,57,57,60,60,63,63,66,66,69,69,73,73,76,76,79,82,82,85,85,88,88,91,91,94,
.................... //!94,97,97,100,103,103,106,106,109,109,112,112,116,119,119,122,122,125,125,128,128,131,134,134,137,137,
.................... //!140,140,143,146,146,149,149,152,152,155,159,159,162,162,165,168,168,171,171,174,177,177,180,183,183,
.................... //!186,186,189,192,192,195,198,198,202,205,205,208,211,211,214,217,217,220,223,223,226,229,229,232,235,
.................... //!238,238,241,245,248,248,251,254,257,257,260,263,266,266,269,272,275,278,281,281,284,288,291,294,297,
.................... //!300,300,303,306,309,312,315,318,321,324,327,331,334,337,340,343,346,349,352,355,358,361,364,370,374,
.................... //!377,380,383,386,392,395,398,401,407,410,413,420,423,429,432,435,441,444,450,453,459,463,469,475,478,
.................... //!484,490,493,499,506,509,515,521,527,533,539,545,552,558,564,570,576,582,592,598,604,610,619,625,635,
.................... //!641,650,656,665,674,681,690,699,708,717,727,736,745,754,767
.................... //!};
.................... //!
.................... //!
.................... const int ascend_speed_table[] = 
.................... {
.................... 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,23,26,26,29,29,32,32,34,34,37,37,40,40,43,43,46,49,49,51,
.................... 51,54,54,57,57,60,60,63,63,66,66,68,68,71,71,74,77,77,80,80,83,83,86,86,88,88,91,91,95,97,97,100,100,
.................... 103,103,105,105,108,112,112,114,114,117,117,120,120,122,126,126,129,129,131,131,134,137,137,140,140,
.................... 143,143,146,149,149,151,151,154,157,157,160,160,163,166,166,168,171,171,174,174,177,180,180,183,185,
.................... 185,188,191,191,194,197,197,200,203,203,205,208,208,212,214,214,217,220,222,222,226,229,231,231,234,
.................... 237,239,239,243,246,248,248,251,254,257,260,263,263,266,268,271,274,277,280,280,283,285,288,291,294,
.................... 297,300,302,305,308,311,314,317,320,322,325,329,331,334,337,339,346,348,351,354,356,360,365,368,371,
.................... 374,380,383,385,391,394,400,402,405,411,414,419,422,428,431,437,442,446,451,456,460,465,471,473,480,
.................... 485,491,497,502,508,514,519,525,531,536,542,551,556,563,568,577,582,590,597,605,611,619,628,634,642,
.................... 651,659,668,677,685,694,702,714
.................... };
.................... 
.................... //!const int ascend_speed_table[] = 
.................... //!{
.................... //!0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,23,26,27,29,30,32,33,34,35,37,38,40,41,43,44,46,49,50,51,
.................... //!52,54,55,57,58,60,61,63,64,66,67,68,69,71,72,74,77,79,80,81,83,84,86,87,88,89,91,93,95,97,98,100,101,
.................... //!103,104,105,106,108,112,113,114,116,117,118,120,121,122,126,127,129,130,131,132,134,137,138,140,141,
.................... //!143,144,146,149,150,151,152,154,157,158,160,161,163,166,167,168,171,172,174,175,177,180,181,183,185,
.................... //!186,188,191,193,194,197,198,200,203,204,205,208,210,212,214,215,217,220,222,225,226,229,231,233,234,
.................... //!237,239,241,243,246,248,249,251,254,257,260,263,265,266,268,271,274,277,280,282,283,285,288,291,294,
.................... //!297,300,302,305,308,311,314,317,320,322,325,329,331,334,337,339,346,348,351,354,356,360,365,368,371,
.................... //!374,380,383,385,391,394,400,402,405,411,414,419,422,428,431,437,442,446,451,456,460,465,471,473,480,
.................... //!485,491,497,502,508,514,519,525,531,536,542,551,556,563,568,577,582,590,597,605,611,619,628,634,642,
.................... //!651,659,668,677,685,694,702,714
.................... //!};
.................... //!
.................... const int descend_speed_table[] = 
.................... {
.................... 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28,32,32,35,35,39,39,42,42,45,45,48,48,53,53,56,59,59,63,63,
.................... 66,66,69,69,74,74,77,77,80,80,84,84,87,87,90,95,95,98,98,101,101,105,105,108,108,111,111,116,119,119,
.................... 122,122,125,125,129,129,132,136,136,140,140,143,143,146,146,150,154,154,157,157,161,161,164,167,167,
.................... 171,171,175,175,178,182,182,185,185,188,191,191,196,196,199,202,202,206,209,209,212,212,217,220,220,
.................... 223,227,227,230,233,233,238,241,241,244,248,248,251,254,254,259,262,262,265,268,272,272,276,279,283,
.................... 283,286,289,293,293,297,300,304,304,307,310,314,318,321,321,325,328,331,334,339,342,342,345,349,352,
.................... 355,360,363,366,370,373,376,381,384,387,391,394,397,402,405,408,411,415,422,426,429,432,436,440,447,
.................... 450,453,457,464,468,471,477,482,488,492,495,503,506,513,516,524,527,534,540,545,551,558,562,569,575,
.................... 579,586,593,600,607,614,620,628,635,641,649,656,662,673,680,688,694,705,712,722,729,739,747,757,768,
.................... 774,784,795,805,816,827,837,848,858,872
.................... };
.................... 
.................... const int timer_table[] = {
.................... 65068,65068,65068,65068,65068,65068,65068,65068,65068,65068,65068,65068,65068,65068,65068,65068,
.................... 65068,65068,65068,65068,65068,61218,57795,54733,51977,49484,47217,45148,43251,41505,39894,38402,
.................... 37016,35726,34522,33395,32339,31346,30412,29531,28699,27912,27165,26458,25785,25145,24535,23954,
.................... 23399,22868,22360,21874,21408,20961,20531,20118,19721,19339,18971,18616,18273,17943,17624,17315,
.................... 17017,16728,16448,16177,15915,15660,15413,15173,14940,14714,14494,14280,14072,13869,13672,13480,
.................... 13292,13110,12932,12758,12589,12423,12262,12104,11950,11799,11652,11508,11367,11229,11094,10962,
.................... 10832,10705,10581,10459,10340,10223,10108,9995,9884,9776,9669,9564,9461,9360,9261,9163,9067,8973,
.................... 8880,8789,8699,8611,8523,8438,8353,8270,8188,8108,8028,7950,7873,7796,7721,7647,7574,7502,7431,7361,
.................... 7291,7223,7155,7089,7023,6958,6893,6830,6767,6705,6643,6582,6522,6463,6404,6346,6289,6232,6175,6120,
.................... 6064,6010,5955,5902,5849,5796,5744,5692,5641,5590,5540,5490,5441,5392,5343,5295,5247,5200,5153,5106,
.................... 5059,5013,4968,4923,4878,4833,4789,4745,4701,4657,4614,4572,4529,4487,4445,4403,4362,4321,4280,4239,
.................... 4199,4159,4119,4079,4040,4000,3961,3923,3884,3846,3808,3770,3732,3695,3658,3621,3584,3547,3511,3475,
.................... 3439,3403,3368,3332,3297,3262,3227,3193,3158,3124,3090,3056,3023,2989,2956,2923,2890,2858,2825,2793,
.................... 2761,2729,2697,2666,2634,2603,2572,2542,2511,2481,2451,2421,2391,2361,2332,2303,2274,2245,2217,2188,
.................... 2160,2132};
.................... 
.................... //!const unsigned int16 gain_table[256] = {
.................... //!0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,85,85,85,86,
.................... //!86,86,86,86,86,87,87,87,87,87,88,88,88,88,88,89,89,
.................... //!89,89,90,90,90,90,91,91,91,91,92,92,92,92,93,93,93,
.................... //!94,94,94,95,95,95,95,96,96,96,97,97,97,98,98,98,99,
.................... //!99,100,100,101,101,101,102,102,102,103,103,104,104,
.................... //!105,105,106,106,106,107,107,108,108,109,110,110,111,
.................... //!111,112,112,113,113,114,114,115,116,116,117,117,118,
.................... //!119,120,120,121,122,122,123,124,125,125,126,127,127,
.................... //!128,129,130,130,131,132,133,134,135,136,137,138,139,
.................... //!140,141,142,143,144,145,146,147,148,149,150,151,152,
.................... //!153,154,155,156,157,158,159,161,162,163,164,166,167,
.................... //!169,170,172,173,175,177,178,180,182,184,186,188,191,
.................... //!193,194,195,196,198,199,200,201,203,204,206,207,209,
.................... //!210,212,213,215,216,218,220,222,223,225,227,229,231,
.................... //!233,235,237,240,242,244,247,249,252,254,257,260,263,
.................... //!266,269,272,275,279,282,286,289,293,297,301,306,310,
.................... //!315,320,325,330,335,341,347,353,360,367,374,381,389,
.................... //!397,406,415,425,436,436,436,436,436,436,436,436
.................... //!};
.................... const unsigned int16 gain_table[] = 
.................... {
.................... 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,85,85,85,86,86,86,86,86,87,87,87,87,87,
.................... 88,88,88,88,89,89,89,89,89,90,90,90,90,91,91,91,92,92,92,92,93,93,93,94,94,94,
.................... 95,95,95,96,96,96,96,97,97,98,98,98,99,99,99,100,100,101,101,102,102,102,103,
.................... 103,104,104,105,105,106,106,107,107,107,108,109,109,109,110,111,111,112,112,
.................... 113,114,114,115,115,116,116,117,118,118,119,120,120,121,122,123,123,124,125,
.................... 126,127,127,128,129,130,130,131,132,133,134,134,135,136,137,138,139,140,141,
.................... 142,143,145,146,147,148,149,150,151,152,153,154,155,156,157,158,160,161,162,
.................... 163,164,166,167,168,170,171,173,174,176,178,179,181,183,185,187,189,191,193,
.................... 195,198,200,201,203,204,205,207,208,209,211,212,214,216,217,219,220,222,224,
.................... 225,227,229,231,233,235,237,239,241,243,246,248,250,253,255,258,260,263,266,
.................... 269,272,275,278,281,285,288,292,296,300,303,308,312,316,321,326,331,336,341,
.................... 347,353,359,365,372,379,386,394,402,410,419,428,438,449,460,460,460,460,460,
.................... 460,460,460
.................... };
.................... 
.................... #DEVICE ADC=10
.................... #device ICSP=1
.................... #use delay(clock=64000000,crystal=8000000)
.................... #use rs232(UART1, baud=57600, RECEIVE_BUFFER=100 , stream=UART_PORT1)
.................... 
.................... #FUSES NOWDT                    //No Watch Dog Timer
.................... #FUSES CKSFSM                   //Clock Switching is enabled, fail Safe clock monitor is enabled
.................... #FUSES BORV42                   //Brownout reset at 4.5V
.................... #FUSES WRT                      //Program Memory Write Protected
.................... #FUSES PROTECT                  //Code protected from reads
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float32)(unsigned int16)y;
.................... 
....................  else if (y < 10000000.0)
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
....................       res = 32768.0*(float32)l;
....................       res += (float32)(unsigned int16)y;
....................    }
.................... 
....................  else
....................   res = y;
.................... 
....................  y = y - (float32)(unsigned int16)y;
.................... 
....................  if (s)
....................   res = -res;
.................... 
....................  if (y != 0)
....................  {
....................   if (s == 1 && n == 0)
....................    res -= 1.0;
.................... 
....................   if (s == 0 && n == 1)
....................    res += 1.0;
....................  }
....................  if (x == 0)
....................     res = 0;
.................... 
....................  return (res);
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl[0]*y2 + pl[1];
.................... 
....................       r = ql[0]*y2 + ql[1];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
....................          r = -(float32)-n;
....................       else
....................          r = (float32)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
*
0FB4:  MOV     W5,[W15++]
0FB6:  MOV     W6,[W15++]
0FB8:  MOV     W7,[W15++]
0FBA:  MOV     W8,[W15++]
0FBC:  CLR     A42
0FBE:  CLR     A44
0FC0:  CLR     A46
0FC2:  MOV     #3FF0,W4
0FC4:  MOV     W4,A48
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
0FC6:  MOV     #FF1F,W4
0FC8:  MOV     W4,A52
0FCA:  SETM    A54
0FCC:  SETM    A56
0FCE:  MOV     #BFDF,W4
0FD0:  MOV     W4,A58
0FD2:  MOV     #1C35,W4
0FD4:  MOV     W4,A5A
0FD6:  MOV     #5555,W4
0FD8:  MOV     W4,A5C
0FDA:  MOV     #5555,W4
0FDC:  MOV     W4,A5E
0FDE:  MOV     #3FA5,W4
0FE0:  MOV     W4,A60
0FE2:  MOV     #3F1C,W4
0FE4:  MOV     W4,A62
0FE6:  MOV     #16A7,W4
0FE8:  MOV     W4,A64
0FEA:  MOV     #C16C,W4
0FEC:  MOV     W4,A66
0FEE:  MOV     #BF56,W4
0FF0:  MOV     W4,A68
0FF2:  MOV     #F3E6,W4
0FF4:  MOV     W4,A6A
0FF6:  MOV     #D65,W4
0FF8:  MOV     W4,A6C
0FFA:  MOV     #1A0,W4
0FFC:  MOV     W4,A6E
0FFE:  MOV     #3EFA,W4
1000:  MOV     W4,A70
1002:  MOV     #A3E,W4
1004:  MOV     W4,A72
1006:  MOV     #3931,W4
1008:  MOV     W4,A74
100A:  MOV     #7E4C,W4
100C:  MOV     W4,A76
100E:  MOV     #BE92,W4
1010:  MOV     W4,A78
1012:  MOV     #DDFB,W4
1014:  MOV     W4,A7A
1016:  MOV     #2B77,W4
1018:  MOV     W4,A7C
101A:  MOV     #EDB1,W4
101C:  MOV     W4,A7E
101E:  MOV     #3E21,W4
1020:  MOV     W4,A80
1022:  MOV     #6FCC,W4
1024:  MOV     W4,A82
1026:  MOV     #8FF7,W4
1028:  MOV     W4,A84
102A:  MOV     #C610,W4
102C:  MOV     W4,A86
102E:  MOV     #BDA8,W4
1030:  MOV     W4,A88
1032:  MOV     #124C,W4
1034:  MOV     W4,A8A
1036:  MOV     #8E1C,W4
1038:  MOV     W4,A8C
103A:  MOV     #3AF9,W4
103C:  MOV     W4,A8E
103E:  MOV     #3CF3,W4
1040:  MOV     W4,A90
1042:  MOV     #7676,W4
1044:  MOV     W4,A92
1046:  MOV     #350F,W4
1048:  MOV     W4,A94
104A:  MOV     #C0DE,W4
104C:  MOV     W4,A96
104E:  MOV     #3CF0,W4
1050:  MOV     W4,A98
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
1052:  MOV     A28,W0
1054:  MOV     A2A,W1
1056:  MOV     A2C,W2
1058:  MOV     A2E,W3
105A:  MOV     #0,W4
105C:  MOV     #0,W5
105E:  MOV     #0,W6
1060:  MOV     #0,W7
1062:  CALL    ED2
1066:  BRA     NC,1072
1068:  MOV     #A28,W0
106A:  MOV     #A28,W1
106C:  REPEAT  #7
106E:  MOV     [W0++],[W1++]
1070:  BTG.B   A2F.7
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
1072:  MOV     A28,W0
1074:  MOV     A2A,W1
1076:  MOV     A2C,W2
1078:  MOV     A2E,W3
107A:  MOV     #C884,W4
107C:  MOV     #6DC9,W5
107E:  MOV     #5F30,W6
1080:  MOV     #3FE4,W7
1082:  CALL    ACC
1086:  CALL    F56
108A:  MOV.B   W0L,A30
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
108C:  MOV     A28,W0
108E:  MOV     A2A,W1
1090:  MOV     A2C,W2
1092:  MOV     A2E,W3
1094:  MOV     #C884,W4
1096:  MOV     #6DC9,W5
1098:  MOV     #5F30,W6
109A:  MOV     #3FE4,W7
109C:  CALL    ACC
10A0:  MOV     W0,W5
10A2:  MOV     W1,W6
10A4:  MOV     W2,W7
10A6:  MOV     W3,W8
10A8:  MOV     #0,W1
10AA:  MOV     #0,W2
10AC:  MOV     #0,W3
10AE:  MOV.B   A30,W0L
10B0:  CLR.B   1
10B2:  CALL    A62
10B6:  BSET.B  43.0
10B8:  MOV     W5,[W15++]
10BA:  MOV     W6,[W15++]
10BC:  MOV     W7,[W15++]
10BE:  MOV     W0,W4
10C0:  MOV     W5,W0
10C2:  MOV     W1,W5
10C4:  MOV     W6,W1
10C6:  MOV     W2,W6
10C8:  MOV     W7,W2
10CA:  MOV     W3,W7
10CC:  MOV     W8,W3
10CE:  CALL    CE4
10D2:  MOV     [--W15],W7
10D4:  MOV     [--W15],W6
10D6:  MOV     [--W15],W5
10D8:  MOV     W0,A4A
10DA:  MOV     W1,A4C
10DC:  MOV     W2,A4E
10DE:  MOV     W3,A50
....................    quad = quad % 4;                    // quadrant (0 to 3)
10E0:  MOV.B   A30,W0L
10E2:  AND.B   W0L,#3,W0L
10E4:  MOV.B   W0L,A30
.................... 
....................    if (quad == 0 || quad == 2)
10E6:  CP0.B   A30
10E8:  BRA     Z,10F0
10EA:  MOV     A30,W4
10EC:  CP.B    W4L,#2
10EE:  BRA     NZ,110E
....................       t = frac * PI_DIV_BY_TWO;
10F0:  MOV     A4A,W0
10F2:  MOV     A4C,W1
10F4:  MOV     A4E,W2
10F6:  MOV     A50,W3
10F8:  MOV     #2D18,W4
10FA:  MOV     #5444,W5
10FC:  MOV     #21FB,W6
10FE:  MOV     #3FF9,W7
1100:  CALL    ACC
1104:  MOV     W0,A3A
1106:  MOV     W1,A3C
1108:  MOV     W2,A3E
110A:  MOV     W3,A40
110C:  BRA     11A2
....................    else if (quad == 1)
110E:  MOV     A30,W4
1110:  CP.B    W4L,#1
1112:  BRA     NZ,115C
....................       t = (1-frac) * PI_DIV_BY_TWO;
1114:  BSET.B  43.0
1116:  MOV     #0,W0
1118:  MOV     #0,W1
111A:  MOV     #0,W2
111C:  MOV     #3FF0,W3
111E:  MOV     A4A,W4
1120:  MOV     A4C,W5
1122:  MOV     A4E,W6
1124:  MOV     A50,W7
1126:  CALL    CE4
112A:  MOV     W0,W5
112C:  MOV     W1,W6
112E:  MOV     W2,W7
1130:  MOV     W3,W8
1132:  MOV     W5,[W15++]
1134:  MOV     W6,[W15++]
1136:  MOV     W7,[W15++]
1138:  MOV     W5,W0
113A:  MOV     W6,W1
113C:  MOV     W7,W2
113E:  MOV     W8,W3
1140:  MOV     #2D18,W4
1142:  MOV     #5444,W5
1144:  MOV     #21FB,W6
1146:  MOV     #3FF9,W7
1148:  CALL    ACC
114C:  MOV     [--W15],W7
114E:  MOV     [--W15],W6
1150:  MOV     [--W15],W5
1152:  MOV     W0,A3A
1154:  MOV     W1,A3C
1156:  MOV     W2,A3E
1158:  MOV     W3,A40
115A:  BRA     11A2
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
115C:  BSET.B  43.0
115E:  MOV     A4A,W0
1160:  MOV     A4C,W1
1162:  MOV     A4E,W2
1164:  MOV     A50,W3
1166:  MOV     #0,W4
1168:  MOV     #0,W5
116A:  MOV     #0,W6
116C:  MOV     #3FF0,W7
116E:  CALL    CE4
1172:  MOV     W0,W5
1174:  MOV     W1,W6
1176:  MOV     W2,W7
1178:  MOV     W3,W8
117A:  MOV     W5,[W15++]
117C:  MOV     W6,[W15++]
117E:  MOV     W7,[W15++]
1180:  MOV     W5,W0
1182:  MOV     W6,W1
1184:  MOV     W7,W2
1186:  MOV     W8,W3
1188:  MOV     #2D18,W4
118A:  MOV     #5444,W5
118C:  MOV     #21FB,W6
118E:  MOV     #3FF9,W7
1190:  CALL    ACC
1194:  MOV     [--W15],W7
1196:  MOV     [--W15],W6
1198:  MOV     [--W15],W5
119A:  MOV     W0,A3A
119C:  MOV     W1,A3C
119E:  MOV     W2,A3E
11A0:  MOV     W3,A40
.................... 
....................    y = 1.0;
11A2:  CLR     A32
11A4:  CLR     A34
11A6:  CLR     A36
11A8:  MOV     #3FF0,W4
11AA:  MOV     W4,A38
....................    t = t * t;
11AC:  MOV     A3A,W0
11AE:  MOV     A3C,W1
11B0:  MOV     A3E,W2
11B2:  MOV     A40,W3
11B4:  MOV     A3A,W4
11B6:  MOV     A3C,W5
11B8:  MOV     A3E,W6
11BA:  MOV     A40,W7
11BC:  CALL    ACC
11C0:  MOV     W0,A3A
11C2:  MOV     W1,A3C
11C4:  MOV     W2,A3E
11C6:  MOV     W3,A40
....................    for (i = 0; i <= 8; i++)
11C8:  CLR.B   A31
11CA:  MOV     A30,W4
11CC:  LSR     W4,#8,W4
11CE:  CP.B    W4L,#8
11D0:  BRA     GTU,1234
....................    {
....................       t2 = t2 * t;
11D2:  MOV     A42,W0
11D4:  MOV     A44,W1
11D6:  MOV     A46,W2
11D8:  MOV     A48,W3
11DA:  MOV     A3A,W4
11DC:  MOV     A3C,W5
11DE:  MOV     A3E,W6
11E0:  MOV     A40,W7
11E2:  CALL    ACC
11E6:  MOV     W0,A42
11E8:  MOV     W1,A44
11EA:  MOV     W2,A46
11EC:  MOV     W3,A48
....................       y = y + p_64[i] * t2;
11EE:  MOV.B   A31,W0L
11F0:  CLR.B   1
11F2:  SL      W0,#3,W0
11F4:  MOV     #A52,W4
11F6:  ADD     W0,W4,W0
11F8:  MOV     W0,W5
11FA:  MOV     W5,[W15++]
11FC:  MOV     [W5],W0
11FE:  MOV     [++W5],W1
1200:  MOV     [++W5],W2
1202:  MOV     [++W5],W3
1204:  MOV     A42,W4
1206:  MOV     A44,W5
1208:  MOV     A46,W6
120A:  MOV     A48,W7
120C:  CALL    ACC
1210:  MOV     [--W15],W5
1212:  BCLR.B  43.0
1214:  MOV     W0,W4
1216:  MOV     W1,W5
1218:  MOV     W2,W6
121A:  MOV     W3,W7
121C:  MOV     A32,W0
121E:  MOV     A34,W1
1220:  MOV     A36,W2
1222:  MOV     A38,W3
1224:  CALL    CE4
1228:  MOV     W0,A32
122A:  MOV     W1,A34
122C:  MOV     W2,A36
122E:  MOV     W3,A38
1230:  INC.B   0A31
1232:  BRA     11CA
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
1234:  MOV     A30,W4
1236:  CP.B    W4L,#2
1238:  BRA     Z,1240
123A:  MOV     A30,W4
123C:  CP.B    W4L,#1
123E:  BRA     NZ,124A
....................       y = -y;  // correct sign
1240:  MOV     #A32,W0
1242:  MOV     #A32,W1
1244:  REPEAT  #7
1246:  MOV     [W0++],[W1++]
1248:  BTG.B   A39.7
.................... 
....................    return (y);
124A:  MOV     A32,W0
124C:  MOV     A34,W1
124E:  MOV     A36,W2
1250:  MOV     A38,W3
1252:  MOV     [--W15],W8
1254:  MOV     [--W15],W7
1256:  MOV     [--W15],W6
1258:  MOV     [--W15],W5
125A:  RETURN  
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
125C:  MOV     W5,[W15++]
125E:  MOV     W6,[W15++]
1260:  MOV     W7,[W15++]
1262:  MOV     W8,[W15++]
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
1264:  BSET.B  43.0
1266:  MOV     A18,W0
1268:  MOV     A1A,W1
126A:  MOV     A1C,W2
126C:  MOV     A1E,W3
126E:  MOV     #2D18,W4
1270:  MOV     #5444,W5
1272:  MOV     #21FB,W6
1274:  MOV     #3FF9,W7
1276:  CALL    CE4
127A:  MOV     W0,W5
127C:  MOV     W1,W6
127E:  MOV     W2,W7
1280:  MOV     W3,W8
1282:  MOV     W5,A28
1284:  MOV     W6,A2A
1286:  MOV     W7,A2C
1288:  MOV     W8,A2E
128A:  CALL    FB4
128E:  MOV     [--W15],W8
1290:  MOV     [--W15],W7
1292:  MOV     [--W15],W6
1294:  MOV     [--W15],W5
1296:  RETURN  
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... #include <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];
....................             c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
....................        result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #ifndef __PCB__
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
....................    goto StrtoulGO;
.................... 
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(; sd!=0; )
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtoulGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
....................    }
....................    if (endptr)
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... #endif
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #define clock_freq 64000000
.................... 
.................... #define P1TCON    0x01C0
.................... #define P1TMR     0x01C2 
.................... #define P1TPER    0x01C4
.................... #define P1SECMP   0x01C6
.................... #define PWM1CON1  0x01C8 
.................... #define PWM1CON2  0x01CA
.................... #define P1DTCON1  0x01CC
.................... #define P1DTCON2  0x01CE  
.................... #define P1FLTACON 0x01D0
.................... #define P1OVDCON  0x01D4     
.................... #define P1DC1     0x01D6   
.................... #define P1DC2     0x01D8
.................... #define P1DC3     0x01DA
.................... #define IPC14     0x00C0  
.................... #define CLKDIV    0x0744 
.................... #define PLLFBD    0x0746
.................... 
.................... 
.................... /*------------QUADRATURE ENCODER REGISTERS-------------------*/
.................... #define QEICON  0x0122       // Control Status Register.
.................... #define DFLTCON 0x0124      // Digital Filter Control Register.
.................... #define POSCNT  0x0126     // Position Count Register.
.................... #define MAXCNT  0x0128    // Maximum Count Register.
.................... #define ADPCFG  0x02A8   // Encoder Multiplexed pins.
.................... #define IEC2    0x0090  // for enabling the QE interrupt.
.................... #define IPC10   0x00A8 // QEI interrupt priority Register.
.................... 
.................... #define UPDN 3       // Direction testing flag.
.................... /*------------QUADRATURE ENCODER REGISTERS-------------------*/
.................... 
.................... #define TIM_OVERFLOW_VAL 65535
.................... #define U1TXREG   0x0210
.................... #define U1BRG     0x0214
.................... 
.................... #define ADC_pin sAN1
.................... #define LED_PIN PIN_C13
.................... 
.................... #define voltage_offset 1000//1248
.................... #define low_duty_limit 50
.................... #define high_duty_limit 1950
.................... #define SLOPE 0
.................... 
.................... #define break_level 5
.................... #define sustain_level 200  
.................... #define break_amplitude 0 
.................... 
.................... #define pedestal_amplitude 500
.................... #define peak_amplitude 950
.................... 
.................... 
.................... #define throttle_PIN PIN_B1
.................... #define PWM_tick_pin PIN_B2
.................... #define TIM_tick_pin PIN_B3
.................... #define ENC_TICK_PIN PIN_B0
.................... 
.................... #define init_freq 30
.................... 
....................  
....................   
.................... void initMCPWM(void);
.................... void fill_sine_table(void);  
.................... int1 QEI_get_direction(void); 
.................... 
.................... unsigned int16 duty[3]={voltage_offset,voltage_offset,voltage_offset},sample=0;
.................... signed int16 peak_voltage =0;//  1184; 
.................... signed int32 reference[3] = {0,0,0};
.................... 
.................... const unsigned max_samples=30.0;
.................... signed int16 sine_table[max_samples];
.................... unsigned int16 sine_index,phase_angle[3] = {0 , 0 , 0};  
.................... double theeta;
.................... 
.................... const unsigned max_freq = 250; //Hz
.................... 
.................... unsigned int16 raw_adc =0 ;
.................... signed int16 throttle_level = 0;
.................... unsigned int16 freq = 1;
.................... 
.................... int32 position_count = 0;
.................... int32 prev_count = 0;
.................... int32 enc_count = 0;
.................... int32 position_count_new = 0;
.................... int1 direction_flag = 0;
.................... unsigned int16 position_capture = 0;
.................... 
.................... int1 tick = 0;
.................... int1 enc_tick = 0;
.................... int1 uart_tick = 0;
.................... int8 tick_count = 0;
.................... unsigned long millis_count = 0;
.................... unsigned long uart_millis = 0;
.................... 
.................... char Serial_OutputBuffer[100];
.................... 
.................... unsigned int16 ascending_speed , descending_speed , attained_speed ,attained_throttle, loaded_speed , prev_speed;  
.................... 
.................... int1 descend_flag = 0;
.................... int1 ascend_flag = 0;
.................... 
.................... static int1 enc_mutx = 0;
.................... #int_PWM1
.................... void  PWM1_isr(void) 
*
0742:  PUSH    42
0744:  PUSH    36
0746:  PUSH    32
0748:  MOV     W0,[W15++]
074A:  MOV     #2,W0
074C:  REPEAT  #C
074E:  MOV     [W0++],[W15++]
.................... {
.................... 
....................    tick_count++;
0750:  INC.B   0997
....................    if(tick_count >= 8)
0752:  MOV     996,W4
0754:  LSR     W4,#8,W4
0756:  CP.B    W4L,#8
0758:  BRA     LT,76A
....................    {     
....................       millis_count++;
075A:  INC     099A
075C:  BTSC.B  42.1
075E:  INC     099C
....................       uart_millis++;
0760:  INC     099E
0762:  BTSC.B  42.1
0764:  INC     09A0
....................       tick = 1;
0766:  BSET.B  996.1
....................       
....................       tick_count=0;
0768:  CLR.B   997
....................    
....................    }
....................    if (uart_millis >= 10) 
076A:  MOV     9A0,W4
076C:  CP      W4,#0
076E:  BRA     NC,77C
0770:  BRA     GTU,778
0772:  MOV     99E,W4
0774:  CP      W4,#A
0776:  BRA     NC,77C
....................    {
.................... //!      uart_tick = 1;
....................       uart_millis = 0;
0778:  CLR     99E
077A:  CLR     9A0
....................       
....................    
....................    }
....................    if (millis_count >= 100) {
077C:  MOV     99C,W4
077E:  CP      W4,#0
0780:  BRA     NC,792
0782:  BRA     GTU,78C
0784:  MOV     99A,W4
0786:  MOV     #64,W3
0788:  CP      W3,W4
078A:  BRA     GTU,792
....................       enc_tick = 1;
078C:  BSET.B  996.2
....................       
....................       millis_count = 0;
078E:  CLR     99A
0790:  CLR     99C
....................       
....................    }  
....................   
.................... 
.................... }
.................... 
0792:  BCLR.B  88.7
0794:  MOV     #1A,W0
0796:  REPEAT  #C
0798:  MOV     [--W15],[W0--]
079A:  MOV     [--W15],W0
079C:  POP     32
079E:  POP     36
07A0:  POP     42
07A2:  RETFIE  
.................... #INT_TIMER3
.................... void  timer3_isr(void) 
*
07E6:  PUSH    42
07E8:  PUSH    36
07EA:  PUSH    32
07EC:  MOV     W0,[W15++]
07EE:  MOV     #2,W0
07F0:  REPEAT  #C
07F2:  MOV     [W0++],[W15++]
.................... {
....................  
....................    sample = (sample+1)%max_samples;
07F4:  MOV     924,W4
07F6:  ADD     W4,#1,W5
07F8:  MOV     #1E,W4
07FA:  REPEAT  #11
07FC:  DIV.U   W5,W4
07FE:  MOV     W1,924
....................    phase_angle[0] = sample;
0800:  PUSH    924
0802:  POP     972
....................    phase_angle[1] = (sample+10)%max_samples;
0804:  MOV     924,W4
0806:  ADD     W4,#A,W5
0808:  MOV     #1E,W4
080A:  REPEAT  #11
080C:  DIV.U   W5,W4
080E:  MOV     W1,974
....................    phase_angle[2] = (sample+20)%max_samples; 
0810:  MOV     924,W4
0812:  ADD     W4,#14,W5
0814:  MOV     #1E,W4
0816:  REPEAT  #11
0818:  DIV.U   W5,W4
081A:  MOV     W1,976
.................... 
....................    for (int i = 0 ; i < 3 ; i++) {
081C:  CLR     ADA
081E:  MOV     ADA,W4
0820:  CP      W4,#3
0822:  BRA     GE,9BA
....................       
....................       reference[i] = sine_table[phase_angle[i]];
0824:  MOV     ADA,W4
0826:  MUL.UU  W4,#4,W0
0828:  MOV     #928,W4
082A:  ADD     W0,W4,W5
082C:  MOV     ADA,W4
082E:  MUL.UU  W4,#2,W0
0830:  MOV     #972,W4
0832:  ADD     W0,W4,W0
0834:  MOV     [W0],W6
0836:  SL      W6,#1,W0
0838:  MOV     #934,W4
083A:  ADD     W0,W4,W0
083C:  MOV     W0,W4
083E:  MOV     [W4],W0
0840:  CLR     W1
0842:  BTSC    W0.F
0844:  SETM    W1
0846:  MOV     #0,W4
0848:  MOV     [W4++],[W5++]
084A:  MOV     [W4++],[W5++]
....................       reference[i] = reference[i] * peak_voltage; 
084C:  MOV     ADA,W4
084E:  MUL.UU  W4,#4,W0
0850:  MOV     #928,W4
0852:  ADD     W0,W4,W5
0854:  MOV     ADA,W4
0856:  MUL.UU  W4,#4,W0
0858:  MOV     #928,W4
085A:  ADD     W0,W4,W0
085C:  MOV     #C,W4
085E:  MOV     [W0++],[W4++]
0860:  MOV     [W0++],[W4++]
0862:  MOV     926,W0
0864:  CLR     W1
0866:  BTSC    W0.F
0868:  SETM    W1
086A:  MOV     W0,W2
086C:  MOV     W1,W3
086E:  MOV     W6,W0
0870:  MOV     W7,W1
0872:  CALL    7A4
0876:  MOV     #0,W4
0878:  MOV     [W4++],[W5++]
087A:  MOV     [W4++],[W5++]
....................       if( reference[i] > 0)
087C:  MOV     ADA,W4
087E:  MUL.UU  W4,#4,W0
0880:  MOV     #928,W4
0882:  ADD     W0,W4,W0
0884:  MOV     #A,W4
0886:  MOV     [W0++],[W4++]
0888:  MOV     [W0++],[W4++]
088A:  CP      W6,#0
088C:  BRA     LT,8BA
088E:  BRA     GT,894
0890:  CP      W5,#0
0892:  BRA     LEU,8BA
....................       {
....................          reference[i] = reference[i] >> 8; 
0894:  MOV     ADA,W4
0896:  MUL.UU  W4,#4,W0
0898:  MOV     #928,W4
089A:  ADD     W0,W4,W5
089C:  MOV     ADA,W4
089E:  MUL.UU  W4,#4,W0
08A0:  MOV     #928,W4
08A2:  ADD     W0,W4,W0
08A4:  MOV     #C,W4
08A6:  MOV     [W0++],[W4++]
08A8:  MOV     [W0++],[W4++]
08AA:  MOV.B   D,W0L
08AC:  MOV.B   W0L,[W5]
08AE:  MOV.B   W7L,[W5+#1]
08B0:  MOV.B   F,W0L
08B2:  MOV.B   W0L,[W5+#2]
08B4:  MOV.B   #0,W0L
08B6:  MOV.B   W0L,[W5+#3]
....................       }
08B8:  BRA     936
....................       else if( reference[i] < 0)
08BA:  MOV     ADA,W4
08BC:  MUL.UU  W4,#4,W0
08BE:  MOV     #928,W4
08C0:  ADD     W0,W4,W0
08C2:  MOV     #A,W4
08C4:  MOV     [W0++],[W4++]
08C6:  MOV     [W0++],[W4++]
08C8:  CP      W6,#0
08CA:  BRA     GT,936
08CC:  BRA     LT,8D2
08CE:  CP      W5,#0
08D0:  BRA     C,936
....................       {
....................          reference[i] = 0 - reference[i];
08D2:  MOV     ADA,W4
08D4:  MUL.UU  W4,#4,W0
08D6:  MOV     #928,W4
08D8:  ADD     W0,W4,W5
08DA:  MOV     ADA,W4
08DC:  MUL.UU  W4,#4,W0
08DE:  MOV     #928,W4
08E0:  ADD     W0,W4,W0
08E2:  MOV     W0,W4
08E4:  MOV     #0,W3
08E6:  MOV     [W4++],[W3++]
08E8:  MOV     [W4++],[W3++]
08EA:  MOV     #0,W4
08EC:  SUB     W4,W0,[W5]
08EE:  MOV     #0,W4
08F0:  SUBB    W4,W1,[++W5]
....................          reference[i] = reference[i] >> 8;
08F2:  MOV     ADA,W4
08F4:  MUL.UU  W4,#4,W0
08F6:  MOV     #928,W4
08F8:  ADD     W0,W4,W5
08FA:  MOV     ADA,W4
08FC:  MUL.UU  W4,#4,W0
08FE:  MOV     #928,W4
0900:  ADD     W0,W4,W0
0902:  MOV     #C,W4
0904:  MOV     [W0++],[W4++]
0906:  MOV     [W0++],[W4++]
0908:  MOV.B   D,W0L
090A:  MOV.B   W0L,[W5]
090C:  MOV.B   W7L,[W5+#1]
090E:  MOV.B   F,W0L
0910:  MOV.B   W0L,[W5+#2]
0912:  MOV.B   #0,W0L
0914:  MOV.B   W0L,[W5+#3]
....................          reference[i] = 0 - reference[i];
0916:  MOV     ADA,W4
0918:  MUL.UU  W4,#4,W0
091A:  MOV     #928,W4
091C:  ADD     W0,W4,W5
091E:  MOV     ADA,W4
0920:  MUL.UU  W4,#4,W0
0922:  MOV     #928,W4
0924:  ADD     W0,W4,W0
0926:  MOV     W0,W4
0928:  MOV     #0,W3
092A:  MOV     [W4++],[W3++]
092C:  MOV     [W4++],[W3++]
092E:  MOV     #0,W4
0930:  SUB     W4,W0,[W5]
0932:  MOV     #0,W4
0934:  SUBB    W4,W1,[++W5]
....................       }
....................       
....................       reference[i] = reference[i] + voltage_offset;
0936:  MOV     ADA,W4
0938:  MUL.UU  W4,#4,W0
093A:  MOV     #928,W4
093C:  ADD     W0,W4,W5
093E:  MOV     ADA,W4
0940:  MUL.UU  W4,#4,W0
0942:  MOV     #928,W4
0944:  ADD     W0,W4,W0
0946:  MOV     #C,W4
0948:  MOV     [W0++],[W4++]
094A:  MOV     [W0++],[W4++]
094C:  MOV     #3E8,W4
094E:  ADD     W6,W4,[W5]
0950:  ADDC    W7,#0,[++W5]
....................       if(reference[i] > high_duty_limit )
0952:  MOV     ADA,W4
0954:  MUL.UU  W4,#4,W0
0956:  MOV     #928,W4
0958:  ADD     W0,W4,W0
095A:  MOV     #A,W4
095C:  MOV     [W0++],[W4++]
095E:  MOV     [W0++],[W4++]
0960:  CP      W6,#0
0962:  BRA     LT,984
0964:  BRA     GT,96C
0966:  MOV     #79E,W4
0968:  CP      W4,W5
096A:  BRA     C,984
....................       { 
....................          reference[i] = high_duty_limit;
096C:  MOV     ADA,W4
096E:  MUL.UU  W4,#4,W0
0970:  MOV     #928,W4
0972:  ADD     W0,W4,W5
0974:  MOV.B   #9E,W0L
0976:  MOV.B   W0L,[W5]
0978:  MOV.B   #7,W0L
097A:  MOV.B   W0L,[W5+#1]
097C:  MOV.B   #0,W0L
097E:  MOV.B   W0L,[W5+#2]
0980:  MOV.B   #0,W0L
0982:  MOV.B   W0L,[W5+#3]
....................       }
....................       if(reference[i] < low_duty_limit)
0984:  MOV     ADA,W4
0986:  MUL.UU  W4,#4,W0
0988:  MOV     #928,W4
098A:  ADD     W0,W4,W0
098C:  MOV     #A,W4
098E:  MOV     [W0++],[W4++]
0990:  MOV     [W0++],[W4++]
0992:  CP      W6,#0
0994:  BRA     GT,9B6
0996:  BRA     LT,99E
0998:  MOV     #32,W4
099A:  CP      W4,W5
099C:  BRA     LEU,9B6
....................       { 
....................          reference[i] = low_duty_limit;
099E:  MOV     ADA,W4
09A0:  MUL.UU  W4,#4,W0
09A2:  MOV     #928,W4
09A4:  ADD     W0,W4,W5
09A6:  MOV.B   #32,W0L
09A8:  MOV.B   W0L,[W5]
09AA:  MOV.B   #0,W0L
09AC:  MOV.B   W0L,[W5+#1]
09AE:  MOV.B   #0,W0L
09B0:  MOV.B   W0L,[W5+#2]
09B2:  MOV.B   #0,W0L
09B4:  MOV.B   W0L,[W5+#3]
....................       }
09B6:  INC     0ADA
09B8:  BRA     81E
....................    }
....................       
....................    *P1DC1 = reference[0];  *(P1DC1+1) = reference[0]>>8;
09BA:  MOV.B   928,W0L
09BC:  MOV.B   W0L,1D6
09BE:  MOV.B   929,W0L
09C0:  MOV.B   W0L,1D7
....................    *P1DC2 = reference[1];  *(P1DC2+1) = reference[1]>>8;
09C2:  MOV.B   92C,W0L
09C4:  MOV.B   W0L,1D8
09C6:  MOV.B   92D,W0L
09C8:  MOV.B   W0L,1D9
....................    *P1DC3 = reference[2];  *(P1DC3+1) = reference[2]>>8;
09CA:  MOV.B   930,W0L
09CC:  MOV.B   W0L,1DA
09CE:  MOV.B   931,W0L
09D0:  MOV.B   W0L,1DB
.................... 
....................    setup_timer2(TMR_INTERNAL | TMR_DIV_BY_1 | TMR_32_BIT , timer_table[freq]);
09D2:  MOV     984,W0
09D4:  SL      W0,#1,W0
09D6:  CALL    3F0
09DA:  MOV     W0,W5
09DC:  CLR     110
09DE:  MOV     W5,10C
09E0:  MOV     W6,10E
09E2:  MOV     #8008,W4
09E4:  MOV     W4,110
....................    output_bit(TIM_tick_pin , 0);
09E6:  BCLR.B  2CA.3
09E8:  BCLR.B  2C6.3
....................    
09EA:  BCLR.B  84.7
09EC:  MOV     #1A,W0
09EE:  REPEAT  #C
09F0:  MOV     [--W15],[W0--]
09F2:  MOV     [--W15],W0
09F4:  POP     32
09F6:  POP     36
09F8:  POP     42
09FA:  RETFIE  
.................... }
.................... 
....................    
.................... void main()
*
14FC:  MOV     #F80,W15
14FE:  MOV     #FFF,W0
1500:  MOV     W0,20
1502:  NOP     
1504:  MOV     #4444,W0
1506:  MOV     W0,96
1508:  MOV     #4444,W0
150A:  MOV     W0,A6
150C:  BSET.B  81.7
150E:  MOV     #8000,W4
1510:  MOV     W4,20C
1512:  MOV     #400,W4
1514:  MOV     W4,20E
1516:  MOV     #10,W4
1518:  MOV     W4,214
151A:  CLR     864
151C:  CLR     866
151E:  CLR     864
1520:  CLR     866
1522:  BSET.B  8D.1
1524:  CLR     924
1526:  CLR     926
1528:  CLR     980
152A:  CLR     982
152C:  MOV     #1,W4
152E:  MOV     W4,984
1530:  CLR     986
1532:  CLR     988
1534:  CLR     98A
1536:  CLR     98C
1538:  CLR     98E
153A:  CLR     990
153C:  CLR     992
153E:  CLR     994
1540:  BCLR.B  996.0
1542:  CLR     998
1544:  BCLR.B  996.1
1546:  BCLR.B  996.2
1548:  BCLR.B  996.3
154A:  CLR.B   997
154C:  CLR     99A
154E:  CLR     99C
1550:  CLR     99E
1552:  CLR     9A0
1554:  BCLR.B  996.4
1556:  BCLR.B  996.5
1558:  CLR     A12
155A:  SETM    2A8
155C:  BCLR.B  996.6
155E:  BRA     1602
1560:  DATA    C0,06,08
1562:  DATA    68,00,00
1564:  DATA    4B,F0,3F
1566:  DATA    5C,0A,58
1568:  DATA    F6,3B,8F
156A:  DATA    00,C0,3C
156C:  DATA    8B,28,AC
156E:  DATA    3C,BE,F6
1570:  DATA    3F,D2,D5
1572:  DATA    44,16,8C
1574:  DATA    15,D7,BF
1576:  DATA    69,00,5A
1578:  DATA    2E,1B,87
157A:  DATA    99,3F,9A
157C:  DATA    5F,AD,4B
157E:  DATA    91,E4,01
1580:  DATA    C0,5D,11
1582:  DATA    2F,92,E4
1584:  DATA    81,FB,3F
1586:  DATA    38,DA,91
1588:  DATA    80,9D,C5
158A:  DATA    E0,BF,6F
158C:  DATA    12,C0,B4
158E:  DATA    C3,09,AB
1590:  DATA    3F,6B,C1
1592:  DATA    03,4E,C1
1594:  DATA    B5,45,BF
1596:  DATA    F7,40,05
1598:  DATA    FF,00,5C
159A:  DATA    EF,3F,F3
159C:  DATA    A3,E2,F7
159E:  DATA    D7,FF,01
15A0:  DATA    40,C0,B4
15A2:  DATA    FF,05,3C
15A4:  DATA    58,FC,3F
15A6:  DATA    3B,D3,C0
15A8:  DATA    B5,BA,8C
15AA:  DATA    E2,3F,39
15AC:  DATA    D3,C7,3D
15AE:  DATA    41,79,B2
15B0:  DATA    3F,87,0D
15B2:  DATA    3C,50,D0
15B4:  DATA    AF,62,3F
15B6:  DATA    30,4B,8D
15B8:  DATA    A2,82,AA
15BA:  DATA    04,40,09
15BC:  DATA    A0,40,4A
15BE:  DATA    05,76,03
15C0:  DATA    40,EC,9E
15C2:  DATA    37,88,A6
15C4:  DATA    44,F0,3F
15C6:  DATA    8F,12,8D
15C8:  DATA    29,9A,5B
15CA:  DATA    C7,3F,0E
15CC:  DATA    E0,80,7C
15CE:  DATA    A1,D8,86
15D0:  DATA    3F,29,4B
15D2:  DATA    FB,95,C2
15D4:  DATA    37,1A,3F
15D6:  DATA    00,00,80
15D8:  DATA    06,09,1E
15DA:  DATA    E8,03,E8
15DC:  DATA    03,E8,03
15DE:  DATA    C0,0C,09
15E0:  DATA    28,00,C0
15E2:  DATA    06,09,72
15E4:  DATA    00,00,00
15E6:  INC     W2,W2
15E8:  CP      W2,#1
15EA:  BRA     NZ,15F4
15EC:  TBLRDL  [W1],W3
15EE:  TBLRDH  [W1++],W4
15F0:  MOV.B   6,W0L
15F2:  RETURN  
15F4:  CP      W2,#2
15F6:  BRA     NZ,15FC
15F8:  MOV.B   7,W0L
15FA:  RETURN  
15FC:  MOV.B   8,W0L
15FE:  CLR     W2
1600:  RETURN  
1602:  MOV     #0,W6
1604:  MOV     #0,W0
1606:  MOV     W0,32
1608:  MOV     #1560,W0
160A:  MOV     W0,W1
160C:  CLR     W2
160E:  CALL    15E6
1612:  MOV.B   W0L,B
1614:  CALL    15E6
1618:  MOV.B   W0L,A
161A:  CP0     W5
161C:  BRA     Z,1650
161E:  BTSS    W5.F
1620:  BRA     1630
1622:  CALL    15E6
1626:  MOV.B   W0L,D
1628:  CALL    15E6
162C:  MOV.B   W0L,C
162E:  BCLR    W5.F
1630:  BTSS    W5.E
1632:  BRA     1644
1634:  BCLR    W5.E
1636:  DEC     W5,W5
1638:  CALL    15E6
163C:  MOV.B   W0L,W7L
163E:  REPEAT  W5
1640:  MOV.B   W7L,[W6++]
1642:  BRA     160E
1644:  CALL    15E6
1648:  MOV.B   W0L,[W6++]
164A:  DEC     W5,W5
164C:  BRA     NZ,1644
164E:  BRA     160E
.................... { 
....................    prev_speed = 0;
1650:  CLR     A10
....................    sprintf(Serial_OutputBuffer, "\nMotor Control Unit v0.1\r\n");
1652:  MOV     #9A2,W4
1654:  MOV     W4,A12
1656:  MOV     #0,W1
1658:  MOV     W1,W0
165A:  CLR.B   1
165C:  CALL    6E0
1660:  INC     W1,W1
1662:  MOV     W1,[W15++]
1664:  MOV     W0,[W15++]
1666:  MOV     [--W15],W0
1668:  CALL    9FC
166C:  MOV     [--W15],W1
166E:  MOV     #19,W0
1670:  CPSGT   W1,W0
1672:  BRA     1658
....................    printf(Serial_OutputBuffer);
1674:  MOV     #9A2,W1
1676:  CP0.B   [W1]
1678:  BRA     Z,1688
167A:  BTSC.B  20F.1
167C:  BRA     167A
167E:  MOV.B   [W1+#0],W0L
1680:  MOV.B   W0L,210
1682:  CLR.B   211
1684:  INC     W1,W1
1686:  BRA     1676
....................    
....................    *U1BRG = 8;    // setting uart baudrate to 115200.
1688:  MOV.B   #8,W0L
168A:  MOV.B   W0L,214
....................    
....................    attained_throttle = 20;
168C:  MOV     #14,W4
168E:  MOV     W4,A0C
....................    position_capture = 0;
1690:  CLR     998
....................    freq = 1;
1692:  MOV     #1,W4
1694:  MOV     W4,984
....................    
....................    initMCPWM();
1696:  CALL    A0A
....................    fill_sine_table();
169A:  CALL    12F6
.................... 
....................    output_drive(LED_PIN);
169E:  BCLR.B  2CD.5
.................... 
....................    setup_adc(ADC_CLOCK_DIV_32);
16A0:  MOV     #1F1F,W4
16A2:  MOV     W4,2A4
16A4:  MOV     #80E0,W4
16A6:  MOV     W4,2A0
....................    setup_adc_ports(ADC_pin);
16A8:  MOV     #FFFD,W4
16AA:  MOV     W4,2A8
16AC:  CLR     2A2
....................    set_adc_channel(1);
16AE:  MOV     #1,W4
16B0:  MOV     W4,2A6
....................    delay_us(10);
16B2:  REPEAT  #9E
16B4:  NOP     
....................    
....................    setup_qei( QEI_MODE_X2 , QEI_FILTER_DIV_1 ,0);
16B6:  MOV     #400,W4
16B8:  MOV     W4,122
16BA:  CLR     124
16BC:  CLR     128
16BE:  CLR     126
....................    setup_timer2(TMR_INTERNAL | TMR_DIV_BY_1 | TMR_32_BIT , timer_table[freq]);
16C0:  MOV     984,W0
16C2:  SL      W0,#1,W0
16C4:  CALL    3F0
16C8:  MOV     W0,W5
16CA:  CLR     110
16CC:  MOV     W5,10C
16CE:  MOV     W6,10E
16D0:  MOV     #8008,W4
16D2:  MOV     W4,110
....................    enable_interrupts(INT_TIMER3);   // enable interrupt in timer3 register (in case of 32bit mode) 
16D4:  BSET.B  8C.7
.................... 
....................    enable_interrupts(INT_PWM1);
16D6:  BSET.B  90.7
....................    enable_interrupts(INTR_GLOBAL);
16D8:  BCLR.B  81.7
16DA:  CLR     42
16DC:  BSET.B  81.7
....................    
.................... 
....................    while(TRUE)         
....................    {
....................       
....................       if (tick) {
16DE:  BTSS.B  996.1
16E0:  BRA     1794
....................          
....................          raw_adc = read_adc();
16E2:  BCLR.B  2A0.0
16E4:  BSET.B  2A0.1
16E6:  BTSS.B  2A0.0
16E8:  BRA     16E6
16EA:  PUSH    280
16EC:  POP     980
....................          
....................          output_bit(LED_PIN , 1);
16EE:  BSET.B  2D1.5
16F0:  BCLR.B  2CD.5
....................          if (raw_adc > 1023) 
16F2:  MOV     980,W4
16F4:  MOV     #3FF,W3
16F6:  CP      W3,W4
16F8:  BRA     C,16FE
....................          {
....................             raw_adc = 1023;
16FA:  MOV     #3FF,W4
16FC:  MOV     W4,980
....................          }
.................... 
....................          raw_adc = raw_adc -200;
16FE:  MOV     980,W4
1700:  SUB     #C8,W4
1702:  MOV     W4,980
....................          throttle_level = raw_adc;
1704:  PUSH    980
1706:  POP     982
....................         
....................          
....................          if (throttle_level > 255)
1708:  MOV     982,W4
170A:  MOV     #FF,W3
170C:  CP      W3,W4
170E:  BRA     GE,1714
....................          {
....................             throttle_level = 255;
1710:  MOV     #FF,W4
1712:  MOV     W4,982
....................          }
....................          if (throttle_level < 0)   
1714:  MOV     982,W4
1716:  CP      W4,#0
1718:  BRA     GE,171C
....................          {  
....................             throttle_level = 0; 
171A:  CLR     982
....................          }
.................... 
....................           ascending_speed  = ascend_speed_table[attained_throttle];
171C:  MOV     A0C,W0
171E:  SL      W0,#1,W0
1720:  CALL    100
1724:  MOV     W0,A06
....................           descending_speed = descend_speed_table[attained_throttle];  
1726:  MOV     A0C,W0
1728:  SL      W0,#1,W0
172A:  CALL    278
172E:  MOV     W0,A08
....................           loaded_speed = ascend_speed_table[attained_throttle -1];
1730:  MOV     A0C,W4
1732:  SUB     W4,#1,W5
1734:  SL      W5,#1,W0
1736:  CALL    100
173A:  MOV     W0,A0E
....................           
....................           if (!enc_mutx) 
173C:  BTSC.B  996.6
173E:  BRA     1744
....................           {
....................             attained_speed = position_count_new;      // READING ENCODER's SHARED VARIABLE. 
1740:  PUSH    992
1742:  POP     A0A
....................  
....................           }
....................           
....................           
....................           if(throttle_level > attained_throttle && attained_speed >= ascending_speed)
1744:  MOV     A0C,W0
1746:  MOV     982,W4
1748:  CP      W4,W0
174A:  BRA     LE,1758
174C:  MOV     A06,W0
174E:  MOV     A0A,W4
1750:  CP      W4,W0
1752:  BRA     NC,1758
....................           {
....................             attained_throttle++;
1754:  INC     0A0C
.................... 
....................           }
1756:  BRA     177C
.................... //!          else if (throttle_level > attained_throttle && attained_speed < prev_speed)   
.................... //!          {
.................... //!            
.................... //!            attained_throttle--;
.................... //!            if (attained_throttle < 20) 
.................... //!            {
.................... //!               attained_throttle = 20;
.................... //!               
.................... //!            }
.................... //!          
.................... //!          }
....................           else if(throttle_level < attained_throttle && attained_speed <= descending_speed)
1758:  MOV     982,W0
175A:  MOV     A0C,W4
175C:  CP      W4,W0
175E:  BRA     LE,1776
1760:  MOV     A0A,W0
1762:  MOV     A08,W4
1764:  CP      W4,W0
1766:  BRA     NC,1776
....................           {
....................             
....................             attained_throttle--; 
1768:  DEC     0A0C
....................             if (attained_throttle < 20)
176A:  MOV     A0C,W4
176C:  CP      W4,#14
176E:  BRA     C,1774
....................             {
....................                attained_throttle = 20;
1770:  MOV     #14,W4
1772:  MOV     W4,A0C
....................             }
....................              
....................           }
1774:  BRA     177C
....................           else if (throttle_level == attained_throttle)
1776:  MOV     982,W0
1778:  CP      A0C
177A:  BRA     NZ,177C
....................           {
....................           //
....................           }
....................           
....................          
....................          freq = attained_throttle;
177C:  PUSH    A0C
177E:  POP     984
....................          peak_voltage = gain_table[attained_throttle];
1780:  MOV     A0C,W0
1782:  SL      W0,#1,W0
1784:  CALL    568
1788:  MOV     W0,926
....................          
....................          prev_speed = attained_speed; 
178A:  PUSH    A0A
178C:  POP     A10
....................          
....................          tick = 0;  
178E:  BCLR.B  996.1
....................          output_bit(LED_PIN , 0);
1790:  BCLR.B  2D1.5
1792:  BCLR.B  2CD.5
....................         
....................       } 
....................       
....................       if (uart_tick) 
1794:  BTSS.B  996.3
1796:  BRA     179A
....................       {
....................          
....................          uart_tick = 0;
1798:  BCLR.B  996.3
....................       
....................       }
....................       if (enc_tick) 
179A:  BTSS.B  996.2
179C:  BRA     18BE
....................       {
....................          enc_mutx = 1;
179E:  BSET.B  996.6
....................          position_count = *(POSCNT +1);
17A0:  MOV.B   127,W0L
17A2:  MOV.B   W0L,986
17A4:  CLR.B   987
17A6:  CLR     988
....................          position_count = position_count << 8;
17A8:  MOV.B   988,W0L
17AA:  MOV.B   W0L,989
17AC:  MOV.B   987,W0L
17AE:  MOV.B   W0L,988
17B0:  MOV.B   986,W0L
17B2:  MOV.B   W0L,987
17B4:  CLR.B   986
....................          position_count = position_count | *POSCNT;   
17B6:  MOV.B   126,W0L
17B8:  CLR.B   1
17BA:  IOR     986
....................          
.................... 
....................          direction_flag = QEI_get_direction();
17BC:  CALL    13BE
17C0:  BCLR.B  996.0
17C2:  BTSC.B  0.0
17C4:  BSET.B  996.0
.................... 
....................          enc_count = position_count - prev_count;
17C6:  MOV     986,W4
17C8:  MOV     98A,W3
17CA:  SUB     W4,W3,W0
17CC:  MOV     W0,98E
17CE:  MOV     988,W4
17D0:  MOV     98C,W3
17D2:  SUBB    W4,W3,W0
17D4:  MOV     W0,990
....................      
....................          if (direction_flag == 1 && enc_count < 0) 
17D6:  BTSS.B  996.0
17D8:  BRA     17F6
17DA:  MOV     990,W4
17DC:  CP      W4,#0
17DE:  BRA     GT,17F6
17E0:  BRA     LT,17E8
17E2:  MOV     98E,W4
17E4:  CP      W4,#0
17E6:  BRA     C,17F6
....................          {
....................             enc_count = enc_count + TIM_OVERFLOW_VAL ;
17E8:  MOV     #FFFF,W4
17EA:  MOV     98E,W3
17EC:  ADD     W3,W4,W0
17EE:  MOV     W0,98E
17F0:  MOV     990,W4
17F2:  ADDC    W4,#0,W0
17F4:  MOV     W0,990
.................... 
....................          }
.................... 
....................          if (direction_flag == 0 && enc_count > 0)   
17F6:  BTSC.B  996.0
17F8:  BRA     1816
17FA:  MOV     990,W4
17FC:  CP      W4,#0
17FE:  BRA     LT,1816
1800:  BRA     GT,1808
1802:  MOV     98E,W4
1804:  CP      W4,#0
1806:  BRA     LEU,1816
....................          {
....................             enc_count = enc_count - TIM_OVERFLOW_VAL ;
1808:  MOV     98E,W4
180A:  MOV     #FFFF,W3
180C:  SUB     W4,W3,W0
180E:  MOV     W0,98E
1810:  MOV     990,W4
1812:  SUBB    W4,#0,W0
1814:  MOV     W0,990
....................          }
....................    
....................          enc_count = abs(enc_count);
1816:  MOV     98E,W0
1818:  MOV     990,W1
181A:  BTSS    W1.F
181C:  BRA     182A
181E:  MOV     #0,W4
1820:  MOV     98E,W3
1822:  SUB     W4,W3,W0
1824:  MOV     #0,W4
1826:  MOV     990,W3
1828:  SUBB    W4,W3,W1
182A:  MOV     W0,98E
182C:  MOV     W1,990
....................          enc_count = enc_count >> 1;
182E:  LSR     990
1830:  RRC     98E
....................          prev_count = position_count;           
1832:  PUSH    986
1834:  POP     98A
1836:  PUSH    988
1838:  POP     98C
....................          position_count_new = enc_count;
183A:  PUSH    98E
183C:  POP     992
183E:  PUSH    990
1840:  POP     994
....................          
....................          sprintf(Serial_OutputBuffer, "\r\n %d,%d,%d,%d,%d,%d" , throttle_level , attained_throttle,  attained_speed , ascending_speed , descending_speed , prev_speed);
1842:  MOV     #9A2,W4
1844:  MOV     W4,A12
1846:  MOV.B   #D,W0L
1848:  CALL    9FC
184C:  MOV.B   #A,W0L
184E:  CALL    9FC
1852:  MOV.B   #20,W0L
1854:  CALL    9FC
1858:  MOV     982,W0
185A:  MOV     #0,W4
185C:  CALL    13CC
1860:  MOV.B   #2C,W0L
1862:  CALL    9FC
1866:  MOV     A0C,W0
1868:  MOV     #0,W4
186A:  CALL    13CC
186E:  MOV.B   #2C,W0L
1870:  CALL    9FC
1874:  MOV     A0A,W0
1876:  MOV     #0,W4
1878:  CALL    13CC
187C:  MOV.B   #2C,W0L
187E:  CALL    9FC
1882:  MOV     A06,W0
1884:  MOV     #0,W4
1886:  CALL    13CC
188A:  MOV.B   #2C,W0L
188C:  CALL    9FC
1890:  MOV     A08,W0
1892:  MOV     #0,W4
1894:  CALL    13CC
1898:  MOV.B   #2C,W0L
189A:  CALL    9FC
189E:  MOV     A10,W0
18A0:  MOV     #0,W4
18A2:  CALL    13CC
....................          printf(Serial_OutputBuffer);
18A6:  MOV     #9A2,W1
18A8:  CP0.B   [W1]
18AA:  BRA     Z,18BA
18AC:  BTSC.B  20F.1
18AE:  BRA     18AC
18B0:  MOV.B   [W1+#0],W0L
18B2:  MOV.B   W0L,210
18B4:  CLR.B   211
18B6:  INC     W1,W1
18B8:  BRA     18A8
....................          
....................          enc_mutx = 0;
18BA:  BCLR.B  996.6
....................          enc_tick = 0;
18BC:  BCLR.B  996.2
.................... 
....................       }
18BE:  BRA     16DE
....................     } 
.................... }    
.................... 
18C0:  PWRSAV  #0
.................... 
.................... void initMCPWM(void) 
.................... {    
....................    *(P1TCON+1)  =  0x80;  *P1TCON =  0x02;
*
0A0A:  MOV.B   #80,W0L
0A0C:  MOV.B   W0L,1C1
0A0E:  MOV.B   #2,W0L
0A10:  MOV.B   W0L,1C0
....................    *(P1TPER+1)  =  0x03;  *P1TPER =  0xE7;  
0A12:  MOV.B   #3,W0L
0A14:  MOV.B   W0L,1C5
0A16:  MOV.B   #E7,W0L
0A18:  MOV.B   W0L,1C4
....................    *(P1SECMP+1) =  0x00;  *P1SECMP=  0x01; //
0A1A:  CLR.B   1C7
0A1C:  MOV.B   #1,W0L
0A1E:  MOV.B   W0L,1C6
....................    *(PWM1CON1+1)=  0x00;  *PWM1CON1= 0x77;  
0A20:  CLR.B   1C9
0A22:  MOV.B   #77,W0L
0A24:  MOV.B   W0L,1C8
....................    *(PWM1CON2+1)=  0x00;  *PWM1CON2= 0x02;
0A26:  CLR.B   1CB
0A28:  MOV.B   #2,W0L
0A2A:  MOV.B   W0L,1CA
....................    *(P1DTCON1+1)=  0x00;  *P1DTCON1= 0x10; //0x09
0A2C:  CLR.B   1CD
0A2E:  MOV.B   #10,W0L
0A30:  MOV.B   W0L,1CC
....................    *(P1DTCON2+1)=  0x00;  *P1DTCON2= 0x00;
0A32:  CLR.B   1CF
0A34:  CLR.B   1CE
....................    *(P1FLTACON+1)= 0x00;  *P1FLTACON=0x00; //0x0000
0A36:  CLR.B   1D1
0A38:  CLR.B   1D0
....................    *(P1OVDCON+1)=  0x3F;  *P1OVDCON= 0x0F;
0A3A:  MOV.B   #3F,W0L
0A3C:  MOV.B   W0L,1D5
0A3E:  MOV.B   #F,W0L
0A40:  MOV.B   W0L,1D4
....................    
....................    *(P1DC1+1) = duty[0]>>8;   *P1DC1 = duty[0]; 
0A42:  MOV.B   91F,W0L
0A44:  MOV.B   W0L,1D7
0A46:  MOV.B   91E,W0L
0A48:  MOV.B   W0L,1D6
....................    *(P1DC2+1) = duty[1]>>8;   *P1DC2 = duty[1];
0A4A:  MOV.B   921,W0L
0A4C:  MOV.B   W0L,1D9
0A4E:  MOV.B   920,W0L
0A50:  MOV.B   W0L,1D8
....................    *(P1DC3+1) = duty[2]>>8;   *P1DC3 = duty[2];  
0A52:  MOV.B   923,W0L
0A54:  MOV.B   W0L,1DB
0A56:  MOV.B   922,W0L
0A58:  MOV.B   W0L,1DA
....................    *(IPC14+1) =0x00;*(IPC14) =0x70;
0A5A:  CLR.B   C1
0A5C:  MOV.B   #70,W0L
0A5E:  MOV.B   W0L,C0
0A60:  RETURN  
.................... }
.................... 
.................... 
....................    
.................... void fill_sine_table(void)
*
12F6:  MOV     W5,[W15++]
12F8:  MOV     W6,[W15++]
12FA:  MOV     W7,[W15++]
12FC:  MOV     W8,[W15++]
.................... {
....................    for(sine_index=0;sine_index < max_samples;sine_index++)  
12FE:  CLR     970
1300:  MOV     970,W4
1302:  CP      W4,#1E
1304:  BRA     C,13B4
....................    {
....................       theeta=sine_index*2.0*PI/max_samples;
1306:  MOV     970,W0
1308:  MOV     #0,W1
130A:  MOV     #0,W2
130C:  MOV     #0,W3
130E:  CALL    A62
1312:  MOV     #0,W4
1314:  MOV     #0,W5
1316:  MOV     #0,W6
1318:  MOV     #4000,W7
131A:  CALL    ACC
131E:  MOV     W0,W5
1320:  MOV     W1,W6
1322:  MOV     W2,W7
1324:  MOV     W3,W8
1326:  MOV     W5,[W15++]
1328:  MOV     W6,[W15++]
132A:  MOV     W7,[W15++]
132C:  MOV     W5,W0
132E:  MOV     W6,W1
1330:  MOV     W7,W2
1332:  MOV     W8,W3
1334:  MOV     #2D18,W4
1336:  MOV     #5444,W5
1338:  MOV     #21FB,W6
133A:  MOV     #4009,W7
133C:  CALL    ACC
1340:  MOV     [--W15],W7
1342:  MOV     [--W15],W6
1344:  MOV     [--W15],W5
1346:  MOV     W0,W5
1348:  MOV     W1,W6
134A:  MOV     W2,W7
134C:  MOV     W3,W8
134E:  MOV     W5,[W15++]
1350:  MOV     W6,[W15++]
1352:  MOV     W7,[W15++]
1354:  MOV     W5,W0
1356:  MOV     W6,W1
1358:  MOV     W7,W2
135A:  MOV     W8,W3
135C:  MOV     #0,W4
135E:  MOV     #0,W5
1360:  MOV     #0,W6
1362:  MOV     #403E,W7
1364:  CALL    BDC
1368:  MOV     [--W15],W7
136A:  MOV     [--W15],W6
136C:  MOV     [--W15],W5
136E:  MOV     W0,978
1370:  MOV     W1,97A
1372:  MOV     W2,97C
1374:  MOV     W3,97E
....................       sine_table[sine_index]=255*sin(theeta);
1376:  MOV     970,W0
1378:  SL      W0,#1,W0
137A:  MOV     #934,W4
137C:  ADD     W0,W4,W5
137E:  PUSH    978
1380:  POP     A18
1382:  PUSH    97A
1384:  POP     A1A
1386:  PUSH    97C
1388:  POP     A1C
138A:  PUSH    97E
138C:  POP     A1E
138E:  CALL    125C
1392:  MOV     W5,[W15++]
1394:  MOV     W0,W4
1396:  MOV     W1,W5
1398:  MOV     W2,W6
139A:  MOV     W3,W7
139C:  MOV     #0,W0
139E:  MOV     #0,W1
13A0:  MOV     #E000,W2
13A2:  MOV     #406F,W3
13A4:  CALL    ACC
13A8:  MOV     [--W15],W5
13AA:  CALL    1298
13AE:  MOV     W0,[W5]
13B0:  INC     0970
13B2:  BRA     1300
....................    }
13B4:  MOV     [--W15],W8
13B6:  MOV     [--W15],W7
13B8:  MOV     [--W15],W6
13BA:  MOV     [--W15],W5
13BC:  RETURN  
.................... }
.................... 
.................... int1 QEI_get_direction(void) 
.................... {
....................    if (*(QEICON +1) & (1 << UPDN)) return 1;
13BE:  BTSS.B  123.3
13C0:  BRA     13C8
13C2:  MOV.B   #1,W0L
13C4:  MOV.B   W0L,0
13C6:  BRA     13CA
....................    
....................    return 0;
13C8:  CLR.B   0
13CA:  RETURN  
.................... 
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
....................   
....................    
.................... 
.................... 
.................... 
.................... //-----------------IMPLEMENATION REQUIRED--------------//
.................... 
.................... //==========RESPONSE ON BREAK INPUT===========
.................... // DRIVE PWM TO 0 ON BREAK INPUT...
.................... 
.................... 
.................... //=========INPUT FREQUENCY VS MOTOR SPEED DIFFERENCE CALCULATION====
.................... /*
....................    speed  = (freq_table[throttle_level] * 120) / poles
....................    enc_freq = (speed * 64) / 60
....................    
....................    slip = motor_enc_freq - enc_freq;
....................    
.................... */
.................... /*
.................... ==========FOLLOW UP MOTOR SPEED ALGORITHM===========
.................... - sending throttle value from serial.
.................... - is speed_table[throttle_level] == motor_enc
.................... - if yes go to next speed value.
.................... 
.................... if (current_speed != set_speed && current_speed == next_speed)
....................          {
....................             next_speed++;
....................             throttle_level++;
....................             prev_speed = current_speed;
....................          }
....................          
....................          if (current_speed <= prev_speed)
....................          {
....................             // speed is decreasing.
....................             prev_speed = current_speed;
....................             
....................          }
....................          
....................          
....................          //!             if (attained_speed < loaded_speed) 
.................... //!             {
.................... //!               position_capture = attained_speed;
.................... //!               descend_flag = 1;
.................... //!                attained_throttle--; 
.................... //!                if (attained_throttle < 20)
.................... //!                {
.................... //!                   attained_throttle = 20;
.................... //!                }
.................... //!             }
.................... //!             else {descend_flag = 0;}
.................... 
.................... */
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
....................   

Configuration Fuses:
   Word  1L: 0306   XT_PLL8 PR CKSFSM
          H: 0000  
   Word  2L: 003F   WPSB16 WPSA512 NOWDT
          H: 0000  
   Word  3L: 8793   PUT64 BORV42 BROWNOUT LPOL_HIGH HPOL_HIGH NOPWMPIN MCLR
          H: 0000  
   Word  4L: 310F  
          H: 0000  
   Word  5L: 330F  
          H: 0000  
   Word  6L: 0004   WRT PROTECT
          H: 0000  
   Word  7L: C003   ICSP1 NODEBUG
          H: 0000  
