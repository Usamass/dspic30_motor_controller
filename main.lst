CCS PCD C Compiler, Version 5.112, 5967               28-Jun-24 10:04

               Filename:   C:\Users\eelab\Documents\[2024-05-15] MOTOR_CONTROL\main.lst

               ROM used:   6350 bytes (19%)
                           Largest free fragment is 26418
               RAM used:   675 (33%) at main() level
                           882 (43%) worst case
               Stack used: 96 locations (46 in main + 50 for interrupts)
               Stack size: 128

*
0000:  GOTO    14FA
*
0022:  DATA    E8,07,00
*
0026:  DATA    08,07,00
*
0062:  DATA    42,07,00
.................... #include <30F4011.h>
.................... //////////// Standard Header file for the DSPIC30F4011 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
*
0732:  MOV     #1A,W0
0734:  REPEAT  #C
0736:  MOV     [--W15],[W0--]
0738:  MOV     [--W15],W0
073A:  POP     32
073C:  POP     36
073E:  POP     42
0740:  RETFIE  
.................... #device DSPIC30F4011
*
0100:  CLR     32
0102:  MOV     #156,W3
0104:  SUB     W0,W3,W3
0106:  BRA     C,110
0108:  MOV     #122,W3
010A:  ADD     W3,W0,W0
010C:  TBLRDL  [W0],W0
010E:  RETURN  
0110:  MOV     #122,W0
0112:  BCLR.B  6.0
0114:  ADD     W3,W3,W3
0116:  ADD     W3,W0,W3
0118:  TBLRDH  [W3++],W0
011A:  TBLRDH  [W3],W3
011C:  SL      W3,#8,W3
011E:  IOR      W3,  W0,W0
0120:  RETURN  
0122:  DATA    00,00,23
0124:  DATA    00,00,01
0126:  DATA    00,00,26
0128:  DATA    00,00,01
012A:  DATA    00,00,29
012C:  DATA    00,00,01
012E:  DATA    00,00,2C
0130:  DATA    00,00,01
0132:  DATA    00,00,2E
0134:  DATA    00,00,01
0136:  DATA    00,00,31
0138:  DATA    00,00,01
013A:  DATA    00,00,34
013C:  DATA    00,00,01
013E:  DATA    00,00,37
0140:  DATA    00,00,01
0142:  DATA    00,00,3A
0144:  DATA    00,00,01
0146:  DATA    00,00,3D
0148:  DATA    00,00,01
014A:  DATA    00,00,40
014C:  DATA    17,00,01
014E:  DATA    1A,00,42
0150:  DATA    1B,00,01
0152:  DATA    1D,00,45
0154:  DATA    1E,00,01
0156:  DATA    20,00,49
0158:  DATA    21,00,01
015A:  DATA    22,00,4B
015C:  DATA    23,00,01
015E:  DATA    25,00,4E
0160:  DATA    26,00,01
0162:  DATA    28,00,51
0164:  DATA    29,00,01
0166:  DATA    2B,00,53
0168:  DATA    2C,00,01
016A:  DATA    2E,00,5A
016C:  DATA    31,00,01
016E:  DATA    32,00,5C
0170:  DATA    33,00,01
0172:  DATA    34,00,5F
0174:  DATA    36,00,01
0176:  DATA    37,00,62
0178:  DATA    39,00,01
017A:  DATA    3A,00,64
017C:  DATA    3C,00,01
017E:  DATA    3D,00,68
0180:  DATA    3F,00,01
0182:  DATA    40,00,6D
0184:  DATA    42,00,01
0186:  DATA    43,00,70
0188:  DATA    44,00,01
018A:  DATA    45,00,73
018C:  DATA    47,00,01
018E:  DATA    48,00,76
0190:  DATA    4A,00,01
0192:  DATA    4D,00,7C
0194:  DATA    4F,00,01
0196:  DATA    50,00,7F
0198:  DATA    51,00,01
019A:  DATA    53,00,81
019C:  DATA    54,00,01
019E:  DATA    56,00,87
01A0:  DATA    57,00,01
01A2:  DATA    58,00,8A
01A4:  DATA    59,00,01
01A6:  DATA    5B,00,90
01A8:  DATA    5D,00,01
01AA:  DATA    5F,00,92
01AC:  DATA    61,00,01
01AE:  DATA    62,00,95
01B0:  DATA    64,00,01
01B2:  DATA    65,00,9B
01B4:  DATA    67,00,01
01B6:  DATA    68,00,9E
01B8:  DATA    69,00,01
01BA:  DATA    6A,00,A3
01BC:  DATA    6C,00,01
01BE:  DATA    70,00,A6
01C0:  DATA    71,00,01
01C2:  DATA    72,00,AC
01C4:  DATA    74,00,01
01C6:  DATA    75,00,AF
01C8:  DATA    76,00,01
01CA:  DATA    78,00,B5
01CC:  DATA    79,00,01
01CE:  DATA    7A,00,BA
01D0:  DATA    7E,00,01
01D2:  DATA    7F,00,BE
01D4:  DATA    81,00,01
01D6:  DATA    82,00,C3
01D8:  DATA    83,00,01
01DA:  DATA    84,00,C8
01DC:  DATA    86,00,01
01DE:  DATA    89,00,CC
01E0:  DATA    8A,00,01
01E2:  DATA    8C,00,D1
01E4:  DATA    8D,00,01
01E6:  DATA    8F,00,D7
01E8:  DATA    90,00,01
01EA:  DATA    92,00,D9
01EC:  DATA    95,00,01
01EE:  DATA    96,00,E0
01F0:  DATA    97,00,01
01F2:  DATA    98,00,E5
01F4:  DATA    9A,00,01
01F6:  DATA    9D,00,EB
01F8:  DATA    9E,00,01
01FA:  DATA    A0,00,F1
01FC:  DATA    A1,00,01
01FE:  DATA    A3,00,F6
0200:  DATA    A6,00,01
0202:  DATA    A7,00,FC
0204:  DATA    A8,00,01
0206:  DATA    AB,00,02
0208:  DATA    AC,00,02
020A:  DATA    AE,00,07
020C:  DATA    AF,00,02
020E:  DATA    B1,00,0D
0210:  DATA    B4,00,02
0212:  DATA    B5,00,13
0214:  DATA    B7,00,02
0216:  DATA    B9,00,18
0218:  DATA    BA,00,02
021A:  DATA    BC,00,1E
021C:  DATA    BF,00,02
021E:  DATA    C1,00,27
0220:  DATA    C2,00,02
0222:  DATA    C5,00,2C
0224:  DATA    C6,00,02
0226:  DATA    C8,00,33
0228:  DATA    CB,00,02
022A:  DATA    CC,00,38
022C:  DATA    CD,00,02
022E:  DATA    D0,00,41
0230:  DATA    D2,00,02
0232:  DATA    D4,00,46
0234:  DATA    D6,00,02
0236:  DATA    D7,00,4E
0238:  DATA    D9,00,02
023A:  DATA    DC,00,55
023C:  DATA    DE,00,02
023E:  DATA    E1,00,5D
0240:  DATA    E2,00,02
0242:  DATA    E5,00,63
0244:  DATA    E7,00,02
0246:  DATA    E9,00,6B
0248:  DATA    EA,00,02
024A:  DATA    ED,00,74
024C:  DATA    EF,00,02
024E:  DATA    F1,00,7A
0250:  DATA    F3,00,02
0252:  DATA    F6,00,82
0254:  DATA    F8,00,02
0256:  DATA    F9,00,8B
0258:  DATA    FB,00,02
025A:  DATA    FE,00,93
025C:  DATA    01,01,02
025E:  DATA    04,01,9C
0260:  DATA    07,01,02
0262:  DATA    09,01,A5
0264:  DATA    0A,01,02
0266:  DATA    0C,01,AD
0268:  DATA    0F,01,02
026A:  DATA    12,01,B6
026C:  DATA    15,01,02
026E:  DATA    18,01,BE
0270:  DATA    1A,01,02
0272:  DATA    1B,01,CA
0274:  DATA    1D,01,02
0276:  DATA    20,01,00
0278:  CLR     32
027A:  MOV     #156,W3
027C:  SUB     W0,W3,W3
027E:  BRA     C,288
0280:  MOV     #29A,W3
0282:  ADD     W3,W0,W0
0284:  TBLRDL  [W0],W0
0286:  RETURN  
0288:  MOV     #29A,W0
028A:  BCLR.B  6.0
028C:  ADD     W3,W3,W3
028E:  ADD     W3,W0,W3
0290:  TBLRDH  [W3++],W0
0292:  TBLRDH  [W3],W3
0294:  SL      W3,#8,W3
0296:  IOR      W3,  W0,W0
0298:  RETURN  
029A:  DATA    00,00,40
029C:  DATA    00,00,01
029E:  DATA    00,00,43
02A0:  DATA    00,00,01
02A2:  DATA    00,00,47
02A4:  DATA    00,00,01
02A6:  DATA    00,00,4A
02A8:  DATA    00,00,01
02AA:  DATA    00,00,4C
02AC:  DATA    00,00,01
02AE:  DATA    00,00,50
02B0:  DATA    00,00,01
02B2:  DATA    00,00,53
02B4:  DATA    00,00,01
02B6:  DATA    00,00,56
02B8:  DATA    00,00,01
02BA:  DATA    00,00,59
02BC:  DATA    00,00,01
02BE:  DATA    00,00,5D
02C0:  DATA    00,00,01
02C2:  DATA    00,00,60
02C4:  DATA    19,00,01
02C6:  DATA    1D,00,62
02C8:  DATA    1D,00,01
02CA:  DATA    20,00,66
02CC:  DATA    20,00,01
02CE:  DATA    23,00,6A
02D0:  DATA    23,00,01
02D2:  DATA    25,00,6C
02D4:  DATA    25,00,01
02D6:  DATA    29,00,6F
02D8:  DATA    29,00,01
02DA:  DATA    2C,00,73
02DC:  DATA    2C,00,01
02DE:  DATA    2F,00,75
02E0:  DATA    2F,00,01
02E2:  DATA    33,00,7D
02E4:  DATA    36,00,01
02E6:  DATA    36,00,7F
02E8:  DATA    38,00,01
02EA:  DATA    38,00,82
02EC:  DATA    3B,00,01
02EE:  DATA    3B,00,85
02F0:  DATA    3F,00,01
02F2:  DATA    3F,00,88
02F4:  DATA    42,00,01
02F6:  DATA    42,00,8C
02F8:  DATA    45,00,01
02FA:  DATA    45,00,92
02FC:  DATA    49,00,01
02FE:  DATA    49,00,95
0300:  DATA    4B,00,01
0302:  DATA    4B,00,98
0304:  DATA    4E,00,01
0306:  DATA    4E,00,9B
0308:  DATA    51,00,01
030A:  DATA    55,00,A2
030C:  DATA    55,00,01
030E:  DATA    58,00,A5
0310:  DATA    58,00,01
0312:  DATA    5B,00,A8
0314:  DATA    5B,00,01
0316:  DATA    5F,00,AE
0318:  DATA    5F,00,01
031A:  DATA    61,00,B1
031C:  DATA    61,00,01
031E:  DATA    64,00,B8
0320:  DATA    64,00,01
0322:  DATA    69,00,BA
0324:  DATA    6B,00,01
0326:  DATA    6B,00,BE
0328:  DATA    6E,00,01
032A:  DATA    6E,00,C4
032C:  DATA    71,00,01
032E:  DATA    71,00,C7
0330:  DATA    74,00,01
0332:  DATA    74,00,CD
0334:  DATA    77,00,01
0336:  DATA    7B,00,D0
0338:  DATA    7B,00,01
033A:  DATA    7D,00,D7
033C:  DATA    7D,00,01
033E:  DATA    81,00,DA
0340:  DATA    81,00,01
0342:  DATA    84,00,E1
0344:  DATA    84,00,01
0346:  DATA    86,00,E6
0348:  DATA    8B,00,01
034A:  DATA    8B,00,EB
034C:  DATA    8E,00,01
034E:  DATA    8E,00,F0
0350:  DATA    90,00,01
0352:  DATA    90,00,F6
0354:  DATA    93,00,01
0356:  DATA    97,00,FA
0358:  DATA    97,00,01
035A:  DATA    9A,00,00
035C:  DATA    9A,00,02
035E:  DATA    9D,00,06
0360:  DATA    9D,00,02
0362:  DATA    A1,00,08
0364:  DATA    A4,00,02
0366:  DATA    A4,00,10
0368:  DATA    A6,00,02
036A:  DATA    A6,00,16
036C:  DATA    A9,00,02
036E:  DATA    AD,00,1C
0370:  DATA    AD,00,02
0372:  DATA    B0,00,23
0374:  DATA    B0,00,02
0376:  DATA    B3,00,28
0378:  DATA    B7,00,02
037A:  DATA    B7,00,2F
037C:  DATA    B9,00,02
037E:  DATA    BC,00,35
0380:  DATA    BC,00,02
0382:  DATA    BF,00,3B
0384:  DATA    BF,00,02
0386:  DATA    C3,00,42
0388:  DATA    C6,00,02
038A:  DATA    C6,00,48
038C:  DATA    C9,00,02
038E:  DATA    CC,00,4E
0390:  DATA    CC,00,02
0392:  DATA    CF,00,54
0394:  DATA    D2,00,02
0396:  DATA    D2,00,5E
0398:  DATA    D5,00,02
039A:  DATA    D9,00,64
039C:  DATA    D9,00,02
039E:  DATA    DC,00,6B
03A0:  DATA    DF,00,02
03A2:  DATA    DF,00,71
03A4:  DATA    E2,00,02
03A6:  DATA    E5,00,7B
03A8:  DATA    E5,00,02
03AA:  DATA    E9,00,80
03AC:  DATA    EB,00,02
03AE:  DATA    EB,00,89
03B0:  DATA    EF,00,02
03B2:  DATA    F2,00,91
03B4:  DATA    F4,00,02
03B6:  DATA    F4,00,9A
03B8:  DATA    F9,00,02
03BA:  DATA    FC,00,A0
03BC:  DATA    FE,00,02
03BE:  DATA    FE,00,A9
03C0:  DATA    01,01,02
03C2:  DATA    05,01,B3
03C4:  DATA    07,01,02
03C6:  DATA    07,01,B9
03C8:  DATA    0B,01,02
03CA:  DATA    0F,01,C2
03CC:  DATA    11,01,02
03CE:  DATA    11,01,CC
03D0:  DATA    14,01,02
03D2:  DATA    17,01,D5
03D4:  DATA    1B,01,02
03D6:  DATA    1E,01,DF
03D8:  DATA    21,01,02
03DA:  DATA    21,01,E9
03DC:  DATA    25,01,02
03DE:  DATA    27,01,F2
03E0:  DATA    2A,01,02
03E2:  DATA    2D,01,FB
03E4:  DATA    31,01,02
03E6:  DATA    34,01,04
03E8:  DATA    34,01,03
03EA:  DATA    37,01,11
03EC:  DATA    3A,01,03
03EE:  DATA    3D,01,00
03F0:  CLR     32
03F2:  MOV     #156,W3
03F4:  SUB     W0,W3,W3
03F6:  BRA     C,400
03F8:  MOV     #412,W3
03FA:  ADD     W3,W0,W0
03FC:  TBLRDL  [W0],W0
03FE:  RETURN  
0400:  MOV     #412,W0
0402:  BCLR.B  6.0
0404:  ADD     W3,W3,W3
0406:  ADD     W3,W0,W3
0408:  TBLRDH  [W3++],W0
040A:  TBLRDH  [W3],W3
040C:  SL      W3,#8,W3
040E:  IOR      W3,  W0,W0
0410:  RETURN  
0412:  DATA    2C,FE,50
0414:  DATA    2C,FE,14
0416:  DATA    2C,FE,21
0418:  DATA    2C,FE,14
041A:  DATA    2C,FE,F2
041C:  DATA    2C,FE,13
041E:  DATA    2C,FE,C3
0420:  DATA    2C,FE,13
0422:  DATA    2C,FE,95
0424:  DATA    2C,FE,13
0426:  DATA    2C,FE,68
0428:  DATA    2C,FE,13
042A:  DATA    2C,FE,3B
042C:  DATA    2C,FE,13
042E:  DATA    2C,FE,0E
0430:  DATA    2C,FE,13
0432:  DATA    2C,FE,E1
0434:  DATA    2C,FE,12
0436:  DATA    2C,FE,B5
0438:  DATA    2C,FE,12
043A:  DATA    2C,FE,89
043C:  DATA    22,EF,12
043E:  DATA    C3,E1,5D
0440:  DATA    CD,D5,12
0442:  DATA    09,CB,31
0444:  DATA    4C,C1,12
0446:  DATA    71,B8,06
0448:  DATA    5C,B0,12
044A:  DATA    F3,A8,DC
044C:  DATA    21,A2,11
044E:  DATA    D6,9B,B1
0450:  DATA    02,96,11
0452:  DATA    98,90,87
0454:  DATA    8E,8B,11
0456:  DATA    DA,86,5D
0458:  DATA    73,82,11
045A:  DATA    53,7E,33
045C:  DATA    72,7A,11
045E:  DATA    CC,76,0A
0460:  DATA    5B,73,11
0462:  DATA    1B,70,E1
0464:  DATA    08,6D,10
0466:  DATA    1D,6A,B8
0468:  DATA    5A,67,10
046A:  DATA    B9,64,8F
046C:  DATA    39,62,10
046E:  DATA    D7,5F,67
0470:  DATA    92,5D,10
0472:  DATA    67,5B,3F
0474:  DATA    54,59,10
0476:  DATA    58,57,17
0478:  DATA    72,55,10
047A:  DATA    A0,53,EF
047C:  DATA    E1,51,0F
047E:  DATA    33,50,C8
0480:  DATA    96,4E,0F
0482:  DATA    09,4D,A0
0484:  DATA    8B,4B,0F
0486:  DATA    1B,4A,79
0488:  DATA    B8,48,0F
048A:  DATA    61,47,53
048C:  DATA    17,46,0F
048E:  DATA    D8,44,2C
0490:  DATA    A3,43,0F
0492:  DATA    79,42,06
0494:  DATA    58,41,0F
0496:  DATA    40,40,E0
0498:  DATA    31,3F,0E
049A:  DATA    2B,3E,BA
049C:  DATA    2C,3D,0E
049E:  DATA    35,3C,94
04A0:  DATA    45,3B,0E
04A2:  DATA    5C,3A,6F
04A4:  DATA    7A,39,0E
04A6:  DATA    9E,38,4A
04A8:  DATA    C8,37,0E
04AA:  DATA    F8,36,25
04AC:  DATA    2D,36,0E
04AE:  DATA    68,35,00
04B0:  DATA    A8,34,0E
04B2:  DATA    EC,33,DB
04B4:  DATA    36,33,0D
04B6:  DATA    84,32,B7
04B8:  DATA    D6,31,0D
04BA:  DATA    2D,31,93
04BC:  DATA    87,30,0D
04BE:  DATA    E6,2F,6F
04C0:  DATA    48,2F,0D
04C2:  DATA    AE,2E,4B
04C4:  DATA    17,2E,0D
04C6:  DATA    84,2D,28
04C8:  DATA    F4,2C,0D
04CA:  DATA    67,2C,04
04CC:  DATA    DD,2B,0D
04CE:  DATA    56,2B,E1
04D0:  DATA    D2,2A,0C
04D2:  DATA    50,2A,BE
04D4:  DATA    D1,29,0C
04D6:  DATA    55,29,9B
04D8:  DATA    DB,28,0C
04DA:  DATA    64,28,79
04DC:  DATA    EF,27,0C
04DE:  DATA    7C,27,56
04E0:  DATA    0B,27,0C
04E2:  DATA    9C,26,34
04E4:  DATA    30,26,0C
04E6:  DATA    C5,25,12
04E8:  DATA    5C,25,0C
04EA:  DATA    F5,24,F0
04EC:  DATA    90,24,0B
04EE:  DATA    2D,24,CF
04F0:  DATA    CB,23,0B
04F2:  DATA    6B,23,AD
04F4:  DATA    0D,23,0B
04F6:  DATA    B0,22,8C
04F8:  DATA    55,22,0B
04FA:  DATA    FB,21,6B
04FC:  DATA    A3,21,0B
04FE:  DATA    4B,21,4A
0500:  DATA    F6,20,0B
0502:  DATA    A1,20,2A
0504:  DATA    4E,20,0B
0506:  DATA    FC,1F,09
0508:  DATA    AC,1F,0B
050A:  DATA    5C,1F,E9
050C:  DATA    0E,1F,0A
050E:  DATA    C1,1E,C9
0510:  DATA    74,1E,0A
0512:  DATA    29,1E,A9
0514:  DATA    DF,1D,0A
0516:  DATA    96,1D,89
0518:  DATA    4E,1D,0A
051A:  DATA    07,1D,6A
051C:  DATA    C1,1C,0A
051E:  DATA    7B,1C,4A
0520:  DATA    37,1C,0A
0522:  DATA    F3,1B,2B
0524:  DATA    B1,1B,0A
0526:  DATA    6F,1B,0C
0528:  DATA    2E,1B,0A
052A:  DATA    ED,1A,EE
052C:  DATA    AE,1A,09
052E:  DATA    6F,1A,CF
0530:  DATA    31,1A,09
0532:  DATA    F3,19,B1
0534:  DATA    B6,19,09
0536:  DATA    7A,19,93
0538:  DATA    3F,19,09
053A:  DATA    04,19,75
053C:  DATA    CA,18,09
053E:  DATA    91,18,57
0540:  DATA    58,18,09
0542:  DATA    1F,18,39
0544:  DATA    E8,17,09
0546:  DATA    B0,17,1C
0548:  DATA    7A,17,09
054A:  DATA    43,17,FF
054C:  DATA    0E,17,08
054E:  DATA    D9,16,E2
0550:  DATA    A4,16,08
0552:  DATA    70,16,C5
0554:  DATA    3C,16,08
0556:  DATA    09,16,A9
0558:  DATA    D6,15,08
055A:  DATA    A4,15,8C
055C:  DATA    72,15,08
055E:  DATA    41,15,70
0560:  DATA    10,15,08
0562:  DATA    DF,14,54
0564:  DATA    AF,14,08
0566:  DATA    7F,14,00
0568:  CLR     32
056A:  MOV     #156,W3
056C:  SUB     W0,W3,W3
056E:  BRA     C,578
0570:  MOV     #58A,W3
0572:  ADD     W3,W0,W0
0574:  TBLRDL  [W0],W0
0576:  RETURN  
0578:  MOV     #58A,W0
057A:  BCLR.B  6.0
057C:  ADD     W3,W3,W3
057E:  ADD     W3,W0,W3
0580:  TBLRDH  [W3++],W0
0582:  TBLRDH  [W3],W3
0584:  SL      W3,#8,W3
0586:  IOR      W3,  W0,W0
0588:  RETURN  
058A:  DATA    00,00,B1
058C:  DATA    00,00,00
058E:  DATA    00,00,B2
0590:  DATA    00,00,00
0592:  DATA    00,00,B4
0594:  DATA    00,00,00
0596:  DATA    00,00,B6
0598:  DATA    00,00,00
059A:  DATA    00,00,B8
059C:  DATA    00,00,00
059E:  DATA    00,00,BA
05A0:  DATA    00,00,00
05A2:  DATA    00,00,BC
05A4:  DATA    00,00,00
05A6:  DATA    00,00,BF
05A8:  DATA    00,00,00
05AA:  DATA    00,00,C1
05AC:  DATA    00,00,00
05AE:  DATA    00,00,C2
05B0:  DATA    00,00,00
05B2:  DATA    55,00,C3
05B4:  DATA    55,00,00
05B6:  DATA    55,00,C4
05B8:  DATA    56,00,00
05BA:  DATA    56,00,C6
05BC:  DATA    56,00,00
05BE:  DATA    56,00,C7
05C0:  DATA    56,00,00
05C2:  DATA    56,00,C8
05C4:  DATA    57,00,00
05C6:  DATA    57,00,C9
05C8:  DATA    57,00,00
05CA:  DATA    57,00,CB
05CC:  DATA    57,00,00
05CE:  DATA    58,00,CC
05D0:  DATA    58,00,00
05D2:  DATA    58,00,CE
05D4:  DATA    58,00,00
05D6:  DATA    58,00,CF
05D8:  DATA    59,00,00
05DA:  DATA    59,00,D1
05DC:  DATA    59,00,00
05DE:  DATA    59,00,D2
05E0:  DATA    5A,00,00
05E2:  DATA    5A,00,D4
05E4:  DATA    5A,00,00
05E6:  DATA    5A,00,D5
05E8:  DATA    5B,00,00
05EA:  DATA    5B,00,D7
05EC:  DATA    5B,00,00
05EE:  DATA    5B,00,D8
05F0:  DATA    5C,00,00
05F2:  DATA    5C,00,DA
05F4:  DATA    5C,00,00
05F6:  DATA    5C,00,DC
05F8:  DATA    5D,00,00
05FA:  DATA    5D,00,DE
05FC:  DATA    5D,00,00
05FE:  DATA    5E,00,DF
0600:  DATA    5E,00,00
0602:  DATA    5E,00,E1
0604:  DATA    5F,00,00
0606:  DATA    5F,00,E3
0608:  DATA    5F,00,00
060A:  DATA    5F,00,E5
060C:  DATA    60,00,00
060E:  DATA    60,00,E7
0610:  DATA    60,00,00
0612:  DATA    61,00,E9
0614:  DATA    61,00,00
0616:  DATA    61,00,EB
0618:  DATA    62,00,00
061A:  DATA    62,00,ED
061C:  DATA    62,00,00
061E:  DATA    63,00,F0
0620:  DATA    63,00,00
0622:  DATA    64,00,F2
0624:  DATA    64,00,00
0626:  DATA    65,00,F4
0628:  DATA    65,00,00
062A:  DATA    65,00,F7
062C:  DATA    66,00,00
062E:  DATA    66,00,F9
0630:  DATA    66,00,00
0632:  DATA    67,00,FC
0634:  DATA    67,00,00
0636:  DATA    68,00,FE
0638:  DATA    68,00,00
063A:  DATA    69,00,01
063C:  DATA    69,00,01
063E:  DATA    6A,00,04
0640:  DATA    6A,00,01
0642:  DATA    6A,00,07
0644:  DATA    6B,00,01
0646:  DATA    6B,00,0A
0648:  DATA    6C,00,01
064A:  DATA    6C,00,0D
064C:  DATA    6D,00,01
064E:  DATA    6E,00,10
0650:  DATA    6E,00,01
0652:  DATA    6F,00,13
0654:  DATA    6F,00,01
0656:  DATA    70,00,17
0658:  DATA    70,00,01
065A:  DATA    71,00,1A
065C:  DATA    71,00,01
065E:  DATA    72,00,1E
0660:  DATA    72,00,01
0662:  DATA    73,00,21
0664:  DATA    74,00,01
0666:  DATA    74,00,25
0668:  DATA    75,00,01
066A:  DATA    75,00,29
066C:  DATA    76,00,01
066E:  DATA    77,00,2D
0670:  DATA    78,00,01
0672:  DATA    78,00,32
0674:  DATA    79,00,01
0676:  DATA    7A,00,36
0678:  DATA    7A,00,01
067A:  DATA    7B,00,3B
067C:  DATA    7C,00,01
067E:  DATA    7D,00,40
0680:  DATA    7D,00,01
0682:  DATA    7E,00,45
0684:  DATA    7F,00,01
0686:  DATA    7F,00,4A
0688:  DATA    80,00,01
068A:  DATA    81,00,4F
068C:  DATA    82,00,01
068E:  DATA    82,00,55
0690:  DATA    83,00,01
0692:  DATA    84,00,5B
0694:  DATA    85,00,01
0696:  DATA    86,00,61
0698:  DATA    87,00,01
069A:  DATA    88,00,68
069C:  DATA    89,00,01
069E:  DATA    8A,00,6F
06A0:  DATA    8B,00,01
06A2:  DATA    8C,00,76
06A4:  DATA    8D,00,01
06A6:  DATA    8E,00,7D
06A8:  DATA    8F,00,01
06AA:  DATA    90,00,85
06AC:  DATA    91,00,01
06AE:  DATA    92,00,8D
06B0:  DATA    93,00,01
06B2:  DATA    94,00,96
06B4:  DATA    95,00,01
06B6:  DATA    96,00,9F
06B8:  DATA    97,00,01
06BA:  DATA    98,00,A9
06BC:  DATA    99,00,01
06BE:  DATA    9A,00,B4
06C0:  DATA    9B,00,01
06C2:  DATA    9C,00,B4
06C4:  DATA    9D,00,01
06C6:  DATA    9E,00,B4
06C8:  DATA    9F,00,01
06CA:  DATA    A1,00,B4
06CC:  DATA    A2,00,01
06CE:  DATA    A3,00,B4
06D0:  DATA    A4,00,01
06D2:  DATA    A6,00,B4
06D4:  DATA    A7,00,01
06D6:  DATA    A9,00,B4
06D8:  DATA    AA,00,01
06DA:  DATA    AC,00,B4
06DC:  DATA    AD,00,01
06DE:  DATA    AF,00,00
06E0:  CLR     32
06E2:  MOV     #6EC,W3
06E4:  ADD     W3,W0,W0
06E6:  TBLRDL.B[W0],W0L
06E8:  CLR.B   1
06EA:  RETURN  
06EC:  DATA    0A,4D,00
06EE:  DATA    6F,74,00
06F0:  DATA    6F,72,00
06F2:  DATA    20,43,00
06F4:  DATA    6F,6E,00
06F6:  DATA    74,72,00
06F8:  DATA    6F,6C,00
06FA:  DATA    20,55,00
06FC:  DATA    6E,69,00
06FE:  DATA    74,20,00
0700:  DATA    76,30,00
0702:  DATA    2E,31,00
0704:  DATA    0D,0A,00
0706:  DATA    00,00,00
0708:  PUSH    42
070A:  PUSH    36
070C:  PUSH    32
070E:  MOV     W0,[W15++]
0710:  MOV     #2,W0
0712:  REPEAT  #C
0714:  MOV     [W0++],[W15++]
0716:  MOV     #800,W0
0718:  MOV     864,W4
071A:  ADD     W0,W4,W1
071C:  MOV     212,W0
071E:  BCLR.B  85.1
0720:  MOV.B   W0L,[W1++]
0722:  INC     0864
0724:  MOV     #63,W4
0726:  MOV     864,W3
0728:  SUB     W4,W3,W0
072A:  BRA     C,72E
072C:  CLR     864
072E:  BTSC.B  20E.0
0730:  BRA     71C
*
07A6:  MOV     W5,[W15++]
07A8:  MOV     #C,W5
07AA:  REPEAT  #3
07AC:  MOV     [W5++],[W15++]
07AE:  MUL.UU  W0,W2,W4
07B0:  BTSS    W3.F
07B2:  BRA     7B8
07B4:  MUL.SS  W0,W3,W6
07B6:  BRA     7BA
07B8:  MUL.UU  W0,W3,W6
07BA:  BCLR.B  42.0
07BC:  ADD     W6,W5,W5
07BE:  ADDC    W7,#0,W8
07C0:  BTSS    W1.F
07C2:  BRA     7C8
07C4:  MUL.SS  W1,W2,W6
07C6:  BRA     7CA
07C8:  MUL.UU  W1,W2,W6
07CA:  ADDC    W6,W5,W5
07CC:  ADDC    W7,W8,W8
07CE:  ADDC    #0,W9
07D0:  MUL.SS  W1,W3,W6
07D2:  ADDC    W6,W8,W8
07D4:  ADDC    W9,W7,W7
07D6:  MOV     W7,W3
07D8:  MOV     W8,W2
07DA:  MOV     W5,W1
07DC:  MOV     W4,W0
07DE:  MOV     #12,W5
07E0:  REPEAT  #3
07E2:  MOV     [--W15],[W5--]
07E4:  MOV     [--W15],W5
07E6:  RETURN  
*
09FA:  MOV     W1,[W15++]
09FC:  MOV     A22,W1
09FE:  MOV.B   W0L,[W1++]
0A00:  CLR.B   [W1]
0A02:  MOV     [--W15],W1
0A04:  INC     0A22
0A06:  RETURN  
*
0A60:  MOV     W5,[W15++]
0A62:  MOV     #C,W5
0A64:  REPEAT  #3
0A66:  MOV     [W5++],[W15++]
0A68:  MOV     W0,W4
0A6A:  MOV     W1,W5
0A6C:  MOV     W2,W6
0A6E:  MOV     W3,W7
0A70:  CLR     W0
0A72:  CLR     W1
0A74:  CLR     W2
0A76:  CLR     W3
0A78:  BCLR    W8.0
0A7A:  BTSS    W7.F
0A7C:  BRA     A8E
0A7E:  BSET    W8.0
0A80:  COM     W7,W7
0A82:  COM     W6,W6
0A84:  COM     W5,W5
0A86:  NEG     W4,W4
0A88:  ADDC    W5,#0,W5
0A8A:  ADDC    W6,#0,W6
0A8C:  ADDC    W7,#0,W7
0A8E:  IOR      W4,  W5,W9
0A90:  BRA     NZ,A96
0A92:  IOR      W6,  W7,W9
0A94:  BRA     Z,AC0
0A96:  MOV     #473,W9
0A98:  BTSC    W3.4
0A9A:  BRA     AB2
0A9C:  BCLR.B  42.0
0A9E:  RLC     W4,W4
0AA0:  RLC     W5,W5
0AA2:  RLC     W6,W6
0AA4:  RLC     W7,W7
0AA6:  RLC     W0,W0
0AA8:  RLC     W1,W1
0AAA:  RLC     W2,W2
0AAC:  RLC     W3,W3
0AAE:  DEC     W9,W9
0AB0:  BRA     NZ,A98
0AB2:  SL      W9,#4,W9
0AB4:  BCLR.B  42.0
0AB6:  BCLR    W9.F
0AB8:  BCLR    W3.4
0ABA:  XOR     W9,W3,W3
0ABC:  BTSC    W8.0
0ABE:  BSET    W3.F
0AC0:  MOV     #12,W5
0AC2:  REPEAT  #3
0AC4:  MOV     [--W15],[W5--]
0AC6:  MOV     [--W15],W5
0AC8:  RETURN  
0ACA:  MOV     W8,[W15++]
0ACC:  MOV     #12,W8
0ACE:  REPEAT  #4
0AD0:  MOV     [W8++],[W15++]
0AD2:  CLR     W11
0AD4:  MUL.UU  W12,#0,W12
0AD6:  MOV     W3,W8
0AD8:  MOV     W7,W9
0ADA:  MOV     #7FF,W10
0ADC:  BCLR.B  42.0
0ADE:  BCLR.B  42.1
0AE0:  ASR     W8,#4,W8
0AE2:  AND     W10,W8,W8
0AE4:  CP0     W8
0AE6:  BRA     Z,BCA
0AE8:  BCLR.B  42.0
0AEA:  BCLR.B  42.1
0AEC:  ASR     W9,#4,W9
0AEE:  AND     W10,W9,W9
0AF0:  CP0     W9
0AF2:  BRA     Z,BCA
0AF4:  ADD     W9,W8,W8
0AF6:  BTSC    W9.B
0AF8:  BRA     B02
0AFA:  SUB     #3FF,W8
0AFC:  BRA     Z,BCA
0AFE:  BRA     NC,BCA
0B00:  BRA     B08
0B02:  MOV     #401,W10
0B04:  ADD.B   W10L,W5L,W5L
0B06:  BRA     C,BCA
0B08:  XOR     W3,W7,W13
0B0A:  BCLR.B  42.0
0B0C:  BCLR.B  42.1
0B0E:  AND     #F,W3
0B10:  BSET    W3.4
0B12:  AND     #F,W7
0B14:  BSET    W7.4
0B16:  MOV     W8,[W15++]
0B18:  MUL.UU  W4,W1,W8
0B1A:  MUL.UU  W5,W0,W10
0B1C:  ADD     W8,W10,W10
0B1E:  ADDC    W9,W11,W11
0B20:  ADDC    #0,W12
0B22:  MUL.UU  W4,W2,W8
0B24:  ADD     W8,W11,W11
0B26:  ADDC    W9,W12,W12
0B28:  MUL.UU  W5,W1,W8
0B2A:  CLR     W10
0B2C:  ADD     W8,W11,W11
0B2E:  ADDC    W9,W12,W12
0B30:  ADDC    #0,W10
0B32:  MUL.UU  W6,W0,W8
0B34:  ADD     W8,W11,W11
0B36:  ADDC    W9,W12,W12
0B38:  ADDC    #0,W10
0B3A:  CLR     W11
0B3C:  MUL.UU  W4,W3,W8
0B3E:  ADD     W8,W12,W12
0B40:  ADDC    W9,W10,W10
0B42:  ADDC    #0,W11
0B44:  MUL.UU  W5,W2,W8
0B46:  ADD     W8,W12,W12
0B48:  ADDC    W9,W10,W10
0B4A:  ADDC    #0,W11
0B4C:  MUL.UU  W6,W1,W8
0B4E:  ADD     W8,W12,W12
0B50:  ADDC    W9,W10,W10
0B52:  ADDC    #0,W11
0B54:  MUL.UU  W7,W0,W8
0B56:  ADD     W8,W12,W12
0B58:  ADDC    W9,W10,W10
0B5A:  ADDC    #0,W11
0B5C:  MOV     W12,W0
0B5E:  CLR     W12
0B60:  MUL.UU  W5,W3,W8
0B62:  ADD     W8,W10,W10
0B64:  ADDC    W9,W11,W11
0B66:  ADDC    #0,W12
0B68:  MUL.UU  W6,W2,W8
0B6A:  ADD     W8,W10,W10
0B6C:  ADDC    W9,W11,W11
0B6E:  ADDC    #0,W12
0B70:  MUL.UU  W6,W3,W8
0B72:  ADD     W8,W11,W11
0B74:  ADDC    W9,W12,W12
0B76:  MUL.UU  W7,W1,W8
0B78:  ADD     W8,W10,W10
0B7A:  ADDC    W9,W11,W11
0B7C:  ADDC    #0,W12
0B7E:  MUL.UU  W7,W2,W8
0B80:  ADD     W8,W11,W11
0B82:  ADDC    W9,W12,W12
0B84:  MUL.UU  W7,W3,W8
0B86:  ADD     W8,W12,W12
0B88:  MOV     W10,W1
0B8A:  MOV     W11,W2
0B8C:  MOV     W12,W3
0B8E:  MOV     #5,W4
0B90:  BCLR.B  42.0
0B92:  RRC     W3,W3
0B94:  RRC     W2,W2
0B96:  RRC     W1,W1
0B98:  RRC     W0,W0
0B9A:  DEC     W4,W4
0B9C:  BRA     NZ,B90
0B9E:  MOV     [--W15],W8
0BA0:  INC     W8,W8
0BA2:  IOR      W0,  W1,W6
0BA4:  BRA     Z,BA8
0BA6:  BRA     BAC
0BA8:  IOR      W2,  W3,W6
0BAA:  BRA     Z,BBC
0BAC:  BTSC    W3.4
0BAE:  BRA     BBC
0BB0:  BCLR.B  42.0
0BB2:  RLC     W0,W0
0BB4:  RLC     W1,W1
0BB6:  RLC     W2,W2
0BB8:  RLC     W3,W3
0BBA:  DEC     W8,W8
0BBC:  SL      W8,#4,W8
0BBE:  BCLR    W3.F
0BC0:  BTSC    W13.F
0BC2:  BSET    W3.F
0BC4:  BCLR    W3.4
0BC6:  XOR     W8,W3,W3
0BC8:  BRA     BD0
0BCA:  MUL.UU  W0,#0,W0
0BCC:  MUL.UU  W0,#0,W2
0BCE:  BRA     BD0
0BD0:  MOV     #1A,W8
0BD2:  REPEAT  #4
0BD4:  MOV     [--W15],[W8--]
0BD6:  MOV     [--W15],W8
0BD8:  RETURN  
0BDA:  MOV     W8,[W15++]
0BDC:  MOV     #12,W8
0BDE:  REPEAT  #4
0BE0:  MOV     [W8++],[W15++]
0BE2:  XOR     W3,W7,W13
0BE4:  MOV     W3,W8
0BE6:  MOV     W7,W9
0BE8:  MOV     #7FF,W10
0BEA:  BCLR.B  42.0
0BEC:  BCLR.B  42.1
0BEE:  ASR     W8,#4,W8
0BF0:  AND     W10,W8,W8
0BF2:  CP0     W8
0BF4:  BRA     Z,CCE
0BF6:  BCLR.B  42.0
0BF8:  BCLR.B  42.1
0BFA:  ASR     W9,#4,W9
0BFC:  AND     W10,W9,W9
0BFE:  CP0     W9
0C00:  BRA     Z,CCE
0C02:  CLR     W10
0C04:  SUB     W8,W9,W12
0C06:  BRA     NC,C0E
0C08:  ADD     #3FF,W12
0C0A:  BRA     C,CCE
0C0C:  BRA     C16
0C0E:  MOV     #401,W11
0C10:  SUB     W12,W11,W12
0C12:  BRA     NC,CCE
0C14:  BRA     Z,CCE
0C16:  CLR     W8
0C18:  CLR     W9
0C1A:  CLR     W10
0C1C:  CLR     W11
0C1E:  AND     #1F,W3
0C20:  BSET    W3.4
0C22:  AND     #1F,W7
0C24:  BSET    W7.4
0C26:  MOV     W12,[W15++]
0C28:  MOV     #36,W12
0C2A:  SUB     W0,W4,W0
0C2C:  SUBB    W1,W5,W1
0C2E:  SUBB    W2,W6,W2
0C30:  SUBB    W3,W7,W3
0C32:  BRA     N,C38
0C34:  BRA     C,C42
0C36:  BRA     NZ,C44
0C38:  ADD     W0,W4,W0
0C3A:  ADDC    W1,W5,W1
0C3C:  ADDC    W2,W6,W2
0C3E:  ADDC    W3,W7,W3
0C40:  BRA     C44
0C42:  BSET    W8.0
0C44:  DEC     W12,W12
0C46:  BRA     Z,C5E
0C48:  BCLR.B  42.0
0C4A:  RLC     W0,W0
0C4C:  RLC     W1,W1
0C4E:  RLC     W2,W2
0C50:  RLC     W3,W3
0C52:  BCLR.B  42.0
0C54:  RLC     W8,W8
0C56:  RLC     W9,W9
0C58:  RLC     W10,W10
0C5A:  RLC     W11,W11
0C5C:  BRA     C2A
0C5E:  MOV     [--W15],W12
0C60:  BTSC    W11.5
0C62:  BRA     C66
0C64:  BRA     C72
0C66:  BCLR.B  42.0
0C68:  RRC     W11,W11
0C6A:  RRC     W10,W10
0C6C:  RRC     W9,W9
0C6E:  RRC     W8,W8
0C70:  BRA     C78
0C72:  DEC     W12,W12
0C74:  BCLR.B  42.0
0C76:  BRA     Z,CCE
0C78:  BTSC.B  42.0
0C7A:  BRA     C8E
0C7C:  RLC     W0,W0
0C7E:  RLC     W1,W1
0C80:  RLC     W2,W2
0C82:  RLC     W3,W3
0C84:  SUB     W0,W4,W4
0C86:  SUBB    W1,W5,W5
0C88:  SUBB    W2,W6,W6
0C8A:  SUBB    W3,W7,W7
0C8C:  BRA     NC,CB8
0C8E:  INC     W8,W8
0C90:  BRA     NZ,CB8
0C92:  INC     W9,W9
0C94:  BRA     NZ,CB8
0C96:  INC     W10,W10
0C98:  BRA     NZ,CB8
0C9A:  INC     W11,W11
0C9C:  BRA     NZ,CB8
0C9E:  INC     W12,W12
0CA0:  BRA     Z,CCE
0CA2:  BRA     CB8
0CA4:  DEC     W12,W12
0CA6:  BRA     Z,CCE
0CA8:  BTSC    W11.4
0CAA:  BRA     CB8
0CAC:  BCLR.B  42.0
0CAE:  RLC     W8,W8
0CB0:  RLC     W9,W9
0CB2:  RLC     W10,W10
0CB4:  RLC     W11,W11
0CB6:  BRA     CA8
0CB8:  SL      W12,#4,W12
0CBA:  BCLR.B  42.0
0CBC:  BCLR    W12.F
0CBE:  BTSC    W13.F
0CC0:  BSET    W12.F
0CC2:  BCLR    W11.4
0CC4:  XOR     W12,W11,W3
0CC6:  MOV     W10,W2
0CC8:  MOV     W9,W1
0CCA:  MOV     W8,W0
0CCC:  BRA     CD8
0CCE:  MOV     #0,W0
0CD0:  MOV     #0,W1
0CD2:  MOV     #0,W2
0CD4:  MOV     #0,W3
0CD6:  BRA     CD8
0CD8:  MOV     #1A,W8
0CDA:  REPEAT  #4
0CDC:  MOV     [--W15],[W8--]
0CDE:  MOV     [--W15],W8
0CE0:  RETURN  
0CE2:  MOV     W8,[W15++]
0CE4:  MOV     #12,W8
0CE6:  REPEAT  #4
0CE8:  MOV     [W8++],[W15++]
0CEA:  MOV     #8000,W8
0CEC:  BTSC.B  43.0
0CEE:  XOR     W8,W7,W7
0CF0:  CP0     W0
0CF2:  BRA     NZ,D02
0CF4:  CP0     W1
0CF6:  BRA     NZ,D02
0CF8:  CP0     W2
0CFA:  BRA     NZ,D02
0CFC:  MOV     #7FFF,W10
0CFE:  AND     W3,W10,W10
0D00:  BTSS.B  42.1
0D02:  MOV     W3,W10
0D04:  XOR     W7,W10,W11
0D06:  MOV     W3,W8
0D08:  MOV     W7,W9
0D0A:  MOV     W7,W12
0D0C:  MOV     #7FF,W13
0D0E:  BCLR.B  42.1
0D10:  BCLR.B  42.0
0D12:  ASR     W8,#4,W8
0D14:  AND     W13,W8,W8
0D16:  CP0     W8
0D18:  BRA     Z,E92
0D1A:  BCLR.B  42.1
0D1C:  BCLR.B  42.0
0D1E:  ASR     W9,#4,W9
0D20:  AND     W13,W9,W9
0D22:  CP0     W9
0D24:  BRA     Z,EA2
0D26:  CLR     W13
0D28:  BCLR.B  42.1
0D2A:  BCLR.B  42.0
0D2C:  CP      W9,W8
0D2E:  BRA     Z,EA4
0D30:  BRA     N,EB4
0D32:  BCLR    W13.0
0D34:  BSET    W13.1
0D36:  SUB     W9,W8,W8
0D38:  AND     #F,W3
0D3A:  BSET    W3.4
0D3C:  AND     #F,W7
0D3E:  BSET    W7.4
0D40:  SUB     #34,W8
0D42:  BRA     NN,D70
0D44:  ADD     #34,W8
0D46:  BCLR.B  42.1
0D48:  BCLR.B  42.0
0D4A:  RRC     W3,W3
0D4C:  RRC     W2,W2
0D4E:  RRC     W1,W1
0D50:  RRC     W0,W0
0D52:  DEC     W8,W8
0D54:  BRA     NZ,D46
0D56:  BRA     D80
0D58:  SUB     #34,W8
0D5A:  BRA     NN,D7A
0D5C:  ADD     #34,W8
0D5E:  BCLR.B  42.1
0D60:  BCLR.B  42.0
0D62:  RRC     W7,W7
0D64:  RRC     W6,W6
0D66:  RRC     W5,W5
0D68:  RRC     W4,W4
0D6A:  DEC     W8,W8
0D6C:  BRA     NZ,D5E
0D6E:  BRA     DA6
0D70:  MOV     W4,W0
0D72:  MOV     W5,W1
0D74:  MOV     W6,W2
0D76:  MOV     W7,W3
0D78:  XOR     W11,W12,W12
0D7A:  BTSC    W12.F
0D7C:  BTG     W11.F
0D7E:  BRA     E72
0D80:  BTSS    W11.F
0D82:  BRA     DC2
0D84:  BTSC    W13.4
0D86:  MOV     W12,W11
0D88:  COM     W0,W0
0D8A:  COM     W1,W1
0D8C:  COM     W2,W2
0D8E:  COM.B   W3L,W3L
0D90:  AND.B   #1F,W3L
0D92:  INC     W0,W0
0D94:  BRA     NZ,DA0
0D96:  INC     W1,W1
0D98:  BRA     NZ,DA0
0D9A:  INC     W2,W2
0D9C:  BRA     NZ,DA0
0D9E:  INC.B   W3L,W3L
0DA0:  BTSC    W13.4
0DA2:  BRA     E08
0DA4:  BRA     DC2
0DA6:  BTSS    W11.F
0DA8:  BRA     DC2
0DAA:  COM     W4,W4
0DAC:  COM     W5,W5
0DAE:  COM     W6,W6
0DB0:  COM.B   W7L,W7L
0DB2:  AND.B   #1F,W7L
0DB4:  INC     W4,W4
0DB6:  BRA     NZ,DC2
0DB8:  INC     W5,W5
0DBA:  BRA     NZ,DC2
0DBC:  INC     W6,W6
0DBE:  BRA     NZ,DC2
0DC0:  INC.B   W7L,W7L
0DC2:  BCLR.B  42.1
0DC4:  BCLR.B  42.0
0DC6:  ADD     W0,W4,W0
0DC8:  ADDC    W1,W5,W1
0DCA:  ADDC    W2,W6,W2
0DCC:  ADDC.B  W3L,W7L,W3L
0DCE:  BTSC    W3.5
0DD0:  BSET    W13.3
0DD2:  BTSC    W13.0
0DD4:  BRA     DE8
0DD6:  BTSC    W13.1
0DD8:  BRA     DDC
0DDA:  BRA     DF2
0DDC:  BTSC    W11.F
0DDE:  BRA     E08
0DE0:  BTSC    W13.3
0DE2:  BRA     E36
0DE4:  BSET    W13.6
0DE6:  BRA     E2A
0DE8:  BTSC    W11.F
0DEA:  BRA     E08
0DEC:  BTSC    W13.3
0DEE:  BRA     E36
0DF0:  BRA     E2A
0DF2:  BTSC    W11.F
0DF4:  BRA     DFE
0DF6:  MOV     W10,W11
0DF8:  BTSC    W13.3
0DFA:  BRA     E36
0DFC:  BRA     E72
0DFE:  BSET    W13.4
0E00:  XOR.B   #10,W3L
0E02:  BTSC    W3.4
0E04:  BRA     D84
0E06:  MOV     W10,W11
0E08:  AND     #1F,W3
0E0A:  IOR      W3,  W2,W8
0E0C:  BRA     NZ,E12
0E0E:  IOR      W1,  W0,W8
0E10:  BRA     Z,E2A
0E12:  BTSC    W3.4
0E14:  BRA     E2A
0E16:  BCLR.B  42.1
0E18:  BCLR.B  42.0
0E1A:  RLC     W0,W0
0E1C:  RLC     W1,W1
0E1E:  RLC     W2,W2
0E20:  RLC     W3,W3
0E22:  DEC     W9,W9
0E24:  BTSC.B  42.1
0E26:  BRA     E8C
0E28:  BRA     E12
0E2A:  BTSC    W13.0
0E2C:  MOV     W10,W11
0E2E:  BTSC    W13.1
0E30:  MOV     W12,W11
0E32:  BTSS    W13.5
0E34:  BRA     E72
0E36:  BCLR.B  42.0
0E38:  RRC.B   W3L,W3L
0E3A:  RRC     W2,W2
0E3C:  RRC     W1,W1
0E3E:  RRC     W0,W0
0E40:  BTSC.B  42.0
0E42:  BSET    W13.5
0E44:  INC     W9,W9
0E46:  BTSC.B  42.1
0E48:  BRA     E8C
0E4A:  BTSS    W13.5
0E4C:  BRA     E6A
0E4E:  INC     W0,W0
0E50:  BRA     NZ,E6A
0E52:  INC     W1,W1
0E54:  BRA     NZ,E6A
0E56:  INC     W2,W2
0E58:  BRA     NZ,E6A
0E5A:  INC     W3,W3
0E5C:  BRA     NZ,E6A
0E5E:  RRC.B   W3L,W3L
0E60:  RRC     W2,W2
0E62:  RRC     W1,W1
0E64:  RRC     W0,W0
0E66:  INC     W9,W9
0E68:  BRA     Z,E8C
0E6A:  BTSC    W13.0
0E6C:  MOV     W10,W11
0E6E:  BTSC    W13.1
0E70:  MOV     W12,W11
0E72:  IOR      W0,  W1,W4
0E74:  BRA     NZ,E7A
0E76:  IOR      W2,  W3,W4
0E78:  BRA     Z,EC6
0E7A:  BCLR    W3.4
0E7C:  BCLR.B  42.1
0E7E:  BCLR.B  42.0
0E80:  SL      W9,#4,W9
0E82:  XOR     W9,W3,W3
0E84:  BSET    W3.F
0E86:  BTSS    W11.F
0E88:  BCLR    W3.F
0E8A:  BRA     EC6
0E8C:  MUL.UU  W0,#0,W0
0E8E:  MUL.UU  W2,#0,W2
0E90:  BRA     EC6
0E92:  MOV     #8000,W8
0E94:  BTSC    W10.F
0E96:  XOR     W8,W7,W7
0E98:  MOV     W5,W1
0E9A:  MOV     W4,W0
0E9C:  MOV     W6,W2
0E9E:  MOV     W7,W3
0EA0:  BRA     EC6
0EA2:  BRA     EC6
0EA4:  AND     #F,W7
0EA6:  BSET    W7.4
0EA8:  AND     #F,W3
0EAA:  BSET    W3.4
0EAC:  BTSC    W11.F
0EAE:  BCLR    W7.4
0EB0:  BSET    W13.2
0EB2:  BRA     DA6
0EB4:  AND     #F,W3
0EB6:  BSET    W3.4
0EB8:  AND     #F,W7
0EBA:  BSET    W7.4
0EBC:  SUB     W8,W9,W8
0EBE:  ADD     W8,W9,W9
0EC0:  BCLR    W13.1
0EC2:  BSET    W13.0
0EC4:  BRA     D58
0EC6:  MOV     #1A,W8
0EC8:  REPEAT  #4
0ECA:  MOV     [--W15],[W8--]
0ECC:  MOV     [--W15],W8
0ECE:  RETURN  
0ED0:  MOV     W8,[W15++]
0ED2:  MOV     W9,[W15++]
0ED4:  MOV     W10,[W15++]
0ED6:  XOR     W3,W7,W9
0ED8:  BTSS    W9.F
0EDA:  BRA     EE8
0EDC:  BCLR.B  42.0
0EDE:  BCLR.B  42.1
0EE0:  BTSS    W3.F
0EE2:  BRA     F4C
0EE4:  BSET.B  42.0
0EE6:  BRA     F4C
0EE8:  MOV     #7FF,W10
0EEA:  MOV     W3,W8
0EEC:  MOV     W7,W9
0EEE:  ASR     W8,#4,W8
0EF0:  AND     W10,W8,W8
0EF2:  ASR     W9,#4,W9
0EF4:  AND     W10,W9,W9
0EF6:  SUB     W9,W8,W10
0EF8:  BRA     Z,F04
0EFA:  BTSS    W3.F
0EFC:  BRA     F4C
0EFE:  MOV     #1,W0
0F00:  XOR.B   42
0F02:  BRA     F4C
0F04:  MOV     W3,W8
0F06:  MOV     W7,W9
0F08:  AND     #1F,W3
0F0A:  AND     #1F,W7
0F0C:  BCLR    W3.4
0F0E:  BCLR    W7.4
0F10:  SUB.B   W7L,W3L,W10L
0F12:  BRA     Z,F1E
0F14:  BTSS    W8.F
0F16:  BRA     F4C
0F18:  MOV     #1,W0
0F1A:  XOR.B   42
0F1C:  BRA     F4C
0F1E:  SUB     W6,W2,W10
0F20:  BRA     Z,F2C
0F22:  BTSS    W8.F
0F24:  BRA     F4C
0F26:  MOV     #1,W0
0F28:  XOR.B   42
0F2A:  BRA     F4C
0F2C:  SUB     W5,W1,W10
0F2E:  BRA     Z,F3A
0F30:  BTSS    W8.F
0F32:  BRA     F4C
0F34:  MOV     #1,W0
0F36:  XOR.B   42
0F38:  BRA     F4C
0F3A:  SUB     W4,W0,W10
0F3C:  BRA     Z,F48
0F3E:  BTSS    W8.F
0F40:  BRA     F4C
0F42:  MOV     #1,W0
0F44:  XOR.B   42
0F46:  BRA     F4C
0F48:  BCLR.B  42.0
0F4A:  BRA     F4C
0F4C:  MOV     [--W15],W10
0F4E:  MOV     [--W15],W9
0F50:  MOV     [--W15],W8
0F52:  RETURN  
0F54:  MOV     W5,[W15++]
0F56:  MOV     #C,W5
0F58:  REPEAT  #5
0F5A:  MOV     [W5++],[W15++]
0F5C:  MOV     W3,W8
0F5E:  MOV     W2,W7
0F60:  MOV     W1,W6
0F62:  MOV     W0,W5
0F64:  MOV     W3,W9
0F66:  MOV     #473,W11
0F68:  ASR     W3,#4,W3
0F6A:  MOV     #7FF,W10
0F6C:  AND     W10,W3,W3
0F6E:  SUB     W11,W3,W11
0F70:  AND     #1F,W8
0F72:  BSET    W8.4
0F74:  CLR     W0
0F76:  CLR     W1
0F78:  CLR     W2
0F7A:  CLR     W3
0F7C:  BCLR.B  42.0
0F7E:  RRC     W8,W8
0F80:  RRC     W7,W7
0F82:  RRC     W6,W6
0F84:  RRC     W5,W5
0F86:  RRC     W3,W3
0F88:  RRC     W2,W2
0F8A:  RRC     W1,W1
0F8C:  RRC     W0,W0
0F8E:  DEC     W11,W11
0F90:  BRA     NZ,F7C
0F92:  BTSS    W9.F
0F94:  BRA     FA8
0F96:  COM     W0,W0
0F98:  COM     W1,W1
0F9A:  COM     W2,W2
0F9C:  COM     W3,W3
0F9E:  INC     W0,W0
0FA0:  ADDC    #0,W1
0FA2:  ADDC    #0,W2
0FA4:  ADDC    #0,W3
0FA6:  BRA     FA8
0FA8:  MOV     #16,W5
0FAA:  REPEAT  #5
0FAC:  MOV     [--W15],[W5--]
0FAE:  MOV     [--W15],W5
0FB0:  RETURN  
*
1296:  MOV     W5,[W15++]
1298:  MOV     #C,W5
129A:  REPEAT  #5
129C:  MOV     [W5++],[W15++]
129E:  MOV     W3,W8
12A0:  MOV     W2,W7
12A2:  MOV     W1,W6
12A4:  MOV     W0,W5
12A6:  MOV     W3,W9
12A8:  MOV     #473,W11
12AA:  ASR     W3,#4,W3
12AC:  MOV     #7FF,W10
12AE:  AND     W10,W3,W3
12B0:  SUB     W11,W3,W11
12B2:  AND     #1F,W8
12B4:  BSET    W8.4
12B6:  CLR     W0
12B8:  CLR     W1
12BA:  CLR     W2
12BC:  CLR     W3
12BE:  BCLR.B  42.0
12C0:  RRC     W8,W8
12C2:  RRC     W7,W7
12C4:  RRC     W6,W6
12C6:  RRC     W5,W5
12C8:  RRC     W3,W3
12CA:  RRC     W2,W2
12CC:  RRC     W1,W1
12CE:  RRC     W0,W0
12D0:  DEC     W11,W11
12D2:  BRA     NZ,12BE
12D4:  BTSS    W9.F
12D6:  BRA     12EA
12D8:  COM     W0,W0
12DA:  COM     W1,W1
12DC:  COM     W2,W2
12DE:  COM     W3,W3
12E0:  INC     W0,W0
12E2:  ADDC    #0,W1
12E4:  ADDC    #0,W2
12E6:  ADDC    #0,W3
12E8:  BRA     12EA
12EA:  MOV     #16,W5
12EC:  REPEAT  #5
12EE:  MOV     [--W15],[W5--]
12F0:  MOV     [--W15],W5
12F2:  RETURN  
*
13BC:  MOV     W5,[W15++]
13BE:  MOV     #C,W5
13C0:  REPEAT  #3
13C2:  MOV     [W5++],[W15++]
13C4:  BTSS    W0.F
13C6:  BRA     13E6
13C8:  NEG     W0,W0
13CA:  BSET    W4.8
13CC:  BTSS    W4.F
13CE:  BRA     13E6
13D0:  MOV     W0,[W15++]
13D2:  MOV     #2D,W0
13D4:  MOV     W4,[W15++]
13D6:  MOV     W0,[W15++]
13D8:  MOV     [--W15],W0
13DA:  CALL    9FA
13DE:  MOV     [--W15],W4
13E0:  MOV     [--W15],W0
13E2:  BCLR    W4.8
13E4:  DEC.B   0008
13E6:  CLR     W5
13E8:  MOV     W0,W7
13EA:  MOV     W4,W9
13EC:  BCLR    W4.F
13EE:  CP0.B   W4L
13F0:  BRA     NZ,13FE
13F2:  BTSC    W9.F
13F4:  BRA     13FA
13F6:  MOV     #0,W5
13F8:  BRA     1428
13FA:  MOV     #0,W5
13FC:  BRA     1428
13FE:  BTSS    W9.8
1400:  SUB.B   W4L,#6,W5L
1402:  BTSC    W9.8
1404:  SUB.B   W4L,#7,W5L
1406:  BRA     NC,1426
1408:  MOV     #30,W0
140A:  BTSS    W9.F
140C:  MOV     #20,W0
140E:  MOV     W0,[W15++]
1410:  MOV     W4,[W15++]
1412:  MOV     W0,[W15++]
1414:  MOV     [--W15],W0
1416:  CALL    9FA
141A:  MOV     [--W15],W4
141C:  MOV     [--W15],W0
141E:  DEC     W5,W5
1420:  BRA     NN,140E
1422:  MOV     #5,W5
1424:  BRA     1428
1426:  MOV     W4,W5
1428:  MOV     #6,W4
142A:  BTSC    W5.8
142C:  INC     W4,W4
142E:  BSET    W5.E
1430:  BTSC    W9.F
1432:  BSET    W5.F
1434:  MOV     #2710,W8
1436:  REPEAT  #11
1438:  DIV.U   W7,W8
143A:  CALL    148E
143E:  MOV     W1,W7
1440:  MOV     #3E8,W8
1442:  REPEAT  #11
1444:  DIV.U   W7,W8
1446:  CALL    148E
144A:  MOV     W1,W7
144C:  MOV     #64,W8
144E:  REPEAT  #11
1450:  DIV.U   W7,W8
1452:  CALL    148E
1456:  MOV     W1,W7
1458:  MOV     #A,W8
145A:  REPEAT  #11
145C:  DIV.U   W7,W8
145E:  CALL    148E
1462:  BTSS    W9.8
1464:  BRA     147A
1466:  MOV     #2D,W0
1468:  MOV     W1,[W15++]
146A:  MOV     W4,[W15++]
146C:  MOV     W0,[W15++]
146E:  MOV     [--W15],W0
1470:  CALL    9FA
1474:  MOV     [--W15],W4
1476:  MOV     [--W15],W1
1478:  BCLR    W9.8
147A:  MOV     #30,W0
147C:  ADD.B   W1L,W0L,W0L
147E:  MOV     W0,2A
1480:  MOV     W4,[W15++]
1482:  MOV     W0,[W15++]
1484:  MOV     [--W15],W0
1486:  CALL    9FA
148A:  MOV     [--W15],W4
148C:  BRA     14E2
148E:  MOV     #30,W6
1490:  CP0     W0
1492:  BRA     NZ,14B0
1494:  BTSS    W5.E
1496:  BRA     14CE
1498:  DEC     W4,W4
149A:  CP.B    W4L,W5L
149C:  BRA     Z,14A2
149E:  BTSC.B  42.0
14A0:  RETURN  
14A2:  CP0     W0
14A4:  BRA     NZ,14B0
14A6:  BTSS    W5.E
14A8:  BRA     14CE
14AA:  BTSS    W5.F
14AC:  MOV     #20,W6
14AE:  BRA     14CE
14B0:  BCLR    W5.E
14B2:  BTSS    W9.8
14B4:  BRA     14CE
14B6:  MOV     W0,W10
14B8:  MOV     #2D,W0
14BA:  MOV     W1,[W15++]
14BC:  MOV     W4,[W15++]
14BE:  MOV     W0,[W15++]
14C0:  MOV     [--W15],W0
14C2:  CALL    9FA
14C6:  MOV     [--W15],W4
14C8:  MOV     [--W15],W1
14CA:  BCLR    W9.8
14CC:  MOV     W10,W0
14CE:  ADD.B   W6L,W0L,W0L
14D0:  MOV     W1,[W15++]
14D2:  MOV     W4,[W15++]
14D4:  MOV     W0,[W15++]
14D6:  MOV     [--W15],W0
14D8:  CALL    9FA
14DC:  MOV     [--W15],W4
14DE:  MOV     [--W15],W1
14E0:  RETURN  
14E2:  MOV     #12,W5
14E4:  REPEAT  #3
14E6:  MOV     [--W15],[W5--]
14E8:  MOV     [--W15],W5
14EA:  RETURN  
.................... 
.................... #list
.................... 
.................... #include <Inc/lookup_tables.h>
.................... // lookup table for 16bit timer
.................... //!const int timer_table[] = {
.................... //!1036,1036,1036,1036,1036,1036,1036,1036,1036,1036,
.................... //!1036,1036,1036,1036,1036,1036,1036,1036,1036,1036,
.................... //!1036,1021,1006,992,978,964,950,936,923,910,897,884,
.................... //!871,859,847,835,823,811,799,788,777,766,755,744,733,
.................... //!723,713,703,693,683,673,663,654,645,636,627,618,609,
.................... //!600,591,583,575,567,559,551,543,535,527,519,512,505,
.................... //!498,491,484,477,470,463,456,449,443,437,431,425,419,
.................... //!413,407,401,395,389,383,378,373,368,363,358,353,348,
.................... //!343,338,333,328,323,318,313,309,305,301,297,293,289,
.................... //!285,281,277,273,269,265,261,257,253,249,245, 241,238,
.................... //!235,232,229,226,223,220,217,214,211,208,205,202,199,
.................... //!196,193,190,187,184,181,178,175,172,170,168,166,164,
.................... //!162,160,158,156,154,152,150,148,146,144,142,140,138,
.................... //!136,134,132,130,128,126,124,122,120,118,116,114,112,
.................... //!110,108,106,104,102,101,100,99,98,97,96,95,94,93,92,
.................... //!91,90,89,88,87,86,85,84,83,82,81,80,79,78,77,76,75,
.................... //!74,73,72,71,70,69,68,67,66,65,64,63,62,61,60,59,58,
.................... //!57,56,55,54,53,52,51,50,49,48,47,46,45,44,43,42,41,
.................... //!40,39,38,37,36,35,34,33,33,33,33,33,33,33,33};
.................... 
.................... //!const int freq_table[] = {
.................... //!8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,17,17,18,18,19,19,20,
.................... //!20,21,21,22,22,23,23,24,24,25,25,26,27,27,28,28,29,29,30,30,31,31,32,32,33,34,34,35,35,36,36,37,
.................... //!37,38,39,39,40,40,41,41,42,42,43,44,44,45,45,46,46,47,48,48,49,49,50,50,51,52,52,53,53,54,55,55,
.................... //!56,56,57,58,58,59,60,60,61,61,62,63,63,64,65,65,66,67,67,68,69,69,70,71,71,72,73,73,74,75,75,76,
.................... //!77,78,78,79,80,81,81,82,83,84,84,85,86,87,87,88,89,90,91,92,92,93,94,95,96,97,98,98,99,100,101,102,
.................... //!103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,121,122,123,124,125,126,128,129,
.................... //!130,131,133,134,135,137,138,140,141,142,144,145,147,148,150,151,153,155,156,158,160,161,163,165,166,
.................... //!168,170,172,174,176,178,180,182,184,186,188,190,193,195,197,199,202,204,207,209,212,214,217,220,222,
.................... //!225,228,231,234,237,240,243,246,250
.................... //!};
.................... 
.................... //!
.................... //!const int ascend_speed_table[] = {
.................... //!23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,26,26,30,30,33,33,36,36,39,39,
.................... //!42,42,45,45,48,51,51,54,54,57,57,60,60,63,63,66,66,69,69,73,73,76,76,79,82,82,85,85,88,88,91,91,94,
.................... //!94,97,97,100,103,103,106,106,109,109,112,112,116,119,119,122,122,125,125,128,128,131,134,134,137,137,
.................... //!140,140,143,146,146,149,149,152,152,155,159,159,162,162,165,168,168,171,171,174,177,177,180,183,183,
.................... //!186,186,189,192,192,195,198,198,202,205,205,208,211,211,214,217,217,220,223,223,226,229,229,232,235,
.................... //!238,238,241,245,248,248,251,254,257,257,260,263,266,266,269,272,275,278,281,281,284,288,291,294,297,
.................... //!300,300,303,306,309,312,315,318,321,324,327,331,334,337,340,343,346,349,352,355,358,361,364,370,374,
.................... //!377,380,383,386,392,395,398,401,407,410,413,420,423,429,432,435,441,444,450,453,459,463,469,475,478,
.................... //!484,490,493,499,506,509,515,521,527,533,539,545,552,558,564,570,576,582,592,598,604,610,619,625,635,
.................... //!641,650,656,665,674,681,690,699,708,717,727,736,745,754,767
.................... //!};
.................... //!
.................... //!
.................... //!const int ascend_speed_table[] = 
.................... //!{
.................... //!0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,23,26,26,29,29,32,32,34,34,37,37,40,40,43,43,46,49,49,51,
.................... //!51,54,54,57,57,60,60,63,63,66,66,68,68,71,71,74,77,77,80,80,83,83,86,86,88,88,91,91,95,97,97,100,100,
.................... //!103,103,105,105,108,112,112,114,114,117,117,120,120,122,126,126,129,129,131,131,134,137,137,140,140,
.................... //!143,143,146,149,149,151,151,154,157,157,160,160,163,166,166,168,171,171,174,174,177,180,180,183,185,
.................... //!185,188,191,191,194,197,197,200,203,203,205,208,208,212,214,214,217,220,222,222,226,229,231,231,234,
.................... //!237,239,239,243,246,248,248,251,254,257,260,263,263,266,268,271,274,277,280,280,283,285,288,291,294,
.................... //!297,300,302,305,308,311,314,317,320,322,325,329,331,334,337,339,346,348,351,354,356,360,365,368,371,
.................... //!374,380,383,385,391,394,400,402,405,411,414,419,422,428,431,437,442,446,451,456,460,465,471,473,480,
.................... //!485,491,497,502,508,514,519,525,531,536,542,551,556,563,568,577,582,590,597,605,611,619,628,634,642,
.................... //!651,659,668,677,685,694,702,714
.................... //!};
.................... //!
.................... const int ascend_speed_table[] = 
.................... {
.................... 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,23,26,27,29,30,32,33,34,35,37,38,40,41,43,44,46,49,50,51,
.................... 52,54,55,57,58,60,61,63,64,66,67,68,69,71,72,74,77,79,80,81,83,84,86,87,88,89,91,93,95,97,98,100,101,
.................... 103,104,105,106,108,112,113,114,116,117,118,120,121,122,126,127,129,130,131,132,134,137,138,140,141,
.................... 143,144,146,149,150,151,152,154,157,158,160,161,163,166,167,168,171,172,174,175,177,180,181,183,185,
.................... 186,188,191,193,194,197,198,200,203,204,205,208,210,212,214,215,217,220,222,225,226,229,231,233,234,
.................... 237,239,241,243,246,248,249,251,254,257,260,263,265,266,268,271,274,277,280,282,283,285,288,291,294,
.................... 297,300,302,305,308,311,314,317,320,322,325,329,331,334,337,339,346,348,351,354,356,360,365,368,371,
.................... 374,380,383,385,391,394,400,402,405,411,414,419,422,428,431,437,442,446,451,456,460,465,471,473,480,
.................... 485,491,497,502,508,514,519,525,531,536,542,551,556,563,568,577,582,590,597,605,611,619,628,634,642,
.................... 651,659,668,677,685,694,702,714
.................... };
.................... 
.................... const int descend_speed_table[] = 
.................... {
.................... 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,25,29,29,32,32,35,35,37,37,41,41,44,44,47,47,51,54,54,56,
.................... 56,59,59,63,63,66,66,69,69,73,73,75,75,78,78,81,85,85,88,88,91,91,95,95,97,97,100,100,105,107,107,
.................... 110,110,113,113,116,116,119,123,123,125,125,129,129,132,132,134,139,139,142,142,144,144,147,151,151,
.................... 154,154,157,157,161,164,164,166,166,169,173,173,176,176,179,183,183,185,188,188,191,191,195,198,198,
.................... 201,204,204,207,210,210,213,217,217,220,223,223,226,229,229,233,235,235,239,242,244,244,249,252,254,
.................... 254,257,261,263,263,267,271,273,273,276,279,283,286,289,289,293,295,298,301,305,308,308,311,314,317,
.................... 320,323,327,330,332,336,339,342,345,349,352,354,358,362,364,367,371,373,381,383,386,389,392,396,402,
.................... 405,408,411,418,421,424,430,433,440,442,446,452,455,461,464,471,474,481,486,491,496,502,506,512,518,
.................... 520,528,534,540,547,552,559,565,571,578,584,590,596,606,612,619,625,635,640,649,657,666,672,681,691,
.................... 697,706,716,725,735,745,754,763,772,785
.................... 
.................... };
.................... 
.................... const int timer_table[] = {
.................... 65068,65068,65068,65068,65068,65068,65068,65068,65068,65068,65068,65068,65068,65068,65068,65068,
.................... 65068,65068,65068,65068,65068,61218,57795,54733,51977,49484,47217,45148,43251,41505,39894,38402,
.................... 37016,35726,34522,33395,32339,31346,30412,29531,28699,27912,27165,26458,25785,25145,24535,23954,
.................... 23399,22868,22360,21874,21408,20961,20531,20118,19721,19339,18971,18616,18273,17943,17624,17315,
.................... 17017,16728,16448,16177,15915,15660,15413,15173,14940,14714,14494,14280,14072,13869,13672,13480,
.................... 13292,13110,12932,12758,12589,12423,12262,12104,11950,11799,11652,11508,11367,11229,11094,10962,
.................... 10832,10705,10581,10459,10340,10223,10108,9995,9884,9776,9669,9564,9461,9360,9261,9163,9067,8973,
.................... 8880,8789,8699,8611,8523,8438,8353,8270,8188,8108,8028,7950,7873,7796,7721,7647,7574,7502,7431,7361,
.................... 7291,7223,7155,7089,7023,6958,6893,6830,6767,6705,6643,6582,6522,6463,6404,6346,6289,6232,6175,6120,
.................... 6064,6010,5955,5902,5849,5796,5744,5692,5641,5590,5540,5490,5441,5392,5343,5295,5247,5200,5153,5106,
.................... 5059,5013,4968,4923,4878,4833,4789,4745,4701,4657,4614,4572,4529,4487,4445,4403,4362,4321,4280,4239,
.................... 4199,4159,4119,4079,4040,4000,3961,3923,3884,3846,3808,3770,3732,3695,3658,3621,3584,3547,3511,3475,
.................... 3439,3403,3368,3332,3297,3262,3227,3193,3158,3124,3090,3056,3023,2989,2956,2923,2890,2858,2825,2793,
.................... 2761,2729,2697,2666,2634,2603,2572,2542,2511,2481,2451,2421,2391,2361,2332,2303,2274,2245,2217,2188,
.................... 2160,2132};
.................... 
.................... const unsigned int16 gain_table[256] = {
.................... 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,85,85,85,86,
.................... 86,86,86,86,86,87,87,87,87,87,88,88,88,88,88,89,89,
.................... 89,89,90,90,90,90,91,91,91,91,92,92,92,92,93,93,93,
.................... 94,94,94,95,95,95,95,96,96,96,97,97,97,98,98,98,99,
.................... 99,100,100,101,101,101,102,102,102,103,103,104,104,
.................... 105,105,106,106,106,107,107,108,108,109,110,110,111,
.................... 111,112,112,113,113,114,114,115,116,116,117,117,118,
.................... 119,120,120,121,122,122,123,124,125,125,126,127,127,
.................... 128,129,130,130,131,132,133,134,135,136,137,138,139,
.................... 140,141,142,143,144,145,146,147,148,149,150,151,152,
.................... 153,154,155,156,157,158,159,161,162,163,164,166,167,
.................... 169,170,172,173,175,177,178,180,182,184,186,188,191,
.................... 193,194,195,196,198,199,200,201,203,204,206,207,209,
.................... 210,212,213,215,216,218,220,222,223,225,227,229,231,
.................... 233,235,237,240,242,244,247,249,252,254,257,260,263,
.................... 266,269,272,275,279,282,286,289,293,297,301,306,310,
.................... 315,320,325,330,335,341,347,353,360,367,374,381,389,
.................... 397,406,415,425,436,436,436,436,436,436,436,436
.................... };
.................... 
.................... #DEVICE ADC=10
.................... #device ICSP=1
.................... #use delay(clock=64000000,crystal=8000000)
.................... #use rs232(UART1, baud=57600, RECEIVE_BUFFER=100 , stream=UART_PORT1)
.................... 
.................... #FUSES NOWDT                    //No Watch Dog Timer
.................... #FUSES CKSFSM                   //Clock Switching is enabled, fail Safe clock monitor is enabled
.................... #FUSES BORV42                   //Brownout reset at 4.5V
.................... #FUSES WRT                      //Program Memory Write Protected
.................... #FUSES PROTECT                  //Code protected from reads
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float32)(unsigned int16)y;
.................... 
....................  else if (y < 10000000.0)
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
....................       res = 32768.0*(float32)l;
....................       res += (float32)(unsigned int16)y;
....................    }
.................... 
....................  else
....................   res = y;
.................... 
....................  y = y - (float32)(unsigned int16)y;
.................... 
....................  if (s)
....................   res = -res;
.................... 
....................  if (y != 0)
....................  {
....................   if (s == 1 && n == 0)
....................    res -= 1.0;
.................... 
....................   if (s == 0 && n == 1)
....................    res += 1.0;
....................  }
....................  if (x == 0)
....................     res = 0;
.................... 
....................  return (res);
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl[0]*y2 + pl[1];
.................... 
....................       r = ql[0]*y2 + ql[1];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
....................          r = -(float32)-n;
....................       else
....................          r = (float32)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
*
0FB2:  MOV     W5,[W15++]
0FB4:  MOV     W6,[W15++]
0FB6:  MOV     W7,[W15++]
0FB8:  MOV     W8,[W15++]
0FBA:  CLR     A52
0FBC:  CLR     A54
0FBE:  CLR     A56
0FC0:  MOV     #3FF0,W4
0FC2:  MOV     W4,A58
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
0FC4:  MOV     #FF1F,W4
0FC6:  MOV     W4,A62
0FC8:  SETM    A64
0FCA:  SETM    A66
0FCC:  MOV     #BFDF,W4
0FCE:  MOV     W4,A68
0FD0:  MOV     #1C35,W4
0FD2:  MOV     W4,A6A
0FD4:  MOV     #5555,W4
0FD6:  MOV     W4,A6C
0FD8:  MOV     #5555,W4
0FDA:  MOV     W4,A6E
0FDC:  MOV     #3FA5,W4
0FDE:  MOV     W4,A70
0FE0:  MOV     #3F1C,W4
0FE2:  MOV     W4,A72
0FE4:  MOV     #16A7,W4
0FE6:  MOV     W4,A74
0FE8:  MOV     #C16C,W4
0FEA:  MOV     W4,A76
0FEC:  MOV     #BF56,W4
0FEE:  MOV     W4,A78
0FF0:  MOV     #F3E6,W4
0FF2:  MOV     W4,A7A
0FF4:  MOV     #D65,W4
0FF6:  MOV     W4,A7C
0FF8:  MOV     #1A0,W4
0FFA:  MOV     W4,A7E
0FFC:  MOV     #3EFA,W4
0FFE:  MOV     W4,A80
1000:  MOV     #A3E,W4
1002:  MOV     W4,A82
1004:  MOV     #3931,W4
1006:  MOV     W4,A84
1008:  MOV     #7E4C,W4
100A:  MOV     W4,A86
100C:  MOV     #BE92,W4
100E:  MOV     W4,A88
1010:  MOV     #DDFB,W4
1012:  MOV     W4,A8A
1014:  MOV     #2B77,W4
1016:  MOV     W4,A8C
1018:  MOV     #EDB1,W4
101A:  MOV     W4,A8E
101C:  MOV     #3E21,W4
101E:  MOV     W4,A90
1020:  MOV     #6FCC,W4
1022:  MOV     W4,A92
1024:  MOV     #8FF7,W4
1026:  MOV     W4,A94
1028:  MOV     #C610,W4
102A:  MOV     W4,A96
102C:  MOV     #BDA8,W4
102E:  MOV     W4,A98
1030:  MOV     #124C,W4
1032:  MOV     W4,A9A
1034:  MOV     #8E1C,W4
1036:  MOV     W4,A9C
1038:  MOV     #3AF9,W4
103A:  MOV     W4,A9E
103C:  MOV     #3CF3,W4
103E:  MOV     W4,AA0
1040:  MOV     #7676,W4
1042:  MOV     W4,AA2
1044:  MOV     #350F,W4
1046:  MOV     W4,AA4
1048:  MOV     #C0DE,W4
104A:  MOV     W4,AA6
104C:  MOV     #3CF0,W4
104E:  MOV     W4,AA8
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
1050:  MOV     A38,W0
1052:  MOV     A3A,W1
1054:  MOV     A3C,W2
1056:  MOV     A3E,W3
1058:  MOV     #0,W4
105A:  MOV     #0,W5
105C:  MOV     #0,W6
105E:  MOV     #0,W7
1060:  CALL    ED0
1064:  BRA     NC,1070
1066:  MOV     #A38,W0
1068:  MOV     #A38,W1
106A:  REPEAT  #7
106C:  MOV     [W0++],[W1++]
106E:  BTG.B   A3F.7
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
1070:  MOV     A38,W0
1072:  MOV     A3A,W1
1074:  MOV     A3C,W2
1076:  MOV     A3E,W3
1078:  MOV     #C884,W4
107A:  MOV     #6DC9,W5
107C:  MOV     #5F30,W6
107E:  MOV     #3FE4,W7
1080:  CALL    ACA
1084:  CALL    F54
1088:  MOV.B   W0L,A40
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
108A:  MOV     A38,W0
108C:  MOV     A3A,W1
108E:  MOV     A3C,W2
1090:  MOV     A3E,W3
1092:  MOV     #C884,W4
1094:  MOV     #6DC9,W5
1096:  MOV     #5F30,W6
1098:  MOV     #3FE4,W7
109A:  CALL    ACA
109E:  MOV     W0,W5
10A0:  MOV     W1,W6
10A2:  MOV     W2,W7
10A4:  MOV     W3,W8
10A6:  MOV     #0,W1
10A8:  MOV     #0,W2
10AA:  MOV     #0,W3
10AC:  MOV.B   A40,W0L
10AE:  CLR.B   1
10B0:  CALL    A60
10B4:  BSET.B  43.0
10B6:  MOV     W5,[W15++]
10B8:  MOV     W6,[W15++]
10BA:  MOV     W7,[W15++]
10BC:  MOV     W0,W4
10BE:  MOV     W5,W0
10C0:  MOV     W1,W5
10C2:  MOV     W6,W1
10C4:  MOV     W2,W6
10C6:  MOV     W7,W2
10C8:  MOV     W3,W7
10CA:  MOV     W8,W3
10CC:  CALL    CE2
10D0:  MOV     [--W15],W7
10D2:  MOV     [--W15],W6
10D4:  MOV     [--W15],W5
10D6:  MOV     W0,A5A
10D8:  MOV     W1,A5C
10DA:  MOV     W2,A5E
10DC:  MOV     W3,A60
....................    quad = quad % 4;                    // quadrant (0 to 3)
10DE:  MOV.B   A40,W0L
10E0:  AND.B   W0L,#3,W0L
10E2:  MOV.B   W0L,A40
.................... 
....................    if (quad == 0 || quad == 2)
10E4:  CP0.B   A40
10E6:  BRA     Z,10EE
10E8:  MOV     A40,W4
10EA:  CP.B    W4L,#2
10EC:  BRA     NZ,110C
....................       t = frac * PI_DIV_BY_TWO;
10EE:  MOV     A5A,W0
10F0:  MOV     A5C,W1
10F2:  MOV     A5E,W2
10F4:  MOV     A60,W3
10F6:  MOV     #2D18,W4
10F8:  MOV     #5444,W5
10FA:  MOV     #21FB,W6
10FC:  MOV     #3FF9,W7
10FE:  CALL    ACA
1102:  MOV     W0,A4A
1104:  MOV     W1,A4C
1106:  MOV     W2,A4E
1108:  MOV     W3,A50
110A:  BRA     11A0
....................    else if (quad == 1)
110C:  MOV     A40,W4
110E:  CP.B    W4L,#1
1110:  BRA     NZ,115A
....................       t = (1-frac) * PI_DIV_BY_TWO;
1112:  BSET.B  43.0
1114:  MOV     #0,W0
1116:  MOV     #0,W1
1118:  MOV     #0,W2
111A:  MOV     #3FF0,W3
111C:  MOV     A5A,W4
111E:  MOV     A5C,W5
1120:  MOV     A5E,W6
1122:  MOV     A60,W7
1124:  CALL    CE2
1128:  MOV     W0,W5
112A:  MOV     W1,W6
112C:  MOV     W2,W7
112E:  MOV     W3,W8
1130:  MOV     W5,[W15++]
1132:  MOV     W6,[W15++]
1134:  MOV     W7,[W15++]
1136:  MOV     W5,W0
1138:  MOV     W6,W1
113A:  MOV     W7,W2
113C:  MOV     W8,W3
113E:  MOV     #2D18,W4
1140:  MOV     #5444,W5
1142:  MOV     #21FB,W6
1144:  MOV     #3FF9,W7
1146:  CALL    ACA
114A:  MOV     [--W15],W7
114C:  MOV     [--W15],W6
114E:  MOV     [--W15],W5
1150:  MOV     W0,A4A
1152:  MOV     W1,A4C
1154:  MOV     W2,A4E
1156:  MOV     W3,A50
1158:  BRA     11A0
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
115A:  BSET.B  43.0
115C:  MOV     A5A,W0
115E:  MOV     A5C,W1
1160:  MOV     A5E,W2
1162:  MOV     A60,W3
1164:  MOV     #0,W4
1166:  MOV     #0,W5
1168:  MOV     #0,W6
116A:  MOV     #3FF0,W7
116C:  CALL    CE2
1170:  MOV     W0,W5
1172:  MOV     W1,W6
1174:  MOV     W2,W7
1176:  MOV     W3,W8
1178:  MOV     W5,[W15++]
117A:  MOV     W6,[W15++]
117C:  MOV     W7,[W15++]
117E:  MOV     W5,W0
1180:  MOV     W6,W1
1182:  MOV     W7,W2
1184:  MOV     W8,W3
1186:  MOV     #2D18,W4
1188:  MOV     #5444,W5
118A:  MOV     #21FB,W6
118C:  MOV     #3FF9,W7
118E:  CALL    ACA
1192:  MOV     [--W15],W7
1194:  MOV     [--W15],W6
1196:  MOV     [--W15],W5
1198:  MOV     W0,A4A
119A:  MOV     W1,A4C
119C:  MOV     W2,A4E
119E:  MOV     W3,A50
.................... 
....................    y = 1.0;
11A0:  CLR     A42
11A2:  CLR     A44
11A4:  CLR     A46
11A6:  MOV     #3FF0,W4
11A8:  MOV     W4,A48
....................    t = t * t;
11AA:  MOV     A4A,W0
11AC:  MOV     A4C,W1
11AE:  MOV     A4E,W2
11B0:  MOV     A50,W3
11B2:  MOV     A4A,W4
11B4:  MOV     A4C,W5
11B6:  MOV     A4E,W6
11B8:  MOV     A50,W7
11BA:  CALL    ACA
11BE:  MOV     W0,A4A
11C0:  MOV     W1,A4C
11C2:  MOV     W2,A4E
11C4:  MOV     W3,A50
....................    for (i = 0; i <= 8; i++)
11C6:  CLR.B   A41
11C8:  MOV     A40,W4
11CA:  LSR     W4,#8,W4
11CC:  CP.B    W4L,#8
11CE:  BRA     GTU,1232
....................    {
....................       t2 = t2 * t;
11D0:  MOV     A52,W0
11D2:  MOV     A54,W1
11D4:  MOV     A56,W2
11D6:  MOV     A58,W3
11D8:  MOV     A4A,W4
11DA:  MOV     A4C,W5
11DC:  MOV     A4E,W6
11DE:  MOV     A50,W7
11E0:  CALL    ACA
11E4:  MOV     W0,A52
11E6:  MOV     W1,A54
11E8:  MOV     W2,A56
11EA:  MOV     W3,A58
....................       y = y + p_64[i] * t2;
11EC:  MOV.B   A41,W0L
11EE:  CLR.B   1
11F0:  SL      W0,#3,W0
11F2:  MOV     #A62,W4
11F4:  ADD     W0,W4,W0
11F6:  MOV     W0,W5
11F8:  MOV     W5,[W15++]
11FA:  MOV     [W5],W0
11FC:  MOV     [++W5],W1
11FE:  MOV     [++W5],W2
1200:  MOV     [++W5],W3
1202:  MOV     A52,W4
1204:  MOV     A54,W5
1206:  MOV     A56,W6
1208:  MOV     A58,W7
120A:  CALL    ACA
120E:  MOV     [--W15],W5
1210:  BCLR.B  43.0
1212:  MOV     W0,W4
1214:  MOV     W1,W5
1216:  MOV     W2,W6
1218:  MOV     W3,W7
121A:  MOV     A42,W0
121C:  MOV     A44,W1
121E:  MOV     A46,W2
1220:  MOV     A48,W3
1222:  CALL    CE2
1226:  MOV     W0,A42
1228:  MOV     W1,A44
122A:  MOV     W2,A46
122C:  MOV     W3,A48
122E:  INC.B   0A41
1230:  BRA     11C8
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
1232:  MOV     A40,W4
1234:  CP.B    W4L,#2
1236:  BRA     Z,123E
1238:  MOV     A40,W4
123A:  CP.B    W4L,#1
123C:  BRA     NZ,1248
....................       y = -y;  // correct sign
123E:  MOV     #A42,W0
1240:  MOV     #A42,W1
1242:  REPEAT  #7
1244:  MOV     [W0++],[W1++]
1246:  BTG.B   A49.7
.................... 
....................    return (y);
1248:  MOV     A42,W0
124A:  MOV     A44,W1
124C:  MOV     A46,W2
124E:  MOV     A48,W3
1250:  MOV     [--W15],W8
1252:  MOV     [--W15],W7
1254:  MOV     [--W15],W6
1256:  MOV     [--W15],W5
1258:  RETURN  
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
125A:  MOV     W5,[W15++]
125C:  MOV     W6,[W15++]
125E:  MOV     W7,[W15++]
1260:  MOV     W8,[W15++]
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
1262:  BSET.B  43.0
1264:  MOV     A28,W0
1266:  MOV     A2A,W1
1268:  MOV     A2C,W2
126A:  MOV     A2E,W3
126C:  MOV     #2D18,W4
126E:  MOV     #5444,W5
1270:  MOV     #21FB,W6
1272:  MOV     #3FF9,W7
1274:  CALL    CE2
1278:  MOV     W0,W5
127A:  MOV     W1,W6
127C:  MOV     W2,W7
127E:  MOV     W3,W8
1280:  MOV     W5,A38
1282:  MOV     W6,A3A
1284:  MOV     W7,A3C
1286:  MOV     W8,A3E
1288:  CALL    FB2
128C:  MOV     [--W15],W8
128E:  MOV     [--W15],W7
1290:  MOV     [--W15],W6
1292:  MOV     [--W15],W5
1294:  RETURN  
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... #include <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];
....................             c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
....................        result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #ifndef __PCB__
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
....................    goto StrtoulGO;
.................... 
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(; sd!=0; )
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtoulGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
....................    }
....................    if (endptr)
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... #endif
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #define clock_freq 64000000
.................... 
.................... #define P1TCON    0x01C0
.................... #define P1TMR     0x01C2 
.................... #define P1TPER    0x01C4
.................... #define P1SECMP   0x01C6
.................... #define PWM1CON1  0x01C8 
.................... #define PWM1CON2  0x01CA
.................... #define P1DTCON1  0x01CC
.................... #define P1DTCON2  0x01CE  
.................... #define P1FLTACON 0x01D0
.................... #define P1OVDCON  0x01D4     
.................... #define P1DC1     0x01D6   
.................... #define P1DC2     0x01D8
.................... #define P1DC3     0x01DA
.................... #define IPC14     0x00C0  
.................... #define CLKDIV    0x0744 
.................... #define PLLFBD    0x0746
.................... 
.................... 
.................... /*------------QUADRATURE ENCODER REGISTERS-------------------*/
.................... #define QEICON  0x0122       // Control Status Register.
.................... #define DFLTCON 0x0124      // Digital Filter Control Register.
.................... #define POSCNT  0x0126     // Position Count Register.
.................... #define MAXCNT  0x0128    // Maximum Count Register.
.................... #define ADPCFG  0x02A8   // Encoder Multiplexed pins.
.................... #define IEC2    0x0090  // for enabling the QE interrupt.
.................... #define IPC10   0x00A8 // QEI interrupt priority Register.
.................... 
.................... #define UPDN 3       // Direction testing flag.
.................... /*------------QUADRATURE ENCODER REGISTERS-------------------*/
.................... 
.................... #define TIM_OVERFLOW_VAL 65535
.................... #define U1TXREG   0x0210
.................... #define U1BRG     0x0214
.................... 
.................... #define ADC_pin sAN1
.................... #define LED_PIN PIN_C13
.................... 
.................... #define voltage_offset 1000//1248
.................... #define low_duty_limit 50
.................... #define high_duty_limit 1950
.................... #define SLOPE 0
.................... 
.................... #define break_level 5
.................... #define sustain_level 200  
.................... #define break_amplitude 0 
.................... 
.................... #define pedestal_amplitude 500
.................... #define peak_amplitude 950
.................... 
.................... 
.................... #define throttle_PIN PIN_B1
.................... #define PWM_tick_pin PIN_B2
.................... #define TIM_tick_pin PIN_B3
.................... #define ENC_TICK_PIN PIN_B0
.................... 
.................... #define init_freq 30
.................... 
....................  
....................   
.................... void initMCPWM(void);
.................... void fill_sine_table(void);  
.................... int1 QEI_get_direction(void); 
.................... void uart1_write (char*, unsigned int);
.................... int16 baud_rate_calc (unsigned int32 baud_rate);
.................... 
.................... unsigned int16 duty[3]={voltage_offset,voltage_offset,voltage_offset},sample=0;
.................... signed int16 peak_voltage =0;//  1184; 
.................... signed int32 reference[3] = {0,0,0};
.................... 
.................... const unsigned max_samples=30.0;
.................... signed int16 sine_table[max_samples];
.................... unsigned int16 sine_index,phase_angle[3] = {0 , 0 , 0};  
.................... double theeta;
.................... 
.................... const unsigned max_freq = 250; //Hz
.................... 
.................... unsigned int16 raw_adc =0 ;
.................... signed int16 throttle_level = 0;
.................... unsigned int16 freq = 1;
.................... unsigned int16 temp = 0;
.................... 
.................... int32 position_count = 0;
.................... int32 prev_count = 0;
.................... int32 enc_count = 0;
.................... int32 position_count_new = 0;
.................... int1 direction_flag = 0;
.................... unsigned int16 position_capture = 0;
.................... unsigned int16 speed_capture = 0;
.................... 
.................... int1 tick = 0;
.................... int1 enc_tick = 0;
.................... int1 uart_tick = 0;
.................... int8 tick_count = 0;
.................... unsigned long millis_count = 0;
.................... unsigned long uart_millis = 0;
.................... 
.................... char Serial_OutputBuffer[100];
.................... 
.................... unsigned int16 ascending_speed , descending_speed , attained_speed ,attained_throttle, loaded_speed;  
.................... 
.................... int1 descend_flag = 0;
.................... int1 ascend_flag = 0;
.................... unsigned int8 val = 0;
.................... signed int32 kalman_big_1=0, kalman_big_2=0, kalman_diff=0;
.................... 
.................... static int1 enc_mutx = 0;
.................... #int_PWM1
.................... void  PWM1_isr(void) 
*
0742:  PUSH    42
0744:  PUSH    36
0746:  PUSH    32
0748:  MOV     W0,[W15++]
074A:  MOV     #2,W0
074C:  REPEAT  #C
074E:  MOV     [W0++],[W15++]
.................... {
.................... 
....................    tick_count++;
0750:  INC.B   0999
....................    if(tick_count >= 8)
0752:  MOV     998,W4
0754:  LSR     W4,#8,W4
0756:  CP.B    W4L,#8
0758:  BRA     LT,76A
....................    {     
....................       millis_count++;
075A:  INC     099E
075C:  BTSC.B  42.1
075E:  INC     09A0
....................       uart_millis++;
0760:  INC     09A2
0762:  BTSC.B  42.1
0764:  INC     09A4
....................       tick = 1;
0766:  BSET.B  998.1
....................       
....................       tick_count=0;
0768:  CLR.B   999
....................    
....................    }
....................    if (uart_millis >= 10) 
076A:  MOV     9A4,W4
076C:  CP      W4,#0
076E:  BRA     NC,77E
0770:  BRA     GTU,778
0772:  MOV     9A2,W4
0774:  CP      W4,#A
0776:  BRA     NC,77E
....................    {
.................... //!      output_toggle(LED_PIN);
....................       uart_tick = 1;
0778:  BSET.B  998.3
....................       uart_millis = 0;
077A:  CLR     9A2
077C:  CLR     9A4
....................       
....................    
....................    }
....................    if (millis_count >= 100) {
077E:  MOV     9A0,W4
0780:  CP      W4,#0
0782:  BRA     NC,794
0784:  BRA     GTU,78E
0786:  MOV     99E,W4
0788:  MOV     #64,W3
078A:  CP      W3,W4
078C:  BRA     GTU,794
....................       enc_tick = 1;
078E:  BSET.B  998.2
....................       
....................       millis_count = 0;
0790:  CLR     99E
0792:  CLR     9A0
....................       
....................    }  
....................   
.................... 
.................... }
.................... 
0794:  BCLR.B  88.7
0796:  MOV     #1A,W0
0798:  REPEAT  #C
079A:  MOV     [--W15],[W0--]
079C:  MOV     [--W15],W0
079E:  POP     32
07A0:  POP     36
07A2:  POP     42
07A4:  RETFIE  
.................... #INT_TIMER3
.................... void  timer3_isr(void) 
*
07E8:  PUSH    42
07EA:  PUSH    36
07EC:  PUSH    32
07EE:  MOV     W0,[W15++]
07F0:  MOV     #2,W0
07F2:  REPEAT  #C
07F4:  MOV     [W0++],[W15++]
.................... {
....................  
....................    sample = (sample+1)%max_samples;
07F6:  MOV     924,W4
07F8:  ADD     W4,#1,W5
07FA:  MOV     #1E,W4
07FC:  REPEAT  #11
07FE:  DIV.U   W5,W4
0800:  MOV     W1,924
....................    phase_angle[0] = sample;
0802:  PUSH    924
0804:  POP     972
....................    phase_angle[1] = (sample+10)%max_samples;
0806:  MOV     924,W4
0808:  ADD     W4,#A,W5
080A:  MOV     #1E,W4
080C:  REPEAT  #11
080E:  DIV.U   W5,W4
0810:  MOV     W1,974
....................    phase_angle[2] = (sample+20)%max_samples; 
0812:  MOV     924,W4
0814:  ADD     W4,#14,W5
0816:  MOV     #1E,W4
0818:  REPEAT  #11
081A:  DIV.U   W5,W4
081C:  MOV     W1,976
.................... 
....................    for (int i = 0 ; i < 3 ; i++) {
081E:  CLR     AEA
0820:  MOV     AEA,W4
0822:  CP      W4,#3
0824:  BRA     GE,9BC
....................       
....................       reference[i] = sine_table[phase_angle[i]];
0826:  MOV     AEA,W4
0828:  MUL.UU  W4,#4,W0
082A:  MOV     #928,W4
082C:  ADD     W0,W4,W5
082E:  MOV     AEA,W4
0830:  MUL.UU  W4,#2,W0
0832:  MOV     #972,W4
0834:  ADD     W0,W4,W0
0836:  MOV     [W0],W6
0838:  SL      W6,#1,W0
083A:  MOV     #934,W4
083C:  ADD     W0,W4,W0
083E:  MOV     W0,W4
0840:  MOV     [W4],W0
0842:  CLR     W1
0844:  BTSC    W0.F
0846:  SETM    W1
0848:  MOV     #0,W4
084A:  MOV     [W4++],[W5++]
084C:  MOV     [W4++],[W5++]
....................       reference[i] = reference[i] * peak_voltage; 
084E:  MOV     AEA,W4
0850:  MUL.UU  W4,#4,W0
0852:  MOV     #928,W4
0854:  ADD     W0,W4,W5
0856:  MOV     AEA,W4
0858:  MUL.UU  W4,#4,W0
085A:  MOV     #928,W4
085C:  ADD     W0,W4,W0
085E:  MOV     #C,W4
0860:  MOV     [W0++],[W4++]
0862:  MOV     [W0++],[W4++]
0864:  MOV     926,W0
0866:  CLR     W1
0868:  BTSC    W0.F
086A:  SETM    W1
086C:  MOV     W0,W2
086E:  MOV     W1,W3
0870:  MOV     W6,W0
0872:  MOV     W7,W1
0874:  CALL    7A6
0878:  MOV     #0,W4
087A:  MOV     [W4++],[W5++]
087C:  MOV     [W4++],[W5++]
....................       if( reference[i] > 0)
087E:  MOV     AEA,W4
0880:  MUL.UU  W4,#4,W0
0882:  MOV     #928,W4
0884:  ADD     W0,W4,W0
0886:  MOV     #A,W4
0888:  MOV     [W0++],[W4++]
088A:  MOV     [W0++],[W4++]
088C:  CP      W6,#0
088E:  BRA     LT,8BC
0890:  BRA     GT,896
0892:  CP      W5,#0
0894:  BRA     LEU,8BC
....................       {
....................          reference[i] = reference[i] >> 8; 
0896:  MOV     AEA,W4
0898:  MUL.UU  W4,#4,W0
089A:  MOV     #928,W4
089C:  ADD     W0,W4,W5
089E:  MOV     AEA,W4
08A0:  MUL.UU  W4,#4,W0
08A2:  MOV     #928,W4
08A4:  ADD     W0,W4,W0
08A6:  MOV     #C,W4
08A8:  MOV     [W0++],[W4++]
08AA:  MOV     [W0++],[W4++]
08AC:  MOV.B   D,W0L
08AE:  MOV.B   W0L,[W5]
08B0:  MOV.B   W7L,[W5+#1]
08B2:  MOV.B   F,W0L
08B4:  MOV.B   W0L,[W5+#2]
08B6:  MOV.B   #0,W0L
08B8:  MOV.B   W0L,[W5+#3]
....................       }
08BA:  BRA     938
....................       else if( reference[i] < 0)
08BC:  MOV     AEA,W4
08BE:  MUL.UU  W4,#4,W0
08C0:  MOV     #928,W4
08C2:  ADD     W0,W4,W0
08C4:  MOV     #A,W4
08C6:  MOV     [W0++],[W4++]
08C8:  MOV     [W0++],[W4++]
08CA:  CP      W6,#0
08CC:  BRA     GT,938
08CE:  BRA     LT,8D4
08D0:  CP      W5,#0
08D2:  BRA     C,938
....................       {
....................          reference[i] = 0 - reference[i];
08D4:  MOV     AEA,W4
08D6:  MUL.UU  W4,#4,W0
08D8:  MOV     #928,W4
08DA:  ADD     W0,W4,W5
08DC:  MOV     AEA,W4
08DE:  MUL.UU  W4,#4,W0
08E0:  MOV     #928,W4
08E2:  ADD     W0,W4,W0
08E4:  MOV     W0,W4
08E6:  MOV     #0,W3
08E8:  MOV     [W4++],[W3++]
08EA:  MOV     [W4++],[W3++]
08EC:  MOV     #0,W4
08EE:  SUB     W4,W0,[W5]
08F0:  MOV     #0,W4
08F2:  SUBB    W4,W1,[++W5]
....................          reference[i] = reference[i] >> 8;
08F4:  MOV     AEA,W4
08F6:  MUL.UU  W4,#4,W0
08F8:  MOV     #928,W4
08FA:  ADD     W0,W4,W5
08FC:  MOV     AEA,W4
08FE:  MUL.UU  W4,#4,W0
0900:  MOV     #928,W4
0902:  ADD     W0,W4,W0
0904:  MOV     #C,W4
0906:  MOV     [W0++],[W4++]
0908:  MOV     [W0++],[W4++]
090A:  MOV.B   D,W0L
090C:  MOV.B   W0L,[W5]
090E:  MOV.B   W7L,[W5+#1]
0910:  MOV.B   F,W0L
0912:  MOV.B   W0L,[W5+#2]
0914:  MOV.B   #0,W0L
0916:  MOV.B   W0L,[W5+#3]
....................          reference[i] = 0 - reference[i];
0918:  MOV     AEA,W4
091A:  MUL.UU  W4,#4,W0
091C:  MOV     #928,W4
091E:  ADD     W0,W4,W5
0920:  MOV     AEA,W4
0922:  MUL.UU  W4,#4,W0
0924:  MOV     #928,W4
0926:  ADD     W0,W4,W0
0928:  MOV     W0,W4
092A:  MOV     #0,W3
092C:  MOV     [W4++],[W3++]
092E:  MOV     [W4++],[W3++]
0930:  MOV     #0,W4
0932:  SUB     W4,W0,[W5]
0934:  MOV     #0,W4
0936:  SUBB    W4,W1,[++W5]
....................       }
....................       
....................       reference[i] = reference[i] + voltage_offset;
0938:  MOV     AEA,W4
093A:  MUL.UU  W4,#4,W0
093C:  MOV     #928,W4
093E:  ADD     W0,W4,W5
0940:  MOV     AEA,W4
0942:  MUL.UU  W4,#4,W0
0944:  MOV     #928,W4
0946:  ADD     W0,W4,W0
0948:  MOV     #C,W4
094A:  MOV     [W0++],[W4++]
094C:  MOV     [W0++],[W4++]
094E:  MOV     #3E8,W4
0950:  ADD     W6,W4,[W5]
0952:  ADDC    W7,#0,[++W5]
....................       if(reference[i] > high_duty_limit )
0954:  MOV     AEA,W4
0956:  MUL.UU  W4,#4,W0
0958:  MOV     #928,W4
095A:  ADD     W0,W4,W0
095C:  MOV     #A,W4
095E:  MOV     [W0++],[W4++]
0960:  MOV     [W0++],[W4++]
0962:  CP      W6,#0
0964:  BRA     LT,986
0966:  BRA     GT,96E
0968:  MOV     #79E,W4
096A:  CP      W4,W5
096C:  BRA     C,986
....................       { 
....................          reference[i] = high_duty_limit;
096E:  MOV     AEA,W4
0970:  MUL.UU  W4,#4,W0
0972:  MOV     #928,W4
0974:  ADD     W0,W4,W5
0976:  MOV.B   #9E,W0L
0978:  MOV.B   W0L,[W5]
097A:  MOV.B   #7,W0L
097C:  MOV.B   W0L,[W5+#1]
097E:  MOV.B   #0,W0L
0980:  MOV.B   W0L,[W5+#2]
0982:  MOV.B   #0,W0L
0984:  MOV.B   W0L,[W5+#3]
....................       }
....................       if(reference[i] < low_duty_limit)
0986:  MOV     AEA,W4
0988:  MUL.UU  W4,#4,W0
098A:  MOV     #928,W4
098C:  ADD     W0,W4,W0
098E:  MOV     #A,W4
0990:  MOV     [W0++],[W4++]
0992:  MOV     [W0++],[W4++]
0994:  CP      W6,#0
0996:  BRA     GT,9B8
0998:  BRA     LT,9A0
099A:  MOV     #32,W4
099C:  CP      W4,W5
099E:  BRA     LEU,9B8
....................       { 
....................          reference[i] = low_duty_limit;
09A0:  MOV     AEA,W4
09A2:  MUL.UU  W4,#4,W0
09A4:  MOV     #928,W4
09A6:  ADD     W0,W4,W5
09A8:  MOV.B   #32,W0L
09AA:  MOV.B   W0L,[W5]
09AC:  MOV.B   #0,W0L
09AE:  MOV.B   W0L,[W5+#1]
09B0:  MOV.B   #0,W0L
09B2:  MOV.B   W0L,[W5+#2]
09B4:  MOV.B   #0,W0L
09B6:  MOV.B   W0L,[W5+#3]
....................       }
09B8:  INC     0AEA
09BA:  BRA     820
....................    }
....................       
....................    *P1DC1 = reference[0];  *(P1DC1+1) = reference[0]>>8;
09BC:  MOV.B   928,W0L
09BE:  MOV.B   W0L,1D6
09C0:  MOV.B   929,W0L
09C2:  MOV.B   W0L,1D7
....................    *P1DC2 = reference[1];  *(P1DC2+1) = reference[1]>>8;
09C4:  MOV.B   92C,W0L
09C6:  MOV.B   W0L,1D8
09C8:  MOV.B   92D,W0L
09CA:  MOV.B   W0L,1D9
....................    *P1DC3 = reference[2];  *(P1DC3+1) = reference[2]>>8;
09CC:  MOV.B   930,W0L
09CE:  MOV.B   W0L,1DA
09D0:  MOV.B   931,W0L
09D2:  MOV.B   W0L,1DB
.................... 
....................    setup_timer2(TMR_INTERNAL | TMR_DIV_BY_1 | TMR_32_BIT , timer_table[freq]);
09D4:  MOV     984,W0
09D6:  SL      W0,#1,W0
09D8:  CALL    3F0
09DC:  MOV     W0,W5
09DE:  CLR     110
09E0:  MOV     W5,10C
09E2:  MOV     W6,10E
09E4:  MOV     #8008,W4
09E6:  MOV     W4,110
.................... //!   output_bit(TIM_tick_pin , 0);
....................    
09E8:  BCLR.B  84.7
09EA:  MOV     #1A,W0
09EC:  REPEAT  #C
09EE:  MOV     [--W15],[W0--]
09F0:  MOV     [--W15],W0
09F2:  POP     32
09F4:  POP     36
09F6:  POP     42
09F8:  RETFIE  
.................... }
.................... 
....................    
.................... void main()
*
14FA:  MOV     #F80,W15
14FC:  MOV     #FFF,W0
14FE:  MOV     W0,20
1500:  NOP     
1502:  MOV     #4444,W0
1504:  MOV     W0,96
1506:  MOV     #4444,W0
1508:  MOV     W0,A6
150A:  BSET.B  81.7
150C:  MOV     #8000,W4
150E:  MOV     W4,20C
1510:  MOV     #400,W4
1512:  MOV     W4,20E
1514:  MOV     #10,W4
1516:  MOV     W4,214
1518:  CLR     864
151A:  CLR     866
151C:  CLR     864
151E:  CLR     866
1520:  BSET.B  8D.1
1522:  CLR     924
1524:  CLR     926
1526:  CLR     980
1528:  CLR     982
152A:  MOV     #1,W4
152C:  MOV     W4,984
152E:  CLR     986
1530:  CLR     988
1532:  CLR     98A
1534:  CLR     98C
1536:  CLR     98E
1538:  CLR     990
153A:  CLR     992
153C:  CLR     994
153E:  CLR     996
1540:  BCLR.B  998.0
1542:  CLR     99A
1544:  CLR     99C
1546:  BCLR.B  998.1
1548:  BCLR.B  998.2
154A:  BCLR.B  998.3
154C:  CLR.B   999
154E:  CLR     99E
1550:  CLR     9A0
1552:  CLR     9A2
1554:  CLR     9A4
1556:  BCLR.B  998.4
1558:  BCLR.B  998.5
155A:  CLR.B   A14
155C:  CLR     A16
155E:  CLR     A18
1560:  CLR     A1A
1562:  CLR     A1C
1564:  CLR     A1E
1566:  CLR     A20
1568:  CLR     A22
156A:  SETM    2A8
156C:  BCLR.B  998.6
156E:  BRA     1612
1570:  DATA    C0,06,08
1572:  DATA    68,00,00
1574:  DATA    4B,F0,3F
1576:  DATA    5C,0A,58
1578:  DATA    F6,3B,8F
157A:  DATA    00,C0,3C
157C:  DATA    8B,28,AC
157E:  DATA    3C,BE,F6
1580:  DATA    3F,D2,D5
1582:  DATA    44,16,8C
1584:  DATA    15,D7,BF
1586:  DATA    69,00,5A
1588:  DATA    2E,1B,87
158A:  DATA    99,3F,9A
158C:  DATA    5F,AD,4B
158E:  DATA    91,E4,01
1590:  DATA    C0,5D,11
1592:  DATA    2F,92,E4
1594:  DATA    81,FB,3F
1596:  DATA    38,DA,91
1598:  DATA    80,9D,C5
159A:  DATA    E0,BF,6F
159C:  DATA    12,C0,B4
159E:  DATA    C3,09,AB
15A0:  DATA    3F,6B,C1
15A2:  DATA    03,4E,C1
15A4:  DATA    B5,45,BF
15A6:  DATA    F7,40,05
15A8:  DATA    FF,00,5C
15AA:  DATA    EF,3F,F3
15AC:  DATA    A3,E2,F7
15AE:  DATA    D7,FF,01
15B0:  DATA    40,C0,B4
15B2:  DATA    FF,05,3C
15B4:  DATA    58,FC,3F
15B6:  DATA    3B,D3,C0
15B8:  DATA    B5,BA,8C
15BA:  DATA    E2,3F,39
15BC:  DATA    D3,C7,3D
15BE:  DATA    41,79,B2
15C0:  DATA    3F,87,0D
15C2:  DATA    3C,50,D0
15C4:  DATA    AF,62,3F
15C6:  DATA    30,4B,8D
15C8:  DATA    A2,82,AA
15CA:  DATA    04,40,09
15CC:  DATA    A0,40,4A
15CE:  DATA    05,76,03
15D0:  DATA    40,EC,9E
15D2:  DATA    37,88,A6
15D4:  DATA    44,F0,3F
15D6:  DATA    8F,12,8D
15D8:  DATA    29,9A,5B
15DA:  DATA    C7,3F,0E
15DC:  DATA    E0,80,7C
15DE:  DATA    A1,D8,86
15E0:  DATA    3F,29,4B
15E2:  DATA    FB,95,C2
15E4:  DATA    37,1A,3F
15E6:  DATA    00,00,80
15E8:  DATA    06,09,1E
15EA:  DATA    E8,03,E8
15EC:  DATA    03,E8,03
15EE:  DATA    C0,0C,09
15F0:  DATA    28,00,C0
15F2:  DATA    06,09,72
15F4:  DATA    00,00,00
15F6:  INC     W2,W2
15F8:  CP      W2,#1
15FA:  BRA     NZ,1604
15FC:  TBLRDL  [W1],W3
15FE:  TBLRDH  [W1++],W4
1600:  MOV.B   6,W0L
1602:  RETURN  
1604:  CP      W2,#2
1606:  BRA     NZ,160C
1608:  MOV.B   7,W0L
160A:  RETURN  
160C:  MOV.B   8,W0L
160E:  CLR     W2
1610:  RETURN  
1612:  MOV     #0,W6
1614:  MOV     #0,W0
1616:  MOV     W0,32
1618:  MOV     #1570,W0
161A:  MOV     W0,W1
161C:  CLR     W2
161E:  CALL    15F6
1622:  MOV.B   W0L,B
1624:  CALL    15F6
1628:  MOV.B   W0L,A
162A:  CP0     W5
162C:  BRA     Z,1660
162E:  BTSS    W5.F
1630:  BRA     1640
1632:  CALL    15F6
1636:  MOV.B   W0L,D
1638:  CALL    15F6
163C:  MOV.B   W0L,C
163E:  BCLR    W5.F
1640:  BTSS    W5.E
1642:  BRA     1654
1644:  BCLR    W5.E
1646:  DEC     W5,W5
1648:  CALL    15F6
164C:  MOV.B   W0L,W7L
164E:  REPEAT  W5
1650:  MOV.B   W7L,[W6++]
1652:  BRA     161E
1654:  CALL    15F6
1658:  MOV.B   W0L,[W6++]
165A:  DEC     W5,W5
165C:  BRA     NZ,1654
165E:  BRA     161E
.................... { 
....................    
....................    sprintf(Serial_OutputBuffer, "\nMotor Control Unit v0.1\r\n");
1660:  MOV     #9A6,W4
1662:  MOV     W4,A22
1664:  MOV     #0,W1
1666:  MOV     W1,W0
1668:  CLR.B   1
166A:  CALL    6E0
166E:  INC     W1,W1
1670:  MOV     W1,[W15++]
1672:  MOV     W0,[W15++]
1674:  MOV     [--W15],W0
1676:  CALL    9FA
167A:  MOV     [--W15],W1
167C:  MOV     #19,W0
167E:  CPSGT   W1,W0
1680:  BRA     1666
....................    printf(Serial_OutputBuffer);
1682:  MOV     #9A6,W1
1684:  CP0.B   [W1]
1686:  BRA     Z,1696
1688:  BTSC.B  20F.1
168A:  BRA     1688
168C:  MOV.B   [W1+#0],W0L
168E:  MOV.B   W0L,210
1690:  CLR.B   211
1692:  INC     W1,W1
1694:  BRA     1684
....................    
....................    *U1BRG = 8;  
1696:  MOV.B   #8,W0L
1698:  MOV.B   W0L,214
....................    attained_throttle = 20;
169A:  MOV     #14,W4
169C:  MOV     W4,A10
....................    position_capture = 0;
169E:  CLR     99A
....................    freq = 1;
16A0:  MOV     #1,W4
16A2:  MOV     W4,984
....................    
....................    initMCPWM();
16A4:  CALL    A08
....................    fill_sine_table();
16A8:  CALL    12F4
.................... 
....................    output_drive(LED_PIN);
16AC:  BCLR.B  2CD.5
.................... 
....................    setup_adc(ADC_CLOCK_DIV_32);
16AE:  MOV     #1F1F,W4
16B0:  MOV     W4,2A4
16B2:  MOV     #80E0,W4
16B4:  MOV     W4,2A0
....................    setup_adc_ports(ADC_pin);
16B6:  MOV     #FFFD,W4
16B8:  MOV     W4,2A8
16BA:  CLR     2A2
....................    set_adc_channel(1);
16BC:  MOV     #1,W4
16BE:  MOV     W4,2A6
....................    delay_us(10);
16C0:  REPEAT  #9E
16C2:  NOP     
....................    
....................    setup_qei( QEI_MODE_X2 , QEI_FILTER_DIV_1 ,0);
16C4:  MOV     #400,W4
16C6:  MOV     W4,122
16C8:  CLR     124
16CA:  CLR     128
16CC:  CLR     126
....................    setup_timer2(TMR_INTERNAL | TMR_DIV_BY_1 | TMR_32_BIT , timer_table[freq]);
16CE:  MOV     984,W0
16D0:  SL      W0,#1,W0
16D2:  CALL    3F0
16D6:  MOV     W0,W5
16D8:  CLR     110
16DA:  MOV     W5,10C
16DC:  MOV     W6,10E
16DE:  MOV     #8008,W4
16E0:  MOV     W4,110
....................    enable_interrupts(INT_TIMER3);   // enable interrupt in timer3 register (in case of 32bit mode) 
16E2:  BSET.B  8C.7
.................... 
....................    enable_interrupts(INT_PWM1);
16E4:  BSET.B  90.7
....................    enable_interrupts(INTR_GLOBAL);
16E6:  BCLR.B  81.7
16E8:  CLR     42
16EA:  BSET.B  81.7
....................    
.................... 
....................    while(TRUE)         
....................    {
....................       
....................       if (tick) {
16EC:  BTSS.B  998.1
16EE:  BRA     1818
....................          
....................          raw_adc = read_adc();
16F0:  BCLR.B  2A0.0
16F2:  BSET.B  2A0.1
16F4:  BTSS.B  2A0.0
16F6:  BRA     16F4
16F8:  PUSH    280
16FA:  POP     980
....................          
....................          output_bit(LED_PIN , 1);
16FC:  BSET.B  2D1.5
16FE:  BCLR.B  2CD.5
....................          if (raw_adc > 1023) 
1700:  MOV     980,W4
1702:  MOV     #3FF,W3
1704:  CP      W3,W4
1706:  BRA     C,170C
....................          {
....................             raw_adc = 1023;
1708:  MOV     #3FF,W4
170A:  MOV     W4,980
....................          }
.................... 
....................          raw_adc = raw_adc -200;
170C:  MOV     980,W4
170E:  SUB     #C8,W4
1710:  MOV     W4,980
....................          throttle_level = raw_adc;
1712:  PUSH    980
1714:  POP     982
....................         
....................          
....................          if (throttle_level > 255)
1716:  MOV     982,W4
1718:  MOV     #FF,W3
171A:  CP      W3,W4
171C:  BRA     GE,1722
....................          {
....................             throttle_level = 255;
171E:  MOV     #FF,W4
1720:  MOV     W4,982
....................          }
....................          if (throttle_level < 0)   
1722:  MOV     982,W4
1724:  CP      W4,#0
1726:  BRA     GE,172A
....................          {  
....................             throttle_level = 0; 
1728:  CLR     982
....................          }
.................... 
....................           ascending_speed  = ascend_speed_table[attained_throttle];
172A:  MOV     A10,W0
172C:  SL      W0,#1,W0
172E:  CALL    100
1732:  MOV     W0,A0A
....................           descending_speed = descend_speed_table[attained_throttle];
1734:  MOV     A10,W0
1736:  SL      W0,#1,W0
1738:  CALL    278
173C:  MOV     W0,A0C
....................           loaded_speed = ascend_speed_table[attained_throttle-1];
173E:  MOV     A10,W4
1740:  SUB     W4,#1,W5
1742:  SL      W5,#1,W0
1744:  CALL    100
1748:  MOV     W0,A12
....................           
....................           if (!enc_mutx) 
174A:  BTSC.B  998.6
174C:  BRA     1752
....................           {
....................             attained_speed = position_count_new;      // READING ENCODER's SHARED VARIABLE. 
174E:  PUSH    994
1750:  POP     A0E
....................           }
....................           
....................           
....................           if(throttle_level > attained_throttle && attained_speed >= ascending_speed)
1752:  MOV     A10,W0
1754:  MOV     982,W4
1756:  CP      W4,W0
1758:  BRA     LE,1766
175A:  MOV     A0A,W0
175C:  MOV     A0E,W4
175E:  CP      W4,W0
1760:  BRA     NC,1766
....................           {
....................             attained_throttle++;
1762:  INC     0A10
.................... 
....................           }
1764:  BRA     17A8
....................           else if (throttle_level > attained_throttle && attained_speed < loaded_speed) 
1766:  MOV     A10,W0
1768:  MOV     982,W4
176A:  CP      W4,W0
176C:  BRA     LE,1784
176E:  MOV     A0E,W0
1770:  MOV     A12,W4
1772:  CP      W4,W0
1774:  BRA     LEU,1784
....................           {
....................             
....................             attained_throttle--;
1776:  DEC     0A10
....................             if (attained_throttle < 20) 
1778:  MOV     A10,W4
177A:  CP      W4,#14
177C:  BRA     C,1782
....................             {
....................                attained_throttle = 20;
177E:  MOV     #14,W4
1780:  MOV     W4,A10
....................                
....................             }
....................           
....................           }
1782:  BRA     17A8
....................           else if(throttle_level < attained_throttle && attained_speed <= descending_speed)
1784:  MOV     982,W0
1786:  MOV     A10,W4
1788:  CP      W4,W0
178A:  BRA     LE,17A2
178C:  MOV     A0E,W0
178E:  MOV     A0C,W4
1790:  CP      W4,W0
1792:  BRA     NC,17A2
....................           {
....................             
....................             attained_throttle--; 
1794:  DEC     0A10
....................             if (attained_throttle < 20)
1796:  MOV     A10,W4
1798:  CP      W4,#14
179A:  BRA     C,17A0
....................             {
....................                attained_throttle = 20;
179C:  MOV     #14,W4
179E:  MOV     W4,A10
....................             }
....................              
....................           }
17A0:  BRA     17A8
....................           else if (throttle_level == attained_throttle)
17A2:  MOV     982,W0
17A4:  CP      A10
17A6:  BRA     NZ,17A8
....................           {
....................           //
....................           }
....................          sprintf(Serial_OutputBuffer, "\r\n %d,%d,%d,%d" , throttle_level , attained_throttle,  attained_speed , ascending_speed);
17A8:  MOV     #9A6,W4
17AA:  MOV     W4,A22
17AC:  MOV.B   #D,W0L
17AE:  CALL    9FA
17B2:  MOV.B   #A,W0L
17B4:  CALL    9FA
17B8:  MOV.B   #20,W0L
17BA:  CALL    9FA
17BE:  MOV     982,W0
17C0:  MOV     #0,W4
17C2:  CALL    13BC
17C6:  MOV.B   #2C,W0L
17C8:  CALL    9FA
17CC:  MOV     A10,W0
17CE:  MOV     #0,W4
17D0:  CALL    13BC
17D4:  MOV.B   #2C,W0L
17D6:  CALL    9FA
17DA:  MOV     A0E,W0
17DC:  MOV     #0,W4
17DE:  CALL    13BC
17E2:  MOV.B   #2C,W0L
17E4:  CALL    9FA
17E8:  MOV     A0A,W0
17EA:  MOV     #0,W4
17EC:  CALL    13BC
....................          printf(Serial_OutputBuffer);  
17F0:  MOV     #9A6,W1
17F2:  CP0.B   [W1]
17F4:  BRA     Z,1804
17F6:  BTSC.B  20F.1
17F8:  BRA     17F6
17FA:  MOV.B   [W1+#0],W0L
17FC:  MOV.B   W0L,210
17FE:  CLR.B   211
1800:  INC     W1,W1
1802:  BRA     17F2
....................          
....................          freq = attained_throttle;
1804:  PUSH    A10
1806:  POP     984
....................          peak_voltage = gain_table[attained_throttle];
1808:  MOV     A10,W0
180A:  SL      W0,#1,W0
180C:  CALL    568
1810:  MOV     W0,926
....................          tick = 0;  
1812:  BCLR.B  998.1
....................          output_bit(LED_PIN , 0);
1814:  BCLR.B  2D1.5
1816:  BCLR.B  2CD.5
....................       } 
....................       
....................       if (uart_tick) 
1818:  BTSS.B  998.3
181A:  BRA     181E
....................       {
.................... //!         sprintf(Serial_OutputBuffer, "\r\n %d , %d , %d , %d , %d , %d" , throttle_level , attained_throttle,  attained_speed , ascending_speed , descending_speed , speed_capture);
.................... //!         printf(Serial_OutputBuffer);         
....................          uart_tick = 0;
181C:  BCLR.B  998.3
....................       
....................       }
....................       if (enc_tick) 
181E:  BTSS.B  998.2
1820:  BRA     18CA
....................       {
....................          enc_mutx = 1;
1822:  BSET.B  998.6
....................          position_count = *(POSCNT +1);
1824:  MOV.B   127,W0L
1826:  MOV.B   W0L,988
1828:  CLR.B   989
182A:  CLR     98A
....................          position_count = position_count << 8;
182C:  MOV.B   98A,W0L
182E:  MOV.B   W0L,98B
1830:  MOV.B   989,W0L
1832:  MOV.B   W0L,98A
1834:  MOV.B   988,W0L
1836:  MOV.B   W0L,989
1838:  CLR.B   988
....................          position_count = position_count | *POSCNT; 
183A:  MOV.B   126,W0L
183C:  CLR.B   1
183E:  IOR     988
....................          
.................... 
....................          direction_flag = QEI_get_direction();
1840:  CALL    14EC
1844:  BCLR.B  998.0
1846:  BTSC.B  0.0
1848:  BSET.B  998.0
.................... 
....................          enc_count = position_count - prev_count;
184A:  MOV     988,W4
184C:  MOV     98C,W3
184E:  SUB     W4,W3,W0
1850:  MOV     W0,990
1852:  MOV     98A,W4
1854:  MOV     98E,W3
1856:  SUBB    W4,W3,W0
1858:  MOV     W0,992
....................      
....................          if (direction_flag == 1 && enc_count < 0) 
185A:  BTSS.B  998.0
185C:  BRA     187A
185E:  MOV     992,W4
1860:  CP      W4,#0
1862:  BRA     GT,187A
1864:  BRA     LT,186C
1866:  MOV     990,W4
1868:  CP      W4,#0
186A:  BRA     C,187A
....................          {
....................             enc_count = enc_count + TIM_OVERFLOW_VAL ;
186C:  MOV     #FFFF,W4
186E:  MOV     990,W3
1870:  ADD     W3,W4,W0
1872:  MOV     W0,990
1874:  MOV     992,W4
1876:  ADDC    W4,#0,W0
1878:  MOV     W0,992
.................... 
....................          }
.................... 
....................          if (direction_flag == 0 && enc_count > 0) 
187A:  BTSC.B  998.0
187C:  BRA     189A
187E:  MOV     992,W4
1880:  CP      W4,#0
1882:  BRA     LT,189A
1884:  BRA     GT,188C
1886:  MOV     990,W4
1888:  CP      W4,#0
188A:  BRA     LEU,189A
....................          {
....................             enc_count = enc_count - TIM_OVERFLOW_VAL ;
188C:  MOV     990,W4
188E:  MOV     #FFFF,W3
1890:  SUB     W4,W3,W0
1892:  MOV     W0,990
1894:  MOV     992,W4
1896:  SUBB    W4,#0,W0
1898:  MOV     W0,992
....................          }
....................    
....................          enc_count = abs(enc_count);
189A:  MOV     990,W0
189C:  MOV     992,W1
189E:  BTSS    W1.F
18A0:  BRA     18AE
18A2:  MOV     #0,W4
18A4:  MOV     990,W3
18A6:  SUB     W4,W3,W0
18A8:  MOV     #0,W4
18AA:  MOV     992,W3
18AC:  SUBB    W4,W3,W1
18AE:  MOV     W0,990
18B0:  MOV     W1,992
....................          enc_count = enc_count >> 1;
18B2:  LSR     992
18B4:  RRC     990
....................          prev_count = position_count;           
18B6:  PUSH    988
18B8:  POP     98C
18BA:  PUSH    98A
18BC:  POP     98E
....................          position_count_new = enc_count;
18BE:  PUSH    990
18C0:  POP     994
18C2:  PUSH    992
18C4:  POP     996
.................... 
....................          enc_mutx = 0;
18C6:  BCLR.B  998.6
....................          enc_tick = 0;
18C8:  BCLR.B  998.2
.................... 
....................       }
18CA:  BRA     16EC
....................     } 
.................... }    
.................... 
18CC:  PWRSAV  #0
.................... 
.................... void initMCPWM(void) 
.................... {    
....................    *(P1TCON+1)  =  0x80;  *P1TCON =  0x02;
*
0A08:  MOV.B   #80,W0L
0A0A:  MOV.B   W0L,1C1
0A0C:  MOV.B   #2,W0L
0A0E:  MOV.B   W0L,1C0
....................    *(P1TPER+1)  =  0x03;  *P1TPER =  0xE7;  
0A10:  MOV.B   #3,W0L
0A12:  MOV.B   W0L,1C5
0A14:  MOV.B   #E7,W0L
0A16:  MOV.B   W0L,1C4
....................    *(P1SECMP+1) =  0x00;  *P1SECMP=  0x01; //
0A18:  CLR.B   1C7
0A1A:  MOV.B   #1,W0L
0A1C:  MOV.B   W0L,1C6
....................    *(PWM1CON1+1)=  0x00;  *PWM1CON1= 0x77;  
0A1E:  CLR.B   1C9
0A20:  MOV.B   #77,W0L
0A22:  MOV.B   W0L,1C8
....................    *(PWM1CON2+1)=  0x00;  *PWM1CON2= 0x02;
0A24:  CLR.B   1CB
0A26:  MOV.B   #2,W0L
0A28:  MOV.B   W0L,1CA
....................    *(P1DTCON1+1)=  0x00;  *P1DTCON1= 0x10; //0x09
0A2A:  CLR.B   1CD
0A2C:  MOV.B   #10,W0L
0A2E:  MOV.B   W0L,1CC
....................    *(P1DTCON2+1)=  0x00;  *P1DTCON2= 0x00;
0A30:  CLR.B   1CF
0A32:  CLR.B   1CE
....................    *(P1FLTACON+1)= 0x00;  *P1FLTACON=0x00; //0x0000
0A34:  CLR.B   1D1
0A36:  CLR.B   1D0
....................    *(P1OVDCON+1)=  0x3F;  *P1OVDCON= 0x0F;
0A38:  MOV.B   #3F,W0L
0A3A:  MOV.B   W0L,1D5
0A3C:  MOV.B   #F,W0L
0A3E:  MOV.B   W0L,1D4
....................    
....................    *(P1DC1+1) = duty[0]>>8;   *P1DC1 = duty[0]; 
0A40:  MOV.B   91F,W0L
0A42:  MOV.B   W0L,1D7
0A44:  MOV.B   91E,W0L
0A46:  MOV.B   W0L,1D6
....................    *(P1DC2+1) = duty[1]>>8;   *P1DC2 = duty[1];
0A48:  MOV.B   921,W0L
0A4A:  MOV.B   W0L,1D9
0A4C:  MOV.B   920,W0L
0A4E:  MOV.B   W0L,1D8
....................    *(P1DC3+1) = duty[2]>>8;   *P1DC3 = duty[2];  
0A50:  MOV.B   923,W0L
0A52:  MOV.B   W0L,1DB
0A54:  MOV.B   922,W0L
0A56:  MOV.B   W0L,1DA
....................    *(IPC14+1) =0x00;*(IPC14) =0x70;
0A58:  CLR.B   C1
0A5A:  MOV.B   #70,W0L
0A5C:  MOV.B   W0L,C0
0A5E:  RETURN  
.................... }
.................... 
.................... 
....................    
.................... void fill_sine_table(void)
*
12F4:  MOV     W5,[W15++]
12F6:  MOV     W6,[W15++]
12F8:  MOV     W7,[W15++]
12FA:  MOV     W8,[W15++]
.................... {
....................    for(sine_index=0;sine_index < max_samples;sine_index++)  
12FC:  CLR     970
12FE:  MOV     970,W4
1300:  CP      W4,#1E
1302:  BRA     C,13B2
....................    {
....................       theeta=sine_index*2.0*PI/max_samples;
1304:  MOV     970,W0
1306:  MOV     #0,W1
1308:  MOV     #0,W2
130A:  MOV     #0,W3
130C:  CALL    A60
1310:  MOV     #0,W4
1312:  MOV     #0,W5
1314:  MOV     #0,W6
1316:  MOV     #4000,W7
1318:  CALL    ACA
131C:  MOV     W0,W5
131E:  MOV     W1,W6
1320:  MOV     W2,W7
1322:  MOV     W3,W8
1324:  MOV     W5,[W15++]
1326:  MOV     W6,[W15++]
1328:  MOV     W7,[W15++]
132A:  MOV     W5,W0
132C:  MOV     W6,W1
132E:  MOV     W7,W2
1330:  MOV     W8,W3
1332:  MOV     #2D18,W4
1334:  MOV     #5444,W5
1336:  MOV     #21FB,W6
1338:  MOV     #4009,W7
133A:  CALL    ACA
133E:  MOV     [--W15],W7
1340:  MOV     [--W15],W6
1342:  MOV     [--W15],W5
1344:  MOV     W0,W5
1346:  MOV     W1,W6
1348:  MOV     W2,W7
134A:  MOV     W3,W8
134C:  MOV     W5,[W15++]
134E:  MOV     W6,[W15++]
1350:  MOV     W7,[W15++]
1352:  MOV     W5,W0
1354:  MOV     W6,W1
1356:  MOV     W7,W2
1358:  MOV     W8,W3
135A:  MOV     #0,W4
135C:  MOV     #0,W5
135E:  MOV     #0,W6
1360:  MOV     #403E,W7
1362:  CALL    BDA
1366:  MOV     [--W15],W7
1368:  MOV     [--W15],W6
136A:  MOV     [--W15],W5
136C:  MOV     W0,978
136E:  MOV     W1,97A
1370:  MOV     W2,97C
1372:  MOV     W3,97E
....................       sine_table[sine_index]=255*sin(theeta);
1374:  MOV     970,W0
1376:  SL      W0,#1,W0
1378:  MOV     #934,W4
137A:  ADD     W0,W4,W5
137C:  PUSH    978
137E:  POP     A28
1380:  PUSH    97A
1382:  POP     A2A
1384:  PUSH    97C
1386:  POP     A2C
1388:  PUSH    97E
138A:  POP     A2E
138C:  CALL    125A
1390:  MOV     W5,[W15++]
1392:  MOV     W0,W4
1394:  MOV     W1,W5
1396:  MOV     W2,W6
1398:  MOV     W3,W7
139A:  MOV     #0,W0
139C:  MOV     #0,W1
139E:  MOV     #E000,W2
13A0:  MOV     #406F,W3
13A2:  CALL    ACA
13A6:  MOV     [--W15],W5
13A8:  CALL    1296
13AC:  MOV     W0,[W5]
13AE:  INC     0970
13B0:  BRA     12FE
....................    }
13B2:  MOV     [--W15],W8
13B4:  MOV     [--W15],W7
13B6:  MOV     [--W15],W6
13B8:  MOV     [--W15],W5
13BA:  RETURN  
.................... }
.................... 
.................... int1 QEI_get_direction(void) 
.................... {
....................    if (*(QEICON +1) & (1 << UPDN)) return 1;
*
14EC:  BTSS.B  123.3
14EE:  BRA     14F6
14F0:  MOV.B   #1,W0L
14F2:  MOV.B   W0L,0
14F4:  BRA     14F8
....................    
....................    return 0;
14F6:  CLR.B   0
14F8:  RETURN  
.................... 
.................... }
.................... 
.................... void uart1_write (char* str , unsigned int str_size) 
.................... {
....................    for (int i = 0; i < str_size; i++) 
....................    {
....................       *U1TXREG = str[i];
....................    
....................    
....................    }
.................... 
.................... 
.................... }
.................... int16 baud_rate_calc (unsigned int32 baud_rate) 
.................... {
....................    int16 UBRG = ((clock_freq/baud_rate)/16) -1;
....................    return UBRG;
.................... }
.................... 
.................... 
.................... 
.................... 
....................   
....................    
.................... 
.................... 
.................... 
.................... //-----------------IMPLEMENATION REQUIRED--------------//
.................... 
.................... //==========RESPONSE ON BREAK INPUT===========
.................... // DRIVE PWM TO 0 ON BREAK INPUT...
.................... 
.................... 
.................... //=========INPUT FREQUENCY VS MOTOR SPEED DIFFERENCE CALCULATION====
.................... /*
....................    speed  = (freq_table[throttle_level] * 120) / poles
....................    enc_freq = (speed * 64) / 60
....................    
....................    slip = motor_enc_freq - enc_freq;
....................    
.................... */
.................... /*
.................... ==========FOLLOW UP MOTOR SPEED ALGORITHM===========
.................... - sending throttle value from serial.
.................... - is speed_table[throttle_level] == motor_enc
.................... - if yes go to next speed value.
.................... 
.................... if (current_speed != set_speed && current_speed == next_speed)
....................          {
....................             next_speed++;
....................             throttle_level++;
....................             prev_speed = current_speed;
....................          }
....................          
....................          if (current_speed <= prev_speed)
....................          {
....................             // speed is decreasing.
....................             prev_speed = current_speed;
....................             
....................          }
....................          
....................          
....................          //!             if (attained_speed < loaded_speed) 
.................... //!             {
.................... //!               position_capture = attained_speed;
.................... //!               descend_flag = 1;
.................... //!                attained_throttle--; 
.................... //!                if (attained_throttle < 20)
.................... //!                {
.................... //!                   attained_throttle = 20;
.................... //!                }
.................... //!             }
.................... //!             else {descend_flag = 0;}
.................... 
.................... */
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
....................   

Configuration Fuses:
   Word  1L: 0306   XT_PLL8 PR CKSFSM
          H: 0000  
   Word  2L: 003F   WPSB16 WPSA512 NOWDT
          H: 0000  
   Word  3L: 8793   PUT64 BORV42 BROWNOUT LPOL_HIGH HPOL_HIGH NOPWMPIN MCLR
          H: 0000  
   Word  4L: 310F  
          H: 0000  
   Word  5L: 330F  
          H: 0000  
   Word  6L: 0004   WRT PROTECT
          H: 0000  
   Word  7L: C003   ICSP1 NODEBUG
          H: 0000  
