CCS PCD C Compiler, Version 5.112, 5967               23-Jul-24 16:29

               Filename:   C:\Users\eelab\Documents\[2024-05-15] MOTOR_CONTROL\main.lst

               ROM used:   7740 bytes (24%)
                           Largest free fragment is 25028
               RAM used:   766 (37%) at main() level
                           973 (48%) worst case
               Stack used: 108 locations (58 in main + 50 for interrupts)
               Stack size: 128

*
0000:  GOTO    1942
*
0022:  DATA    EE,07,00
*
0026:  DATA    0C,07,00
*
003E:  DATA    8A,0B,00
*
0062:  DATA    46,07,00
.................... #include <30F4011.h>
.................... //////////// Standard Header file for the DSPIC30F4011 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
*
0736:  MOV     #1A,W0
0738:  REPEAT  #C
073A:  MOV     [--W15],[W0--]
073C:  MOV     [--W15],W0
073E:  POP     32
0740:  POP     36
0742:  POP     42
0744:  RETFIE  
.................... #device DSPIC30F4011
*
0100:  CLR     32
0102:  MOV     #156,W3
0104:  SUB     W0,W3,W3
0106:  BRA     C,110
0108:  MOV     #122,W3
010A:  ADD     W3,W0,W0
010C:  TBLRDL  [W0],W0
010E:  RETURN  
0110:  MOV     #122,W0
0112:  BCLR.B  6.0
0114:  ADD     W3,W3,W3
0116:  ADD     W3,W0,W3
0118:  TBLRDH  [W3++],W0
011A:  TBLRDH  [W3],W3
011C:  SL      W3,#8,W3
011E:  IOR      W3,  W0,W0
0120:  RETURN  
0122:  DATA    6A,04,40
0124:  DATA    7A,E7,0C
0126:  DATA    54,D0,2E
0128:  DATA    64,BD,0C
012A:  DATA    9B,AD,1C
012C:  DATA    41,A0,0C
012E:  DATA    CE,94,0A
0130:  DATA    E3,8A,0C
0132:  DATA    34,82,F8
0134:  DATA    8C,7A,0B
0136:  DATA    8C,7A,E7
0138:  DATA    BD,73,0B
013A:  DATA    A5,6D,D5
013C:  DATA    2A,68,0B
013E:  DATA    34,63,C4
0140:  DATA    B1,5E,0B
0142:  DATA    93,5A,B3
0144:  DATA    CD,56,0B
0146:  DATA    54,53,A3
0148:  DATA    20,50,0B
014A:  DATA    28,4D,92
014C:  DATA    67,4A,0B
014E:  DATA    D6,47,82
0150:  DATA    71,45,0B
0152:  DATA    33,43,71
0154:  DATA    1A,41,0B
0156:  DATA    21,3F,61
0158:  DATA    45,3D,0B
015A:  DATA    85,3B,52
015C:  DATA    DE,39,0B
015E:  DATA    DE,39,42
0160:  DATA    4D,38,0B
0162:  DATA    D2,36,42
0164:  DATA    6A,35,0B
0166:  DATA    14,34,32
0168:  DATA    CF,32,0B
016A:  DATA    99,31,23
016C:  DATA    72,30,0B
016E:  DATA    58,2F,14
0170:  DATA    4B,2E,0B
0172:  DATA    49,2D,05
0174:  DATA    53,2C,0B
0176:  DATA    66,2B,F6
0178:  DATA    83,2A,0A
017A:  DATA    AA,29,E7
017C:  DATA    D9,28,0A
017E:  DATA    0F,28,D9
0180:  DATA    4E,27,0A
0182:  DATA    94,26,CA
0184:  DATA    E0,25,0A
0186:  DATA    E0,25,BC
0188:  DATA    33,25,0A
018A:  DATA    8C,24,AE
018C:  DATA    EA,23,0A
018E:  DATA    4F,23,A0
0190:  DATA    B8,22,0A
0192:  DATA    26,22,92
0194:  DATA    99,21,0A
0196:  DATA    11,21,85
0198:  DATA    8C,20,0A
019A:  DATA    0C,20,77
019C:  DATA    90,1F,0A
019E:  DATA    17,1F,6A
01A0:  DATA    A2,1E,0A
01A2:  DATA    30,1E,5C
01A4:  DATA    C2,1D,0A
01A6:  DATA    57,1D,4F
01A8:  DATA    EE,1C,0A
01AA:  DATA    89,1C,42
01AC:  DATA    89,1C,0A
01AE:  DATA    26,1C,42
01B0:  DATA    C6,1B,0A
01B2:  DATA    69,1B,35
01B4:  DATA    0D,1B,0A
01B6:  DATA    B5,1A,29
01B8:  DATA    5E,1A,0A
01BA:  DATA    0A,1A,1C
01BC:  DATA    B7,19,0A
01BE:  DATA    67,19,0F
01C0:  DATA    19,19,0A
01C2:  DATA    CC,18,03
01C4:  DATA    82,18,0A
01C6:  DATA    39,18,F7
01C8:  DATA    F1,17,09
01CA:  DATA    AC,17,EB
01CC:  DATA    68,17,09
01CE:  DATA    25,17,DF
01D0:  DATA    E4,16,09
01D2:  DATA    A4,16,D3
01D4:  DATA    A4,16,09
01D6:  DATA    66,16,C7
01D8:  DATA    29,16,09
01DA:  DATA    ED,15,BB
01DC:  DATA    B3,15,09
01DE:  DATA    79,15,B0
01E0:  DATA    41,15,09
01E2:  DATA    0A,15,A4
01E4:  DATA    D4,14,09
01E6:  DATA    A0,14,99
01E8:  DATA    6C,14,09
01EA:  DATA    39,14,8D
01EC:  DATA    07,14,09
01EE:  DATA    D6,13,82
01F0:  DATA    A6,13,09
01F2:  DATA    77,13,77
01F4:  DATA    49,13,09
01F6:  DATA    1C,13,6C
01F8:  DATA    EF,12,09
01FA:  DATA    EF,12,61
01FC:  DATA    C4,12,09
01FE:  DATA    99,12,61
0200:  DATA    6F,12,09
0202:  DATA    45,12,57
0204:  DATA    1D,12,09
0206:  DATA    F5,11,4C
0208:  DATA    CD,11,09
020A:  DATA    A7,11,41
020C:  DATA    81,11,09
020E:  DATA    5B,11,37
0210:  DATA    37,11,09
0212:  DATA    13,11,2C
0214:  DATA    EF,10,09
0216:  DATA    CC,10,22
0218:  DATA    AA,10,09
021A:  DATA    88,10,18
021C:  DATA    66,10,09
021E:  DATA    46,10,0E
0220:  DATA    25,10,09
0222:  DATA    25,10,04
0224:  DATA    06,10,09
0226:  DATA    E6,0F,FA
0228:  DATA    C7,0F,08
022A:  DATA    A9,0F,F0
022C:  DATA    8B,0F,08
022E:  DATA    6E,0F,E6
0230:  DATA    51,0F,08
0232:  DATA    34,0F,DD
0234:  DATA    18,0F,08
0236:  DATA    FC,0E,D3
0238:  DATA    E1,0E,08
023A:  DATA    C6,0E,C9
023C:  DATA    AB,0E,08
023E:  DATA    91,0E,C0
0240:  DATA    77,0E,08
0242:  DATA    5D,0E,B7
0244:  DATA    44,0E,08
0246:  DATA    2B,0E,AD
0248:  DATA    13,0E,08
024A:  DATA    13,0E,A4
024C:  DATA    FA,0D,08
024E:  DATA    E3,0D,A4
0250:  DATA    CB,0D,08
0252:  DATA    B4,0D,9B
0254:  DATA    9D,0D,08
0256:  DATA    86,0D,92
0258:  DATA    70,0D,08
025A:  DATA    5A,0D,89
025C:  DATA    44,0D,08
025E:  DATA    2F,0D,80
0260:  DATA    19,0D,08
0262:  DATA    04,0D,77
0264:  DATA    F0,0C,08
0266:  DATA    DB,0C,6E
0268:  DATA    C7,0C,08
026A:  DATA    B3,0C,66
026C:  DATA    9F,0C,08
026E:  DATA    8C,0C,5D
0270:  DATA    8C,0C,08
0272:  DATA    79,0C,54
0274:  DATA    66,0C,08
0276:  DATA    53,0C,00
0278:  CLR     32
027A:  MOV     #156,W3
027C:  SUB     W0,W3,W3
027E:  BRA     C,288
0280:  MOV     #29A,W3
0282:  ADD     W3,W0,W0
0284:  TBLRDL  [W0],W0
0286:  RETURN  
0288:  MOV     #29A,W0
028A:  BCLR.B  6.0
028C:  ADD     W3,W3,W3
028E:  ADD     W3,W0,W3
0290:  TBLRDH  [W3++],W0
0292:  TBLRDH  [W3],W3
0294:  SL      W3,#8,W3
0296:  IOR      W3,  W0,W0
0298:  RETURN  
029A:  DATA    57,00,15
029C:  DATA    5A,00,02
029E:  DATA    5D,00,17
02A0:  DATA    5F,00,02
02A2:  DATA    62,00,1A
02A4:  DATA    65,00,02
02A6:  DATA    68,00,1D
02A8:  DATA    6A,00,02
02AA:  DATA    6D,00,20
02AC:  DATA    70,00,02
02AE:  DATA    70,00,22
02B0:  DATA    72,00,02
02B2:  DATA    75,00,25
02B4:  DATA    78,00,02
02B6:  DATA    7B,00,28
02B8:  DATA    7E,00,02
02BA:  DATA    80,00,2B
02BC:  DATA    83,00,02
02BE:  DATA    86,00,2D
02C0:  DATA    88,00,02
02C2:  DATA    8B,00,30
02C4:  DATA    8E,00,02
02C6:  DATA    91,00,33
02C8:  DATA    93,00,02
02CA:  DATA    96,00,36
02CC:  DATA    99,00,02
02CE:  DATA    9C,00,38
02D0:  DATA    9F,00,02
02D2:  DATA    A1,00,3B
02D4:  DATA    A4,00,02
02D6:  DATA    A4,00,3E
02D8:  DATA    A7,00,02
02DA:  DATA    AA,00,3E
02DC:  DATA    AC,00,02
02DE:  DATA    AF,00,41
02E0:  DATA    B2,00,02
02E2:  DATA    B5,00,43
02E4:  DATA    B7,00,02
02E6:  DATA    BA,00,46
02E8:  DATA    BD,00,02
02EA:  DATA    C0,00,49
02EC:  DATA    C2,00,02
02EE:  DATA    C5,00,4C
02F0:  DATA    C8,00,02
02F2:  DATA    CA,00,4E
02F4:  DATA    CD,00,02
02F6:  DATA    D0,00,51
02F8:  DATA    D3,00,02
02FA:  DATA    D5,00,54
02FC:  DATA    D8,00,02
02FE:  DATA    D8,00,57
0300:  DATA    DB,00,02
0302:  DATA    DE,00,59
0304:  DATA    E1,00,02
0306:  DATA    E3,00,5C
0308:  DATA    E6,00,02
030A:  DATA    E9,00,5F
030C:  DATA    EC,00,02
030E:  DATA    EE,00,61
0310:  DATA    F1,00,02
0312:  DATA    F4,00,64
0314:  DATA    F6,00,02
0316:  DATA    F9,00,67
0318:  DATA    FC,00,02
031A:  DATA    FF,00,6A
031C:  DATA    02,01,02
031E:  DATA    04,01,6D
0320:  DATA    07,01,02
0322:  DATA    0A,01,6F
0324:  DATA    0A,01,02
0326:  DATA    0D,01,6F
0328:  DATA    0F,01,02
032A:  DATA    12,01,72
032C:  DATA    15,01,02
032E:  DATA    17,01,75
0330:  DATA    1A,01,02
0332:  DATA    1D,01,77
0334:  DATA    20,01,02
0336:  DATA    23,01,7A
0338:  DATA    25,01,02
033A:  DATA    28,01,7D
033C:  DATA    2B,01,02
033E:  DATA    2D,01,80
0340:  DATA    30,01,02
0342:  DATA    33,01,82
0344:  DATA    36,01,02
0346:  DATA    38,01,85
0348:  DATA    3B,01,02
034A:  DATA    3E,01,88
034C:  DATA    3E,01,02
034E:  DATA    41,01,8B
0350:  DATA    43,01,02
0352:  DATA    46,01,8E
0354:  DATA    49,01,02
0356:  DATA    4C,01,90
0358:  DATA    4F,01,02
035A:  DATA    51,01,93
035C:  DATA    54,01,02
035E:  DATA    57,01,96
0360:  DATA    59,01,02
0362:  DATA    5C,01,99
0364:  DATA    5F,01,02
0366:  DATA    62,01,9B
0368:  DATA    65,01,02
036A:  DATA    67,01,9E
036C:  DATA    6A,01,02
036E:  DATA    6D,01,A1
0370:  DATA    70,01,02
0372:  DATA    70,01,A4
0374:  DATA    72,01,02
0376:  DATA    75,01,A4
0378:  DATA    78,01,02
037A:  DATA    7B,01,A6
037C:  DATA    7D,01,02
037E:  DATA    80,01,A9
0380:  DATA    83,01,02
0382:  DATA    85,01,AC
0384:  DATA    88,01,02
0386:  DATA    8B,01,AE
0388:  DATA    8E,01,02
038A:  DATA    90,01,B1
038C:  DATA    93,01,02
038E:  DATA    96,01,B4
0390:  DATA    99,01,02
0392:  DATA    9B,01,B7
0394:  DATA    9E,01,02
0396:  DATA    A1,01,B9
0398:  DATA    A4,01,02
039A:  DATA    A4,01,BC
039C:  DATA    A6,01,02
039E:  DATA    A9,01,BF
03A0:  DATA    AC,01,02
03A2:  DATA    AF,01,C2
03A4:  DATA    B2,01,02
03A6:  DATA    B4,01,C5
03A8:  DATA    B7,01,02
03AA:  DATA    BA,01,C7
03AC:  DATA    BC,01,02
03AE:  DATA    BF,01,CA
03B0:  DATA    C2,01,02
03B2:  DATA    C5,01,CD
03B4:  DATA    C7,01,02
03B6:  DATA    CA,01,CF
03B8:  DATA    CD,01,02
03BA:  DATA    D0,01,D2
03BC:  DATA    D2,01,02
03BE:  DATA    D5,01,D5
03C0:  DATA    D8,01,02
03C2:  DATA    D8,01,D8
03C4:  DATA    DB,01,02
03C6:  DATA    DD,01,D8
03C8:  DATA    E0,01,02
03CA:  DATA    E3,01,DA
03CC:  DATA    E6,01,02
03CE:  DATA    E9,01,DD
03D0:  DATA    EB,01,02
03D2:  DATA    EE,01,E0
03D4:  DATA    F1,01,02
03D6:  DATA    F3,01,E3
03D8:  DATA    F6,01,02
03DA:  DATA    F9,01,E6
03DC:  DATA    FC,01,02
03DE:  DATA    FF,01,E8
03E0:  DATA    01,02,02
03E2:  DATA    04,02,EB
03E4:  DATA    07,02,02
03E6:  DATA    09,02,EE
03E8:  DATA    09,02,02
03EA:  DATA    0C,02,F1
03EC:  DATA    0F,02,02
03EE:  DATA    12,02,00
03F0:  CLR     32
03F2:  MOV     #158,W3
03F4:  SUB     W0,W3,W3
03F6:  BRA     C,400
03F8:  MOV     #412,W3
03FA:  ADD     W3,W0,W0
03FC:  TBLRDL  [W0],W0
03FE:  RETURN  
0400:  MOV     #412,W0
0402:  BCLR.B  6.0
0404:  ADD     W3,W3,W3
0406:  ADD     W3,W0,W3
0408:  TBLRDH  [W3++],W0
040A:  TBLRDH  [W3],W3
040C:  SL      W3,#8,W3
040E:  IOR      W3,  W0,W0
0410:  RETURN  
0412:  DATA    00,00,15
0414:  DATA    19,00,02
0416:  DATA    1C,00,18
0418:  DATA    1F,00,02
041A:  DATA    22,00,1B
041C:  DATA    26,00,02
041E:  DATA    29,00,1F
0420:  DATA    2C,00,02
0422:  DATA    2F,00,22
0424:  DATA    32,00,02
0426:  DATA    35,00,25
0428:  DATA    35,00,02
042A:  DATA    38,00,28
042C:  DATA    3C,00,02
042E:  DATA    3F,00,2B
0430:  DATA    42,00,02
0432:  DATA    45,00,2E
0434:  DATA    48,00,02
0436:  DATA    4B,00,31
0438:  DATA    4E,00,02
043A:  DATA    52,00,34
043C:  DATA    55,00,02
043E:  DATA    58,00,38
0440:  DATA    5B,00,02
0442:  DATA    5E,00,3B
0444:  DATA    61,00,02
0446:  DATA    64,00,3E
0448:  DATA    67,00,02
044A:  DATA    6B,00,41
044C:  DATA    6E,00,02
044E:  DATA    71,00,44
0450:  DATA    71,00,02
0452:  DATA    74,00,44
0454:  DATA    77,00,02
0456:  DATA    7A,00,47
0458:  DATA    7D,00,02
045A:  DATA    81,00,4A
045C:  DATA    84,00,02
045E:  DATA    87,00,4E
0460:  DATA    8A,00,02
0462:  DATA    8D,00,51
0464:  DATA    90,00,02
0466:  DATA    93,00,54
0468:  DATA    97,00,02
046A:  DATA    9A,00,57
046C:  DATA    9D,00,02
046E:  DATA    A0,00,5A
0470:  DATA    A3,00,02
0472:  DATA    A6,00,5D
0474:  DATA    A9,00,02
0476:  DATA    AC,00,60
0478:  DATA    AC,00,02
047A:  DATA    B0,00,64
047C:  DATA    B3,00,02
047E:  DATA    B6,00,67
0480:  DATA    B9,00,02
0482:  DATA    BC,00,6A
0484:  DATA    BF,00,02
0486:  DATA    C2,00,6D
0488:  DATA    C6,00,02
048A:  DATA    C9,00,70
048C:  DATA    CC,00,02
048E:  DATA    CF,00,73
0490:  DATA    D2,00,02
0492:  DATA    D5,00,76
0494:  DATA    D8,00,02
0496:  DATA    DC,00,7A
0498:  DATA    DF,00,02
049A:  DATA    E2,00,7D
049C:  DATA    E5,00,02
049E:  DATA    E5,00,7D
04A0:  DATA    E8,00,02
04A2:  DATA    EB,00,80
04A4:  DATA    EE,00,02
04A6:  DATA    F1,00,83
04A8:  DATA    F5,00,02
04AA:  DATA    F8,00,86
04AC:  DATA    FB,00,02
04AE:  DATA    FE,00,89
04B0:  DATA    01,01,02
04B2:  DATA    04,01,8C
04B4:  DATA    07,01,02
04B6:  DATA    0B,01,8F
04B8:  DATA    0E,01,02
04BA:  DATA    11,01,92
04BC:  DATA    14,01,02
04BE:  DATA    17,01,96
04C0:  DATA    1A,01,02
04C2:  DATA    1D,01,99
04C4:  DATA    21,01,02
04C6:  DATA    21,01,9C
04C8:  DATA    24,01,02
04CA:  DATA    27,01,9F
04CC:  DATA    2A,01,02
04CE:  DATA    2D,01,A2
04D0:  DATA    30,01,02
04D2:  DATA    33,01,A5
04D4:  DATA    36,01,02
04D6:  DATA    3A,01,A8
04D8:  DATA    3D,01,02
04DA:  DATA    40,01,AC
04DC:  DATA    43,01,02
04DE:  DATA    46,01,AF
04E0:  DATA    49,01,02
04E2:  DATA    4C,01,B2
04E4:  DATA    50,01,02
04E6:  DATA    53,01,B5
04E8:  DATA    56,01,02
04EA:  DATA    59,01,B8
04EC:  DATA    59,01,02
04EE:  DATA    5C,01,B8
04F0:  DATA    5F,01,02
04F2:  DATA    62,01,BB
04F4:  DATA    66,01,02
04F6:  DATA    69,01,BE
04F8:  DATA    6C,01,02
04FA:  DATA    6F,01,C2
04FC:  DATA    72,01,02
04FE:  DATA    75,01,C5
0500:  DATA    78,01,02
0502:  DATA    7B,01,C8
0504:  DATA    7F,01,02
0506:  DATA    82,01,CB
0508:  DATA    85,01,02
050A:  DATA    88,01,CE
050C:  DATA    8B,01,02
050E:  DATA    8E,01,D1
0510:  DATA    91,01,02
0512:  DATA    95,01,D4
0514:  DATA    95,01,02
0516:  DATA    98,01,D8
0518:  DATA    9B,01,02
051A:  DATA    9E,01,DB
051C:  DATA    A1,01,02
051E:  DATA    A4,01,DE
0520:  DATA    A7,01,02
0522:  DATA    AA,01,E1
0524:  DATA    AE,01,02
0526:  DATA    B1,01,E4
0528:  DATA    B4,01,02
052A:  DATA    B7,01,E7
052C:  DATA    BA,01,02
052E:  DATA    BD,01,EA
0530:  DATA    C0,01,02
0532:  DATA    C4,01,ED
0534:  DATA    C7,01,02
0536:  DATA    CA,01,F1
0538:  DATA    CD,01,02
053A:  DATA    D0,01,F4
053C:  DATA    D0,01,02
053E:  DATA    D3,01,F4
0540:  DATA    D6,01,02
0542:  DATA    DA,01,F7
0544:  DATA    DD,01,02
0546:  DATA    E0,01,FA
0548:  DATA    E3,01,02
054A:  DATA    E6,01,FD
054C:  DATA    E9,01,02
054E:  DATA    EC,01,00
0550:  DATA    EF,01,03
0552:  DATA    F3,01,03
0554:  DATA    F6,01,03
0556:  DATA    F9,01,07
0558:  DATA    FC,01,03
055A:  DATA    FF,01,0A
055C:  DATA    02,02,03
055E:  DATA    05,02,0D
0560:  DATA    09,02,03
0562:  DATA    09,02,10
0564:  DATA    0C,02,03
0566:  DATA    0F,02,00
0568:  DATA    12,02,00
056A:  CLR     32
056C:  MOV     #158,W3
056E:  SUB     W0,W3,W3
0570:  BRA     C,57A
0572:  MOV     #58C,W3
0574:  ADD     W3,W0,W0
0576:  TBLRDL  [W0],W0
0578:  RETURN  
057A:  MOV     #58C,W0
057C:  BCLR.B  6.0
057E:  ADD     W3,W3,W3
0580:  ADD     W3,W0,W3
0582:  TBLRDH  [W3++],W0
0584:  TBLRDH  [W3],W3
0586:  SL      W3,#8,W3
0588:  IOR      W3,  W0,W0
058A:  RETURN  
058C:  DATA    00,00,21
058E:  DATA    1C,00,02
0590:  DATA    1F,00,24
0592:  DATA    22,00,02
0594:  DATA    26,00,27
0596:  DATA    29,00,02
0598:  DATA    2D,00,2B
059A:  DATA    31,00,02
059C:  DATA    33,00,2E
059E:  DATA    36,00,02
05A0:  DATA    39,00,31
05A2:  DATA    39,00,02
05A4:  DATA    3D,00,34
05A6:  DATA    40,00,02
05A8:  DATA    43,00,37
05AA:  DATA    47,00,02
05AC:  DATA    49,00,3B
05AE:  DATA    4D,00,02
05B0:  DATA    50,00,3E
05B2:  DATA    53,00,02
05B4:  DATA    56,00,41
05B6:  DATA    5A,00,02
05B8:  DATA    5D,00,44
05BA:  DATA    60,00,02
05BC:  DATA    64,00,47
05BE:  DATA    66,00,02
05C0:  DATA    69,00,4B
05C2:  DATA    6D,00,02
05C4:  DATA    70,00,4E
05C6:  DATA    73,00,02
05C8:  DATA    77,00,51
05CA:  DATA    76,00,02
05CC:  DATA    79,00,51
05CE:  DATA    7D,00,02
05D0:  DATA    80,00,54
05D2:  DATA    83,00,02
05D4:  DATA    86,00,57
05D6:  DATA    89,00,02
05D8:  DATA    8C,00,5B
05DA:  DATA    8F,00,02
05DC:  DATA    92,00,5E
05DE:  DATA    95,00,02
05E0:  DATA    98,00,61
05E2:  DATA    9A,00,02
05E4:  DATA    9F,00,64
05E6:  DATA    A2,00,02
05E8:  DATA    A5,00,67
05EA:  DATA    A8,00,02
05EC:  DATA    AC,00,6B
05EE:  DATA    AF,00,02
05F0:  DATA    B2,00,6E
05F2:  DATA    B2,00,02
05F4:  DATA    B5,00,71
05F6:  DATA    B9,00,02
05F8:  DATA    BB,00,74
05FA:  DATA    BF,00,02
05FC:  DATA    C3,00,77
05FE:  DATA    C6,00,02
0600:  DATA    C8,00,7B
0602:  DATA    CD,00,02
0604:  DATA    D1,00,7E
0606:  DATA    D3,00,02
0608:  DATA    D6,00,81
060A:  DATA    D8,00,02
060C:  DATA    DC,00,84
060E:  DATA    DF,00,02
0610:  DATA    E2,00,87
0612:  DATA    E5,00,02
0614:  DATA    E8,00,8B
0616:  DATA    EC,00,02
0618:  DATA    ED,00,8B
061A:  DATA    EE,00,02
061C:  DATA    F2,00,8E
061E:  DATA    F5,00,02
0620:  DATA    F8,00,91
0622:  DATA    FC,00,02
0624:  DATA    00,01,94
0626:  DATA    02,01,02
0628:  DATA    05,01,98
062A:  DATA    08,01,02
062C:  DATA    0C,01,9B
062E:  DATA    0F,01,02
0630:  DATA    12,01,9E
0632:  DATA    16,01,02
0634:  DATA    18,01,A1
0636:  DATA    1C,01,02
0638:  DATA    20,01,A4
063A:  DATA    23,01,02
063C:  DATA    25,01,A7
063E:  DATA    27,01,02
0640:  DATA    29,01,AB
0642:  DATA    2B,01,02
0644:  DATA    2E,01,AE
0646:  DATA    31,01,02
0648:  DATA    34,01,B1
064A:  DATA    38,01,02
064C:  DATA    3B,01,B4
064E:  DATA    3E,01,02
0650:  DATA    41,01,B7
0652:  DATA    44,01,02
0654:  DATA    48,01,BB
0656:  DATA    4C,01,02
0658:  DATA    4F,01,BE
065A:  DATA    52,01,02
065C:  DATA    55,01,C1
065E:  DATA    58,01,02
0660:  DATA    5B,01,C4
0662:  DATA    5E,01,02
0664:  DATA    61,01,C8
0666:  DATA    61,01,02
0668:  DATA    64,01,C8
066A:  DATA    67,01,02
066C:  DATA    6B,01,CA
066E:  DATA    6E,01,02
0670:  DATA    71,01,CE
0672:  DATA    74,01,02
0674:  DATA    77,01,D1
0676:  DATA    7B,01,02
0678:  DATA    7E,01,D4
067A:  DATA    81,01,02
067C:  DATA    84,01,D8
067E:  DATA    87,01,02
0680:  DATA    8B,01,DB
0682:  DATA    8E,01,02
0684:  DATA    91,01,DE
0686:  DATA    94,01,02
0688:  DATA    97,01,E1
068A:  DATA    9B,01,02
068C:  DATA    9E,01,E4
068E:  DATA    9E,01,02
0690:  DATA    A1,01,E7
0692:  DATA    A4,01,02
0694:  DATA    A7,01,EB
0696:  DATA    AB,01,02
0698:  DATA    AE,01,EE
069A:  DATA    B1,01,02
069C:  DATA    B4,01,F1
069E:  DATA    B7,01,02
06A0:  DATA    BB,01,F4
06A2:  DATA    BE,01,02
06A4:  DATA    C1,01,F8
06A6:  DATA    C4,01,02
06A8:  DATA    C7,01,FB
06AA:  DATA    CB,01,02
06AC:  DATA    CE,01,FE
06AE:  DATA    D1,01,02
06B0:  DATA    D4,01,01
06B2:  DATA    D7,01,03
06B4:  DATA    DB,01,04
06B6:  DATA    DB,01,03
06B8:  DATA    DE,01,04
06BA:  DATA    E1,01,03
06BC:  DATA    E4,01,07
06BE:  DATA    E7,01,03
06C0:  DATA    EB,01,0B
06C2:  DATA    EE,01,03
06C4:  DATA    F1,01,0E
06C6:  DATA    F4,01,03
06C8:  DATA    F7,01,11
06CA:  DATA    FB,01,03
06CC:  DATA    FE,01,14
06CE:  DATA    01,02,03
06D0:  DATA    04,02,17
06D2:  DATA    07,02,03
06D4:  DATA    0B,02,1A
06D6:  DATA    0E,02,03
06D8:  DATA    11,02,1E
06DA:  DATA    14,02,03
06DC:  DATA    14,02,21
06DE:  DATA    17,02,03
06E0:  DATA    1B,02,00
06E2:  DATA    1E,02,00
06E4:  CLR     32
06E6:  MOV     #6F0,W3
06E8:  ADD     W3,W0,W0
06EA:  TBLRDL.B[W0],W0L
06EC:  CLR.B   1
06EE:  RETURN  
06F0:  DATA    0A,4D,00
06F2:  DATA    6F,74,00
06F4:  DATA    6F,72,00
06F6:  DATA    20,43,00
06F8:  DATA    6F,6E,00
06FA:  DATA    74,72,00
06FC:  DATA    6F,6C,00
06FE:  DATA    20,55,00
0700:  DATA    6E,69,00
0702:  DATA    74,20,00
0704:  DATA    76,30,00
0706:  DATA    2E,31,00
0708:  DATA    0D,0A,00
070A:  DATA    00,00,00
070C:  PUSH    42
070E:  PUSH    36
0710:  PUSH    32
0712:  MOV     W0,[W15++]
0714:  MOV     #2,W0
0716:  REPEAT  #C
0718:  MOV     [W0++],[W15++]
071A:  MOV     #800,W0
071C:  MOV     864,W4
071E:  ADD     W0,W4,W1
0720:  MOV     212,W0
0722:  BCLR.B  85.1
0724:  MOV.B   W0L,[W1++]
0726:  INC     0864
0728:  MOV     #63,W4
072A:  MOV     864,W3
072C:  SUB     W4,W3,W0
072E:  BRA     C,732
0730:  CLR     864
0732:  BTSC.B  20E.0
0734:  BRA     720
*
07AC:  MOV     W5,[W15++]
07AE:  MOV     #C,W5
07B0:  REPEAT  #3
07B2:  MOV     [W5++],[W15++]
07B4:  MUL.UU  W0,W2,W4
07B6:  BTSS    W3.F
07B8:  BRA     7BE
07BA:  MUL.SS  W0,W3,W6
07BC:  BRA     7C0
07BE:  MUL.UU  W0,W3,W6
07C0:  BCLR.B  42.0
07C2:  ADD     W6,W5,W5
07C4:  ADDC    W7,#0,W8
07C6:  BTSS    W1.F
07C8:  BRA     7CE
07CA:  MUL.SS  W1,W2,W6
07CC:  BRA     7D0
07CE:  MUL.UU  W1,W2,W6
07D0:  ADDC    W6,W5,W5
07D2:  ADDC    W7,W8,W8
07D4:  ADDC    #0,W9
07D6:  MUL.SS  W1,W3,W6
07D8:  ADDC    W6,W8,W8
07DA:  ADDC    W9,W7,W7
07DC:  MOV     W7,W3
07DE:  MOV     W8,W2
07E0:  MOV     W5,W1
07E2:  MOV     W4,W0
07E4:  MOV     #12,W5
07E6:  REPEAT  #3
07E8:  MOV     [--W15],[W5--]
07EA:  MOV     [--W15],W5
07EC:  RETURN  
*
0CC6:  MOV     W1,[W15++]
0CC8:  MOV     A7C,W1
0CCA:  MOV.B   W0L,[W1++]
0CCC:  CLR.B   [W1]
0CCE:  MOV     [--W15],W1
0CD0:  INC     0A7C
0CD2:  RETURN  
*
0D2C:  MOV     W5,[W15++]
0D2E:  MOV     #C,W5
0D30:  REPEAT  #3
0D32:  MOV     [W5++],[W15++]
0D34:  MOV     W0,W4
0D36:  MOV     W1,W5
0D38:  MOV     W2,W6
0D3A:  MOV     W3,W7
0D3C:  CLR     W0
0D3E:  CLR     W1
0D40:  CLR     W2
0D42:  CLR     W3
0D44:  BCLR    W8.0
0D46:  BTSS    W7.F
0D48:  BRA     D5A
0D4A:  BSET    W8.0
0D4C:  COM     W7,W7
0D4E:  COM     W6,W6
0D50:  COM     W5,W5
0D52:  NEG     W4,W4
0D54:  ADDC    W5,#0,W5
0D56:  ADDC    W6,#0,W6
0D58:  ADDC    W7,#0,W7
0D5A:  IOR      W4,  W5,W9
0D5C:  BRA     NZ,D62
0D5E:  IOR      W6,  W7,W9
0D60:  BRA     Z,D8C
0D62:  MOV     #473,W9
0D64:  BTSC    W3.4
0D66:  BRA     D7E
0D68:  BCLR.B  42.0
0D6A:  RLC     W4,W4
0D6C:  RLC     W5,W5
0D6E:  RLC     W6,W6
0D70:  RLC     W7,W7
0D72:  RLC     W0,W0
0D74:  RLC     W1,W1
0D76:  RLC     W2,W2
0D78:  RLC     W3,W3
0D7A:  DEC     W9,W9
0D7C:  BRA     NZ,D64
0D7E:  SL      W9,#4,W9
0D80:  BCLR.B  42.0
0D82:  BCLR    W9.F
0D84:  BCLR    W3.4
0D86:  XOR     W9,W3,W3
0D88:  BTSC    W8.0
0D8A:  BSET    W3.F
0D8C:  MOV     #12,W5
0D8E:  REPEAT  #3
0D90:  MOV     [--W15],[W5--]
0D92:  MOV     [--W15],W5
0D94:  RETURN  
0D96:  MOV     W8,[W15++]
0D98:  MOV     #12,W8
0D9A:  REPEAT  #4
0D9C:  MOV     [W8++],[W15++]
0D9E:  CLR     W11
0DA0:  MUL.UU  W12,#0,W12
0DA2:  MOV     W3,W8
0DA4:  MOV     W7,W9
0DA6:  MOV     #7FF,W10
0DA8:  BCLR.B  42.0
0DAA:  BCLR.B  42.1
0DAC:  ASR     W8,#4,W8
0DAE:  AND     W10,W8,W8
0DB0:  CP0     W8
0DB2:  BRA     Z,E96
0DB4:  BCLR.B  42.0
0DB6:  BCLR.B  42.1
0DB8:  ASR     W9,#4,W9
0DBA:  AND     W10,W9,W9
0DBC:  CP0     W9
0DBE:  BRA     Z,E96
0DC0:  ADD     W9,W8,W8
0DC2:  BTSC    W9.B
0DC4:  BRA     DCE
0DC6:  SUB     #3FF,W8
0DC8:  BRA     Z,E96
0DCA:  BRA     NC,E96
0DCC:  BRA     DD4
0DCE:  MOV     #401,W10
0DD0:  ADD.B   W10L,W5L,W5L
0DD2:  BRA     C,E96
0DD4:  XOR     W3,W7,W13
0DD6:  BCLR.B  42.0
0DD8:  BCLR.B  42.1
0DDA:  AND     #F,W3
0DDC:  BSET    W3.4
0DDE:  AND     #F,W7
0DE0:  BSET    W7.4
0DE2:  MOV     W8,[W15++]
0DE4:  MUL.UU  W4,W1,W8
0DE6:  MUL.UU  W5,W0,W10
0DE8:  ADD     W8,W10,W10
0DEA:  ADDC    W9,W11,W11
0DEC:  ADDC    #0,W12
0DEE:  MUL.UU  W4,W2,W8
0DF0:  ADD     W8,W11,W11
0DF2:  ADDC    W9,W12,W12
0DF4:  MUL.UU  W5,W1,W8
0DF6:  CLR     W10
0DF8:  ADD     W8,W11,W11
0DFA:  ADDC    W9,W12,W12
0DFC:  ADDC    #0,W10
0DFE:  MUL.UU  W6,W0,W8
0E00:  ADD     W8,W11,W11
0E02:  ADDC    W9,W12,W12
0E04:  ADDC    #0,W10
0E06:  CLR     W11
0E08:  MUL.UU  W4,W3,W8
0E0A:  ADD     W8,W12,W12
0E0C:  ADDC    W9,W10,W10
0E0E:  ADDC    #0,W11
0E10:  MUL.UU  W5,W2,W8
0E12:  ADD     W8,W12,W12
0E14:  ADDC    W9,W10,W10
0E16:  ADDC    #0,W11
0E18:  MUL.UU  W6,W1,W8
0E1A:  ADD     W8,W12,W12
0E1C:  ADDC    W9,W10,W10
0E1E:  ADDC    #0,W11
0E20:  MUL.UU  W7,W0,W8
0E22:  ADD     W8,W12,W12
0E24:  ADDC    W9,W10,W10
0E26:  ADDC    #0,W11
0E28:  MOV     W12,W0
0E2A:  CLR     W12
0E2C:  MUL.UU  W5,W3,W8
0E2E:  ADD     W8,W10,W10
0E30:  ADDC    W9,W11,W11
0E32:  ADDC    #0,W12
0E34:  MUL.UU  W6,W2,W8
0E36:  ADD     W8,W10,W10
0E38:  ADDC    W9,W11,W11
0E3A:  ADDC    #0,W12
0E3C:  MUL.UU  W6,W3,W8
0E3E:  ADD     W8,W11,W11
0E40:  ADDC    W9,W12,W12
0E42:  MUL.UU  W7,W1,W8
0E44:  ADD     W8,W10,W10
0E46:  ADDC    W9,W11,W11
0E48:  ADDC    #0,W12
0E4A:  MUL.UU  W7,W2,W8
0E4C:  ADD     W8,W11,W11
0E4E:  ADDC    W9,W12,W12
0E50:  MUL.UU  W7,W3,W8
0E52:  ADD     W8,W12,W12
0E54:  MOV     W10,W1
0E56:  MOV     W11,W2
0E58:  MOV     W12,W3
0E5A:  MOV     #5,W4
0E5C:  BCLR.B  42.0
0E5E:  RRC     W3,W3
0E60:  RRC     W2,W2
0E62:  RRC     W1,W1
0E64:  RRC     W0,W0
0E66:  DEC     W4,W4
0E68:  BRA     NZ,E5C
0E6A:  MOV     [--W15],W8
0E6C:  INC     W8,W8
0E6E:  IOR      W0,  W1,W6
0E70:  BRA     Z,E74
0E72:  BRA     E78
0E74:  IOR      W2,  W3,W6
0E76:  BRA     Z,E88
0E78:  BTSC    W3.4
0E7A:  BRA     E88
0E7C:  BCLR.B  42.0
0E7E:  RLC     W0,W0
0E80:  RLC     W1,W1
0E82:  RLC     W2,W2
0E84:  RLC     W3,W3
0E86:  DEC     W8,W8
0E88:  SL      W8,#4,W8
0E8A:  BCLR    W3.F
0E8C:  BTSC    W13.F
0E8E:  BSET    W3.F
0E90:  BCLR    W3.4
0E92:  XOR     W8,W3,W3
0E94:  BRA     E9C
0E96:  MUL.UU  W0,#0,W0
0E98:  MUL.UU  W0,#0,W2
0E9A:  BRA     E9C
0E9C:  MOV     #1A,W8
0E9E:  REPEAT  #4
0EA0:  MOV     [--W15],[W8--]
0EA2:  MOV     [--W15],W8
0EA4:  RETURN  
0EA6:  MOV     W8,[W15++]
0EA8:  MOV     #12,W8
0EAA:  REPEAT  #4
0EAC:  MOV     [W8++],[W15++]
0EAE:  XOR     W3,W7,W13
0EB0:  MOV     W3,W8
0EB2:  MOV     W7,W9
0EB4:  MOV     #7FF,W10
0EB6:  BCLR.B  42.0
0EB8:  BCLR.B  42.1
0EBA:  ASR     W8,#4,W8
0EBC:  AND     W10,W8,W8
0EBE:  CP0     W8
0EC0:  BRA     Z,F9A
0EC2:  BCLR.B  42.0
0EC4:  BCLR.B  42.1
0EC6:  ASR     W9,#4,W9
0EC8:  AND     W10,W9,W9
0ECA:  CP0     W9
0ECC:  BRA     Z,F9A
0ECE:  CLR     W10
0ED0:  SUB     W8,W9,W12
0ED2:  BRA     NC,EDA
0ED4:  ADD     #3FF,W12
0ED6:  BRA     C,F9A
0ED8:  BRA     EE2
0EDA:  MOV     #401,W11
0EDC:  SUB     W12,W11,W12
0EDE:  BRA     NC,F9A
0EE0:  BRA     Z,F9A
0EE2:  CLR     W8
0EE4:  CLR     W9
0EE6:  CLR     W10
0EE8:  CLR     W11
0EEA:  AND     #1F,W3
0EEC:  BSET    W3.4
0EEE:  AND     #1F,W7
0EF0:  BSET    W7.4
0EF2:  MOV     W12,[W15++]
0EF4:  MOV     #36,W12
0EF6:  SUB     W0,W4,W0
0EF8:  SUBB    W1,W5,W1
0EFA:  SUBB    W2,W6,W2
0EFC:  SUBB    W3,W7,W3
0EFE:  BRA     N,F04
0F00:  BRA     C,F0E
0F02:  BRA     NZ,F10
0F04:  ADD     W0,W4,W0
0F06:  ADDC    W1,W5,W1
0F08:  ADDC    W2,W6,W2
0F0A:  ADDC    W3,W7,W3
0F0C:  BRA     F10
0F0E:  BSET    W8.0
0F10:  DEC     W12,W12
0F12:  BRA     Z,F2A
0F14:  BCLR.B  42.0
0F16:  RLC     W0,W0
0F18:  RLC     W1,W1
0F1A:  RLC     W2,W2
0F1C:  RLC     W3,W3
0F1E:  BCLR.B  42.0
0F20:  RLC     W8,W8
0F22:  RLC     W9,W9
0F24:  RLC     W10,W10
0F26:  RLC     W11,W11
0F28:  BRA     EF6
0F2A:  MOV     [--W15],W12
0F2C:  BTSC    W11.5
0F2E:  BRA     F32
0F30:  BRA     F3E
0F32:  BCLR.B  42.0
0F34:  RRC     W11,W11
0F36:  RRC     W10,W10
0F38:  RRC     W9,W9
0F3A:  RRC     W8,W8
0F3C:  BRA     F44
0F3E:  DEC     W12,W12
0F40:  BCLR.B  42.0
0F42:  BRA     Z,F9A
0F44:  BTSC.B  42.0
0F46:  BRA     F5A
0F48:  RLC     W0,W0
0F4A:  RLC     W1,W1
0F4C:  RLC     W2,W2
0F4E:  RLC     W3,W3
0F50:  SUB     W0,W4,W4
0F52:  SUBB    W1,W5,W5
0F54:  SUBB    W2,W6,W6
0F56:  SUBB    W3,W7,W7
0F58:  BRA     NC,F84
0F5A:  INC     W8,W8
0F5C:  BRA     NZ,F84
0F5E:  INC     W9,W9
0F60:  BRA     NZ,F84
0F62:  INC     W10,W10
0F64:  BRA     NZ,F84
0F66:  INC     W11,W11
0F68:  BRA     NZ,F84
0F6A:  INC     W12,W12
0F6C:  BRA     Z,F9A
0F6E:  BRA     F84
0F70:  DEC     W12,W12
0F72:  BRA     Z,F9A
0F74:  BTSC    W11.4
0F76:  BRA     F84
0F78:  BCLR.B  42.0
0F7A:  RLC     W8,W8
0F7C:  RLC     W9,W9
0F7E:  RLC     W10,W10
0F80:  RLC     W11,W11
0F82:  BRA     F74
0F84:  SL      W12,#4,W12
0F86:  BCLR.B  42.0
0F88:  BCLR    W12.F
0F8A:  BTSC    W13.F
0F8C:  BSET    W12.F
0F8E:  BCLR    W11.4
0F90:  XOR     W12,W11,W3
0F92:  MOV     W10,W2
0F94:  MOV     W9,W1
0F96:  MOV     W8,W0
0F98:  BRA     FA4
0F9A:  MOV     #0,W0
0F9C:  MOV     #0,W1
0F9E:  MOV     #0,W2
0FA0:  MOV     #0,W3
0FA2:  BRA     FA4
0FA4:  MOV     #1A,W8
0FA6:  REPEAT  #4
0FA8:  MOV     [--W15],[W8--]
0FAA:  MOV     [--W15],W8
0FAC:  RETURN  
0FAE:  MOV     W8,[W15++]
0FB0:  MOV     #12,W8
0FB2:  REPEAT  #4
0FB4:  MOV     [W8++],[W15++]
0FB6:  MOV     #8000,W8
0FB8:  BTSC.B  43.0
0FBA:  XOR     W8,W7,W7
0FBC:  CP0     W0
0FBE:  BRA     NZ,FCE
0FC0:  CP0     W1
0FC2:  BRA     NZ,FCE
0FC4:  CP0     W2
0FC6:  BRA     NZ,FCE
0FC8:  MOV     #7FFF,W10
0FCA:  AND     W3,W10,W10
0FCC:  BTSS.B  42.1
0FCE:  MOV     W3,W10
0FD0:  XOR     W7,W10,W11
0FD2:  MOV     W3,W8
0FD4:  MOV     W7,W9
0FD6:  MOV     W7,W12
0FD8:  MOV     #7FF,W13
0FDA:  BCLR.B  42.1
0FDC:  BCLR.B  42.0
0FDE:  ASR     W8,#4,W8
0FE0:  AND     W13,W8,W8
0FE2:  CP0     W8
0FE4:  BRA     Z,115E
0FE6:  BCLR.B  42.1
0FE8:  BCLR.B  42.0
0FEA:  ASR     W9,#4,W9
0FEC:  AND     W13,W9,W9
0FEE:  CP0     W9
0FF0:  BRA     Z,116E
0FF2:  CLR     W13
0FF4:  BCLR.B  42.1
0FF6:  BCLR.B  42.0
0FF8:  CP      W9,W8
0FFA:  BRA     Z,1170
0FFC:  BRA     N,1180
0FFE:  BCLR    W13.0
1000:  BSET    W13.1
1002:  SUB     W9,W8,W8
1004:  AND     #F,W3
1006:  BSET    W3.4
1008:  AND     #F,W7
100A:  BSET    W7.4
100C:  SUB     #34,W8
100E:  BRA     NN,103C
1010:  ADD     #34,W8
1012:  BCLR.B  42.1
1014:  BCLR.B  42.0
1016:  RRC     W3,W3
1018:  RRC     W2,W2
101A:  RRC     W1,W1
101C:  RRC     W0,W0
101E:  DEC     W8,W8
1020:  BRA     NZ,1012
1022:  BRA     104C
1024:  SUB     #34,W8
1026:  BRA     NN,1046
1028:  ADD     #34,W8
102A:  BCLR.B  42.1
102C:  BCLR.B  42.0
102E:  RRC     W7,W7
1030:  RRC     W6,W6
1032:  RRC     W5,W5
1034:  RRC     W4,W4
1036:  DEC     W8,W8
1038:  BRA     NZ,102A
103A:  BRA     1072
103C:  MOV     W4,W0
103E:  MOV     W5,W1
1040:  MOV     W6,W2
1042:  MOV     W7,W3
1044:  XOR     W11,W12,W12
1046:  BTSC    W12.F
1048:  BTG     W11.F
104A:  BRA     113E
104C:  BTSS    W11.F
104E:  BRA     108E
1050:  BTSC    W13.4
1052:  MOV     W12,W11
1054:  COM     W0,W0
1056:  COM     W1,W1
1058:  COM     W2,W2
105A:  COM.B   W3L,W3L
105C:  AND.B   #1F,W3L
105E:  INC     W0,W0
1060:  BRA     NZ,106C
1062:  INC     W1,W1
1064:  BRA     NZ,106C
1066:  INC     W2,W2
1068:  BRA     NZ,106C
106A:  INC.B   W3L,W3L
106C:  BTSC    W13.4
106E:  BRA     10D4
1070:  BRA     108E
1072:  BTSS    W11.F
1074:  BRA     108E
1076:  COM     W4,W4
1078:  COM     W5,W5
107A:  COM     W6,W6
107C:  COM.B   W7L,W7L
107E:  AND.B   #1F,W7L
1080:  INC     W4,W4
1082:  BRA     NZ,108E
1084:  INC     W5,W5
1086:  BRA     NZ,108E
1088:  INC     W6,W6
108A:  BRA     NZ,108E
108C:  INC.B   W7L,W7L
108E:  BCLR.B  42.1
1090:  BCLR.B  42.0
1092:  ADD     W0,W4,W0
1094:  ADDC    W1,W5,W1
1096:  ADDC    W2,W6,W2
1098:  ADDC.B  W3L,W7L,W3L
109A:  BTSC    W3.5
109C:  BSET    W13.3
109E:  BTSC    W13.0
10A0:  BRA     10B4
10A2:  BTSC    W13.1
10A4:  BRA     10A8
10A6:  BRA     10BE
10A8:  BTSC    W11.F
10AA:  BRA     10D4
10AC:  BTSC    W13.3
10AE:  BRA     1102
10B0:  BSET    W13.6
10B2:  BRA     10F6
10B4:  BTSC    W11.F
10B6:  BRA     10D4
10B8:  BTSC    W13.3
10BA:  BRA     1102
10BC:  BRA     10F6
10BE:  BTSC    W11.F
10C0:  BRA     10CA
10C2:  MOV     W10,W11
10C4:  BTSC    W13.3
10C6:  BRA     1102
10C8:  BRA     113E
10CA:  BSET    W13.4
10CC:  XOR.B   #10,W3L
10CE:  BTSC    W3.4
10D0:  BRA     1050
10D2:  MOV     W10,W11
10D4:  AND     #1F,W3
10D6:  IOR      W3,  W2,W8
10D8:  BRA     NZ,10DE
10DA:  IOR      W1,  W0,W8
10DC:  BRA     Z,10F6
10DE:  BTSC    W3.4
10E0:  BRA     10F6
10E2:  BCLR.B  42.1
10E4:  BCLR.B  42.0
10E6:  RLC     W0,W0
10E8:  RLC     W1,W1
10EA:  RLC     W2,W2
10EC:  RLC     W3,W3
10EE:  DEC     W9,W9
10F0:  BTSC.B  42.1
10F2:  BRA     1158
10F4:  BRA     10DE
10F6:  BTSC    W13.0
10F8:  MOV     W10,W11
10FA:  BTSC    W13.1
10FC:  MOV     W12,W11
10FE:  BTSS    W13.5
1100:  BRA     113E
1102:  BCLR.B  42.0
1104:  RRC.B   W3L,W3L
1106:  RRC     W2,W2
1108:  RRC     W1,W1
110A:  RRC     W0,W0
110C:  BTSC.B  42.0
110E:  BSET    W13.5
1110:  INC     W9,W9
1112:  BTSC.B  42.1
1114:  BRA     1158
1116:  BTSS    W13.5
1118:  BRA     1136
111A:  INC     W0,W0
111C:  BRA     NZ,1136
111E:  INC     W1,W1
1120:  BRA     NZ,1136
1122:  INC     W2,W2
1124:  BRA     NZ,1136
1126:  INC     W3,W3
1128:  BRA     NZ,1136
112A:  RRC.B   W3L,W3L
112C:  RRC     W2,W2
112E:  RRC     W1,W1
1130:  RRC     W0,W0
1132:  INC     W9,W9
1134:  BRA     Z,1158
1136:  BTSC    W13.0
1138:  MOV     W10,W11
113A:  BTSC    W13.1
113C:  MOV     W12,W11
113E:  IOR      W0,  W1,W4
1140:  BRA     NZ,1146
1142:  IOR      W2,  W3,W4
1144:  BRA     Z,1192
1146:  BCLR    W3.4
1148:  BCLR.B  42.1
114A:  BCLR.B  42.0
114C:  SL      W9,#4,W9
114E:  XOR     W9,W3,W3
1150:  BSET    W3.F
1152:  BTSS    W11.F
1154:  BCLR    W3.F
1156:  BRA     1192
1158:  MUL.UU  W0,#0,W0
115A:  MUL.UU  W2,#0,W2
115C:  BRA     1192
115E:  MOV     #8000,W8
1160:  BTSC    W10.F
1162:  XOR     W8,W7,W7
1164:  MOV     W5,W1
1166:  MOV     W4,W0
1168:  MOV     W6,W2
116A:  MOV     W7,W3
116C:  BRA     1192
116E:  BRA     1192
1170:  AND     #F,W7
1172:  BSET    W7.4
1174:  AND     #F,W3
1176:  BSET    W3.4
1178:  BTSC    W11.F
117A:  BCLR    W7.4
117C:  BSET    W13.2
117E:  BRA     1072
1180:  AND     #F,W3
1182:  BSET    W3.4
1184:  AND     #F,W7
1186:  BSET    W7.4
1188:  SUB     W8,W9,W8
118A:  ADD     W8,W9,W9
118C:  BCLR    W13.1
118E:  BSET    W13.0
1190:  BRA     1024
1192:  MOV     #1A,W8
1194:  REPEAT  #4
1196:  MOV     [--W15],[W8--]
1198:  MOV     [--W15],W8
119A:  RETURN  
119C:  MOV     W8,[W15++]
119E:  MOV     W9,[W15++]
11A0:  MOV     W10,[W15++]
11A2:  XOR     W3,W7,W9
11A4:  BTSS    W9.F
11A6:  BRA     11B4
11A8:  BCLR.B  42.0
11AA:  BCLR.B  42.1
11AC:  BTSS    W3.F
11AE:  BRA     1218
11B0:  BSET.B  42.0
11B2:  BRA     1218
11B4:  MOV     #7FF,W10
11B6:  MOV     W3,W8
11B8:  MOV     W7,W9
11BA:  ASR     W8,#4,W8
11BC:  AND     W10,W8,W8
11BE:  ASR     W9,#4,W9
11C0:  AND     W10,W9,W9
11C2:  SUB     W9,W8,W10
11C4:  BRA     Z,11D0
11C6:  BTSS    W3.F
11C8:  BRA     1218
11CA:  MOV     #1,W0
11CC:  XOR.B   42
11CE:  BRA     1218
11D0:  MOV     W3,W8
11D2:  MOV     W7,W9
11D4:  AND     #1F,W3
11D6:  AND     #1F,W7
11D8:  BCLR    W3.4
11DA:  BCLR    W7.4
11DC:  SUB.B   W7L,W3L,W10L
11DE:  BRA     Z,11EA
11E0:  BTSS    W8.F
11E2:  BRA     1218
11E4:  MOV     #1,W0
11E6:  XOR.B   42
11E8:  BRA     1218
11EA:  SUB     W6,W2,W10
11EC:  BRA     Z,11F8
11EE:  BTSS    W8.F
11F0:  BRA     1218
11F2:  MOV     #1,W0
11F4:  XOR.B   42
11F6:  BRA     1218
11F8:  SUB     W5,W1,W10
11FA:  BRA     Z,1206
11FC:  BTSS    W8.F
11FE:  BRA     1218
1200:  MOV     #1,W0
1202:  XOR.B   42
1204:  BRA     1218
1206:  SUB     W4,W0,W10
1208:  BRA     Z,1214
120A:  BTSS    W8.F
120C:  BRA     1218
120E:  MOV     #1,W0
1210:  XOR.B   42
1212:  BRA     1218
1214:  BCLR.B  42.0
1216:  BRA     1218
1218:  MOV     [--W15],W10
121A:  MOV     [--W15],W9
121C:  MOV     [--W15],W8
121E:  RETURN  
1220:  MOV     W5,[W15++]
1222:  MOV     #C,W5
1224:  REPEAT  #5
1226:  MOV     [W5++],[W15++]
1228:  MOV     W3,W8
122A:  MOV     W2,W7
122C:  MOV     W1,W6
122E:  MOV     W0,W5
1230:  MOV     W3,W9
1232:  MOV     #473,W11
1234:  ASR     W3,#4,W3
1236:  MOV     #7FF,W10
1238:  AND     W10,W3,W3
123A:  SUB     W11,W3,W11
123C:  AND     #1F,W8
123E:  BSET    W8.4
1240:  CLR     W0
1242:  CLR     W1
1244:  CLR     W2
1246:  CLR     W3
1248:  BCLR.B  42.0
124A:  RRC     W8,W8
124C:  RRC     W7,W7
124E:  RRC     W6,W6
1250:  RRC     W5,W5
1252:  RRC     W3,W3
1254:  RRC     W2,W2
1256:  RRC     W1,W1
1258:  RRC     W0,W0
125A:  DEC     W11,W11
125C:  BRA     NZ,1248
125E:  BTSS    W9.F
1260:  BRA     1274
1262:  COM     W0,W0
1264:  COM     W1,W1
1266:  COM     W2,W2
1268:  COM     W3,W3
126A:  INC     W0,W0
126C:  ADDC    #0,W1
126E:  ADDC    #0,W2
1270:  ADDC    #0,W3
1272:  BRA     1274
1274:  MOV     #16,W5
1276:  REPEAT  #5
1278:  MOV     [--W15],[W5--]
127A:  MOV     [--W15],W5
127C:  RETURN  
*
1562:  MOV     W5,[W15++]
1564:  MOV     #C,W5
1566:  REPEAT  #5
1568:  MOV     [W5++],[W15++]
156A:  MOV     W3,W8
156C:  MOV     W2,W7
156E:  MOV     W1,W6
1570:  MOV     W0,W5
1572:  MOV     W3,W9
1574:  MOV     #473,W11
1576:  ASR     W3,#4,W3
1578:  MOV     #7FF,W10
157A:  AND     W10,W3,W3
157C:  SUB     W11,W3,W11
157E:  AND     #1F,W8
1580:  BSET    W8.4
1582:  CLR     W0
1584:  CLR     W1
1586:  CLR     W2
1588:  CLR     W3
158A:  BCLR.B  42.0
158C:  RRC     W8,W8
158E:  RRC     W7,W7
1590:  RRC     W6,W6
1592:  RRC     W5,W5
1594:  RRC     W3,W3
1596:  RRC     W2,W2
1598:  RRC     W1,W1
159A:  RRC     W0,W0
159C:  DEC     W11,W11
159E:  BRA     NZ,158A
15A0:  BTSS    W9.F
15A2:  BRA     15B6
15A4:  COM     W0,W0
15A6:  COM     W1,W1
15A8:  COM     W2,W2
15AA:  COM     W3,W3
15AC:  INC     W0,W0
15AE:  ADDC    #0,W1
15B0:  ADDC    #0,W2
15B2:  ADDC    #0,W3
15B4:  BRA     15B6
15B6:  MOV     #16,W5
15B8:  REPEAT  #5
15BA:  MOV     [--W15],[W5--]
15BC:  MOV     [--W15],W5
15BE:  RETURN  
*
1696:  MOV     W5,[W15++]
1698:  MOV     #C,W5
169A:  REPEAT  #3
169C:  MOV     [W5++],[W15++]
169E:  BTSS    W0.F
16A0:  BRA     16C0
16A2:  NEG     W0,W0
16A4:  BSET    W4.8
16A6:  BTSS    W4.F
16A8:  BRA     16C0
16AA:  MOV     W0,[W15++]
16AC:  MOV     #2D,W0
16AE:  MOV     W4,[W15++]
16B0:  MOV     W0,[W15++]
16B2:  MOV     [--W15],W0
16B4:  CALL    CC6
16B8:  MOV     [--W15],W4
16BA:  MOV     [--W15],W0
16BC:  BCLR    W4.8
16BE:  DEC.B   0008
16C0:  CLR     W5
16C2:  MOV     W0,W7
16C4:  MOV     W4,W9
16C6:  BCLR    W4.F
16C8:  CP0.B   W4L
16CA:  BRA     NZ,16D8
16CC:  BTSC    W9.F
16CE:  BRA     16D4
16D0:  MOV     #0,W5
16D2:  BRA     1702
16D4:  MOV     #0,W5
16D6:  BRA     1702
16D8:  BTSS    W9.8
16DA:  SUB.B   W4L,#6,W5L
16DC:  BTSC    W9.8
16DE:  SUB.B   W4L,#7,W5L
16E0:  BRA     NC,1700
16E2:  MOV     #30,W0
16E4:  BTSS    W9.F
16E6:  MOV     #20,W0
16E8:  MOV     W0,[W15++]
16EA:  MOV     W4,[W15++]
16EC:  MOV     W0,[W15++]
16EE:  MOV     [--W15],W0
16F0:  CALL    CC6
16F4:  MOV     [--W15],W4
16F6:  MOV     [--W15],W0
16F8:  DEC     W5,W5
16FA:  BRA     NN,16E8
16FC:  MOV     #5,W5
16FE:  BRA     1702
1700:  MOV     W4,W5
1702:  MOV     #6,W4
1704:  BTSC    W5.8
1706:  INC     W4,W4
1708:  BSET    W5.E
170A:  BTSC    W9.F
170C:  BSET    W5.F
170E:  MOV     #2710,W8
1710:  REPEAT  #11
1712:  DIV.U   W7,W8
1714:  CALL    1768
1718:  MOV     W1,W7
171A:  MOV     #3E8,W8
171C:  REPEAT  #11
171E:  DIV.U   W7,W8
1720:  CALL    1768
1724:  MOV     W1,W7
1726:  MOV     #64,W8
1728:  REPEAT  #11
172A:  DIV.U   W7,W8
172C:  CALL    1768
1730:  MOV     W1,W7
1732:  MOV     #A,W8
1734:  REPEAT  #11
1736:  DIV.U   W7,W8
1738:  CALL    1768
173C:  BTSS    W9.8
173E:  BRA     1754
1740:  MOV     #2D,W0
1742:  MOV     W1,[W15++]
1744:  MOV     W4,[W15++]
1746:  MOV     W0,[W15++]
1748:  MOV     [--W15],W0
174A:  CALL    CC6
174E:  MOV     [--W15],W4
1750:  MOV     [--W15],W1
1752:  BCLR    W9.8
1754:  MOV     #30,W0
1756:  ADD.B   W1L,W0L,W0L
1758:  MOV     W0,2A
175A:  MOV     W4,[W15++]
175C:  MOV     W0,[W15++]
175E:  MOV     [--W15],W0
1760:  CALL    CC6
1764:  MOV     [--W15],W4
1766:  BRA     17BC
1768:  MOV     #30,W6
176A:  CP0     W0
176C:  BRA     NZ,178A
176E:  BTSS    W5.E
1770:  BRA     17A8
1772:  DEC     W4,W4
1774:  CP.B    W4L,W5L
1776:  BRA     Z,177C
1778:  BTSC.B  42.0
177A:  RETURN  
177C:  CP0     W0
177E:  BRA     NZ,178A
1780:  BTSS    W5.E
1782:  BRA     17A8
1784:  BTSS    W5.F
1786:  MOV     #20,W6
1788:  BRA     17A8
178A:  BCLR    W5.E
178C:  BTSS    W9.8
178E:  BRA     17A8
1790:  MOV     W0,W10
1792:  MOV     #2D,W0
1794:  MOV     W1,[W15++]
1796:  MOV     W4,[W15++]
1798:  MOV     W0,[W15++]
179A:  MOV     [--W15],W0
179C:  CALL    CC6
17A0:  MOV     [--W15],W4
17A2:  MOV     [--W15],W1
17A4:  BCLR    W9.8
17A6:  MOV     W10,W0
17A8:  ADD.B   W6L,W0L,W0L
17AA:  MOV     W1,[W15++]
17AC:  MOV     W4,[W15++]
17AE:  MOV     W0,[W15++]
17B0:  MOV     [--W15],W0
17B2:  CALL    CC6
17B6:  MOV     [--W15],W4
17B8:  MOV     [--W15],W1
17BA:  RETURN  
17BC:  MOV     #12,W5
17BE:  REPEAT  #3
17C0:  MOV     [--W15],[W5--]
17C2:  MOV     [--W15],W5
17C4:  RETURN  
17C6:  MOV     W6,[W15++]
17C8:  MOV     W7,[W15++]
17CA:  MOV     W8,[W15++]
17CC:  MOV     W9,[W15++]
17CE:  CLR     W4
17D0:  CLR     W5
17D2:  CLR     W6
17D4:  CLR     W7
17D6:  XOR     W2,W3,W8
17D8:  BRA     Z,17FC
17DA:  MOV     #20,W8
17DC:  BCLR.B  42.0
17DE:  RLC     W0,W0
17E0:  RLC     W1,W1
17E2:  RLC     W4,W4
17E4:  RLC     W5,W5
17E6:  CP      W5,W3
17E8:  BRA     NZ,17EC
17EA:  CPB     W4,W2
17EC:  BRA     NC,17F4
17EE:  SUB     W4,W2,W4
17F0:  SUBB    W5,W3,W5
17F2:  BSET.B  42.0
17F4:  RLC     W6,W6
17F6:  RLC     W7,W7
17F8:  DEC     W8,W8
17FA:  BRA     NZ,17DC
17FC:  MOV     W7,W1
17FE:  MOV     W6,W0
1800:  MOV     [--W15],W9
1802:  MOV     [--W15],W8
1804:  MOV     [--W15],W7
1806:  MOV     [--W15],W6
1808:  RETURN  
180A:  MOV     W5,[W15++]
180C:  MOV     #C,W5
180E:  REPEAT  #7
1810:  MOV     [W5++],[W15++]
1812:  BTSS    W1.F
1814:  BRA     1824
1816:  NEG     W0,W0
1818:  BRA     Z,181C
181A:  BRA     NZ,1820
181C:  NEG     W1,W1
181E:  BRA     1822
1820:  COM     W1,W1
1822:  BSET    W4.8
1824:  CLR     W5
1826:  MOV     W0,W6
1828:  MOV     W1,W7
182A:  MOV     W4,W12
182C:  BCLR    W4.F
182E:  CP0.B   W4L
1830:  BRA     NZ,1834
1832:  BRA     187C
1834:  SUB.B   W4L,#B,W5L
1836:  BRA     NC,187C
1838:  SUB.B   W4L,W5L,W4L
183A:  BTSS    W12.F
183C:  BRA     185E
183E:  BTSS    W4.8
1840:  BRA     185A
1842:  MOV     #2D,W0
1844:  MOV     W1,[W15++]
1846:  MOV     W4,[W15++]
1848:  MOV     W0,[W15++]
184A:  MOV     [--W15],W0
184C:  CALL    CC6
1850:  MOV     [--W15],W4
1852:  MOV     [--W15],W1
1854:  BCLR    W4.8
1856:  DEC     W5,W5
1858:  BRA     N,187C
185A:  MOV     #30,W0
185C:  BRA     1860
185E:  MOV     #20,W0
1860:  MOV     W0,[W15++]
1862:  MOV     W1,[W15++]
1864:  MOV     W4,[W15++]
1866:  MOV     W0,[W15++]
1868:  MOV     [--W15],W0
186A:  CALL    CC6
186E:  MOV     [--W15],W4
1870:  MOV     [--W15],W1
1872:  MOV     [--W15],W0
1874:  DEC     W5,W5
1876:  BRA     NN,1860
1878:  BTSC    W4.8
187A:  DEC.B   W4L,W4L
187C:  MOV     #E,W8
187E:  MOV     #0,W9
1880:  LNK     #10
1882:  MOV     W12,[W14+W8]
1884:  DEC2    W8,W8
1886:  BRA     NN,1882
1888:  MOV     W4,W5
188A:  MOV     #A,W4
188C:  BTSC    W5.8
188E:  INC     W4,W4
1890:  BSET    W5.E
1892:  BTSC    W12.F
1894:  BSET    W5.F
1896:  CP0.B   W5L
1898:  BRA     Z,189C
189A:  DEC.B   W5L,W5L
189C:  MOV     W4,[W14]
189E:  MOV     W5,[W14+#2]
18A0:  MOV     W6,W0
18A2:  MOV     W7,W1
18A4:  MOV     #CA00,W2
18A6:  MOV     #3B9A,W3
18A8:  MOV     #2710,W8
18AA:  BCLR    W13.F
18AC:  BCLR.B  43.0
18AE:  CALL    17C6
18B2:  BTG     W13.F
18B4:  BTSC    W13.F
18B6:  BRA     18C6
18B8:  MOV     W0,[W14+#8]
18BA:  MOV     W1,[W14+#A]
18BC:  MOV     W0,W2
18BE:  MOV     W1,W3
18C0:  MOV     [W14+#4],W0
18C2:  MOV     [W14+#6],W1
18C4:  BRA     18AC
18C6:  MOV     W2,[W14+#8]
18C8:  MOV     W3,[W14+#A]
18CA:  MOV     W4,[W14+#4]
18CC:  MOV     W5,[W14+#6]
18CE:  MOV     [W14],W4
18D0:  MOV     [W14+#2],W5
18D2:  MOV     #30,W6
18D4:  CP0     W0
18D6:  BRA     NZ,18FA
18D8:  BTSS    W5.E
18DA:  BRA     18FE
18DC:  DEC     W4,W4
18DE:  MOV     W4,[W14]
18E0:  CP0     W4
18E2:  BRA     Z,18FE
18E4:  CP.B    W4L,W5L
18E6:  BRA     Z,18EC
18E8:  BTSC.B  42.0
18EA:  BRA     1928
18EC:  BTSS    W5.F
18EE:  BRA     18F6
18F0:  BTSS    W5.8
18F2:  BRA     191A
18F4:  BRA     1904
18F6:  MOV     #20,W6
18F8:  BRA     191A
18FA:  BCLR    W5.E
18FC:  MOV     W5,[W14+#2]
18FE:  MOV     [W14+#2],W5
1900:  BTSS    W5.8
1902:  BRA     191A
1904:  BCLR    W5.8
1906:  MOV     W5,[W14+#2]
1908:  MOV     W0,W10
190A:  MOV     #2D,W0
190C:  MOV     W4,[W15++]
190E:  MOV     W0,[W15++]
1910:  MOV     [--W15],W0
1912:  CALL    CC6
1916:  MOV     [--W15],W4
1918:  MOV     W10,W0
191A:  ADD.B   W6L,W0L,W0L
191C:  MOV     W4,[W15++]
191E:  MOV     W0,[W15++]
1920:  MOV     [--W15],W0
1922:  CALL    CC6
1926:  MOV     [--W15],W4
1928:  MOV     [W14+#8],W0
192A:  MOV     [W14+#A],W1
192C:  MOV     #A,W2
192E:  CLR     W3
1930:  CP      W0,#1
1932:  BRA     Z,1936
1934:  BRA     18AC
1936:  ULNK    
1938:  MOV     #1A,W5
193A:  REPEAT  #7
193C:  MOV     [--W15],[W5--]
193E:  MOV     [--W15],W5
1940:  RETURN  
.................... 
.................... #list
.................... 
.................... #include <Inc/lookup_tables.h>
.................... 
.................... const int timer_table[] = {
.................... 66666, 59258, 53332, 48484, 44443, 41025, 38094, 35555, 33332, 31372, 31372, 29629, 
.................... 28069, 26666, 25396, 24241, 23187, 22221, 21332, 20512, 19752, 19047, 18390, 17777, 
.................... 17203, 16666, 16161, 15685, 15237, 14814, 14814, 14413, 14034, 13674, 13332, 13007, 
.................... 12697, 12402, 12120, 11851, 11593, 11347, 11110, 10883, 10666, 10457, 10255, 10062, 
.................... 9876, 9696, 9696, 9523, 9356, 9194, 9039, 8888, 8742, 8601, 8465, 8332, 8204, 8080, 
.................... 7959, 7842, 7728, 7618, 7511, 7406, 7305, 7305, 7206, 7110, 7017, 6925, 6837, 6750, 
.................... 6666, 6583, 6503, 6425, 6348, 6274, 6201, 6129, 6060, 5992, 5925, 5860, 5796, 5796, 
.................... 5734, 5673, 5613, 5555, 5497, 5441, 5386, 5332, 5280, 5228, 5177, 5127, 5078, 5030,
.................... 4983, 4937, 4892, 4847, 4847, 4804, 4761, 4719, 4677, 4637, 4597, 4557, 4519, 4481, 
.................... 4443, 4407, 4371, 4335, 4300, 4266, 4232, 4198, 4166, 4133, 4133, 4102, 4070, 4039,
.................... 4009, 3979, 3950, 3921, 3892, 3864, 3836, 3809, 3782, 3755, 3729, 3703, 3677, 3652, 
.................... 3627, 3603, 3603, 3578, 3555, 3531, 3508, 3485, 3462, 3440, 3418, 3396, 3375, 3353, 
.................... 3332, 3312, 3291, 3271, 3251, 3231, 3212, 3212, 3193, 3174, 3155, 3136, 3118, 3100, 
.................... 3082, 3064, 3047, 3029, 3012, 2995, 2979, 2962, 2946, 2929, 2913, 2898, 2882, 2882,
.................... 2866, 2851, 2836, 2821, 2806, 2791, 2777, 2762, 2748, 2734, 2720, 2706, 2693, 2679, 
.................... 2666, 2652, 2639, 2626, 2626, 2613, 2601, 2588, 2575, 2563, 2551, 2539, 2527, 2515,
.................... 2503, 2491, 2480, 2468, 2457, 2445, 2434, 2423, 2412, 2401, 2401, 2391, 2380, 2369, 
.................... 2359, 2348, 2338, 2328, 2318, 2308, 2298, 2288, 2278, 2269, 2259, 2249, 2240, 2231, 
.................... 2221, 2212, 2212, 2203, 2194, 2185, 2176, 2167, 2158, 2150, 2141, 2132
.................... };
.................... 
.................... 
.................... const int gain_table[] = {
.................... 87, 90, 93, 95, 98, 101, 104, 106, 109, 112, 112, 114, 117, 120, 123, 126, 128,
.................... 131, 134, 136, 139, 142, 145, 147, 150, 153, 156, 159, 161, 164, 164, 167, 170, 
.................... 172, 175, 178, 181, 183, 186, 189, 192, 194, 197, 200, 202, 205, 208, 211, 213, 
.................... 216, 216, 219, 222, 225, 227, 230, 233, 236, 238, 241, 244, 246, 249, 252, 255,
.................... 258, 260, 263, 266, 266, 269, 271, 274, 277, 279, 282, 285, 288, 291, 293, 296, 
.................... 299, 301, 304, 307, 310, 312, 315, 318, 318, 321, 323, 326, 329, 332, 335, 337, 
.................... 340, 343, 345, 348, 351, 354, 357, 359, 362, 365, 368, 368, 370, 373, 376, 379,
.................... 381, 384, 387, 389, 392, 395, 398, 400, 403, 406, 409, 411, 414, 417, 420, 420,
.................... 422, 425, 428, 431, 434, 436, 439, 442, 444, 447, 450, 453, 455, 458, 461, 464, 
.................... 466, 469, 472, 472, 475, 477, 480, 483, 486, 489, 491, 494, 497, 499, 502, 505,
.................... 508, 511, 513, 516, 519, 521, 521, 524, 527, 530, 533, 535, 538, 541, 544, 546, 
.................... 549, 552, 555, 557, 560, 563, 566, 568, 571, 574, 574, 577, 579, 582, 585, 588, 
.................... 590, 593, 596, 599, 601, 604, 607, 609, 612, 615, 618, 621, 623, 623, 626, 629, 
.................... 631, 634, 637, 640, 642, 645, 648, 651, 654, 656, 659, 662, 665, 667, 670, 673,
.................... 676, 676, 678, 681, 684, 686, 689, 692, 695, 697, 700, 703, 706, 709, 711, 714,
.................... 717, 719, 722, 725, 728, 728, 730, 733, 736, 739, 742, 744, 747, 750, 753
.................... 
.................... };
.................... 
.................... 
.................... const int ascend_speed_table[] = {
.................... 0,25, 28, 31, 34, 38, 41, 44, 47, 50, 53, 53, 56, 60, 63, 66, 69, 72, 75, 78, 
.................... 82, 85, 88, 91, 94, 97, 100, 103, 107, 110, 113, 113, 116, 119, 122, 125, 129, 
.................... 132, 135, 138, 141, 144, 147, 151, 154, 157, 160, 163, 166, 169, 172, 172, 176, 
.................... 179, 182, 185, 188, 191, 194, 198, 201, 204, 207, 210, 213, 216, 220, 223, 226, 
.................... 229, 229, 232, 235, 238, 241, 245, 248, 251, 254, 257, 260, 263, 267, 270, 273, 
.................... 276, 279, 282, 285, 289, 289, 292, 295, 298, 301, 304, 307, 310, 314, 317, 320, 
.................... 323, 326, 329, 332, 336, 339, 342, 345, 345, 348, 351, 354, 358, 361, 364, 367, 
.................... 370, 373, 376, 379, 383, 386, 389, 392, 395, 398, 401, 405, 405, 408, 411, 414, 
.................... 417, 420, 423, 426, 430, 433, 436, 439, 442, 445, 448, 452, 455, 458, 461, 464, 
.................... 464, 467, 470, 474, 477, 480, 483, 486, 489, 492, 495, 499, 502, 505, 508, 511, 
.................... 514, 517, 521, 521, 524, 527, 530, 533, 536, 539, 543, 546, 549, 552, 555, 558, 
.................... 561, 564, 568, 571, 574, 577, 580, 580, 583, 586, 590, 593, 596, 599, 602, 605, 
.................... 608, 612, 615, 618, 621, 624, 627, 630, 634, 637, 637, 640, 643, 646, 649, 652, 
.................... 655, 658, 662, 665, 668, 671, 674, 677, 680, 684, 687, 690, 693, 696, 696, 699, 
.................... 702, 706, 709, 712, 715, 718, 721, 724, 728, 731, 734, 737, 740, 743, 746, 749, 
.................... 753, 756, 756, 759, 762, 765, 768, 771, 775, 778, 781, 784
.................... 
.................... 
.................... };
.................... 
.................... const int descend_speed_table[] = 
.................... {
.................... 0,28, 31, 34, 38, 41, 45, 49, 51, 54, 57, 57, 61, 64, 67, 71, 73, 77, 80, 83, 86, 
.................... 90, 93, 96, 100, 102, 105, 109, 112, 115, 119, 118, 121, 125, 128, 131, 134, 137, 
.................... 140, 143, 146, 149, 152, 154, 159, 162, 165, 168, 172, 175, 178, 178, 181, 185, 
.................... 187, 191, 195, 198, 200, 205, 209, 211, 214, 216, 220, 223, 226, 229, 232, 236,
.................... 237, 238, 242, 245, 248, 252, 256, 258, 261, 264, 268, 271, 274, 278, 280, 284,
.................... 288, 291, 293, 295, 297, 299, 302, 305, 308, 312, 315, 318, 321, 324, 328, 332,
.................... 335, 338, 341, 344, 347, 350, 353, 353, 356, 359, 363, 366, 369, 372, 375, 379,
.................... 382, 385, 388, 391, 395, 398, 401, 404, 407, 411, 414, 414, 417, 420, 423, 427,
.................... 430, 433, 436, 439, 443, 446, 449, 452, 455, 459, 462, 465, 468, 471, 475, 475,
.................... 478, 481, 484, 487, 491, 494, 497, 500, 503, 507, 510, 513, 516, 519, 523, 526, 
.................... 529, 532, 532, 535, 539, 542, 545, 548, 551, 555, 558, 561, 564, 567, 571, 574, 
.................... 577, 580, 583, 587, 590, 593, 593, 596, 599, 603, 606, 609, 612, 615, 619, 622,
.................... 625, 628, 631, 635, 638, 641, 644, 647, 651, 651, 654, 657, 660, 664, 667, 670,
.................... 673, 676, 679, 683, 686, 689, 692, 695, 699, 702, 705, 708, 712, 712, 714, 718,
.................... 721, 724, 728, 731, 734, 737, 740, 743, 747, 750, 753, 756, 760, 763, 766, 769,
.................... 772, 772, 775, 779, 782, 785, 788, 791, 794, 798, 801
.................... 
.................... 
.................... };
.................... 
.................... 
.................... #DEVICE ADC=10
.................... #device ICSP=1
.................... #include <digital_filter/digital_filter.h>
.................... typedef struct 
.................... {
....................    int32 kalman_big_1;
....................    int32 kalman_big_2;
....................    int32 kalman_diff;
....................    
....................    int32 KALMAN_UP;
....................    int32 KALMAN_DOWN;   
....................    
....................    
.................... }  KALMAN;
.................... 
.................... 
.................... void KALMAN_begin(KALMAN* kalman_filter , unsigned int16* input , unsigned int16* filtered_out);
.................... void KALMAN_init(KALMAN* kalman_filter , int32 kalman_up , int32 kalman_down);
.................... 
.................... //--------------------FUNCTIONS IMPLEMENTATION--------------------------//
.................... 
.................... void KALMAN_init(KALMAN* kalman_filter , int32 kalman_up , int32 kalman_down)
*
0C84:  MOV     W5,[W15++]
.................... {
....................    kalman_filter->kalman_big_1 = 0;
0C86:  MOV     A7E,W5
0C88:  CLR.B   [W5]
0C8A:  MOV.B   #0,W0L
0C8C:  MOV.B   W0L,[W5+#1]
0C8E:  MOV.B   #0,W0L
0C90:  MOV.B   W0L,[W5+#2]
0C92:  MOV.B   #0,W0L
0C94:  MOV.B   W0L,[W5+#3]
....................    kalman_filter->kalman_big_2 = 0;
0C96:  MOV     #4,W0
0C98:  ADD     A7E,W0
0C9A:  MOV     W0,W5
0C9C:  CLR.B   [W5]
0C9E:  MOV.B   #0,W0L
0CA0:  MOV.B   W0L,[W5+#1]
0CA2:  MOV.B   #0,W0L
0CA4:  MOV.B   W0L,[W5+#2]
0CA6:  MOV.B   #0,W0L
0CA8:  MOV.B   W0L,[W5+#3]
....................    
....................    kalman_filter->KALMAN_UP = kalman_up;
0CAA:  MOV     #C,W0
0CAC:  ADD     A7E,W0
0CAE:  MOV     W0,W5
0CB0:  MOV     #A80,W4
0CB2:  MOV     [W4++],[W5++]
0CB4:  MOV     [W4++],[W5++]
....................    kalman_filter->KALMAN_DOWN = kalman_down;
0CB6:  MOV     #10,W0
0CB8:  ADD     A7E,W0
0CBA:  MOV     W0,W5
0CBC:  MOV     #A84,W4
0CBE:  MOV     [W4++],[W5++]
0CC0:  MOV     [W4++],[W5++]
0CC2:  MOV     [--W15],W5
0CC4:  RETURN  
.................... 
.................... }
.................... void KALMAN_begin(KALMAN* kalman_filter , unsigned int16* input , unsigned int16* filtered_out) 
*
0A1E:  MOV     W5,[W15++]
0A20:  MOV     W6,[W15++]
0A22:  MOV     W7,[W15++]
0A24:  MOV     W8,[W15++]
.................... {
....................    kalman_filter->kalman_big_1 = *input << kalman_filter->KALMAN_UP;
0A26:  MOV     B44,W5
0A28:  MOV     B46,W0
0A2A:  MOV     [W0],W6
0A2C:  MOV     #0,W7
0A2E:  MOV     #C,W0
0A30:  ADD     B44,W0
0A32:  MOV     W0,W4
0A34:  MOV     #0,W3
0A36:  MOV     [W4++],[W3++]
0A38:  MOV     [W4++],[W3++]
0A3A:  MOV     W0,W4
0A3C:  MOV     #C,W3
0A3E:  MOV     [W3++],[W5++]
0A40:  MOV     [W3++],[W5++]
0A42:  SUB     #4,W5
0A44:  INC     W4,W4
0A46:  DEC     W4,W4
0A48:  BRA     Z,A50
0A4A:  SL      [W5],[W5++]
0A4C:  RLC     [W5],[W5--]
0A4E:  BRA     A46
....................    kalman_filter->kalman_diff = kalman_filter->kalman_big_1 - kalman_filter->kalman_big_2;
0A50:  MOV     #8,W0
0A52:  ADD     B44,W0
0A54:  MOV     W0,W5
0A56:  MOV     B44,W0
0A58:  MOV     #C,W4
0A5A:  MOV     [W0++],[W4++]
0A5C:  MOV     [W0++],[W4++]
0A5E:  MOV     #4,W0
0A60:  ADD     B44,W0
0A62:  MOV     W0,W4
0A64:  MOV     #0,W3
0A66:  MOV     [W4++],[W3++]
0A68:  MOV     [W4++],[W3++]
0A6A:  SUB     W6,W0,[W5]
0A6C:  SUBB    W7,W1,[++W5]
.................... 
....................    if (kalman_filter->kalman_diff > 0) {
0A6E:  MOV     #8,W0
0A70:  ADD     B44,W0
0A72:  MOV     #A,W4
0A74:  MOV     [W0++],[W4++]
0A76:  MOV     [W0++],[W4++]
0A78:  CP      W6,#0
0A7A:  BRA     LT,AD6
0A7C:  BRA     GT,A82
0A7E:  CP      W5,#0
0A80:  BRA     LEU,AD6
.................... 
....................         kalman_filter->kalman_diff = kalman_filter->kalman_diff >> kalman_filter->KALMAN_DOWN;
0A82:  MOV     #8,W0
0A84:  ADD     B44,W0
0A86:  MOV     W0,W5
0A88:  MOV     #8,W0
0A8A:  ADD     B44,W0
0A8C:  MOV     #C,W4
0A8E:  MOV     [W0++],[W4++]
0A90:  MOV     [W0++],[W4++]
0A92:  MOV     #10,W0
0A94:  ADD     B44,W0
0A96:  MOV     W0,W4
0A98:  MOV     #0,W3
0A9A:  MOV     [W4++],[W3++]
0A9C:  MOV     [W4++],[W3++]
0A9E:  MOV     W0,W4
0AA0:  MOV     #C,W3
0AA2:  MOV     [W3++],[W5++]
0AA4:  MOV     [W3++],[W5++]
0AA6:  SUB     #4,W5
0AA8:  INC     W4,W4
0AAA:  DEC     W4,W4
0AAC:  BRA     Z,AB4
0AAE:  LSR     [++W5],[W5]
0AB0:  RRC     [--W5],[W5]
0AB2:  BRA     AAA
....................         kalman_filter->kalman_big_2 = kalman_filter->kalman_big_2 + kalman_filter->kalman_diff;
0AB4:  MOV     #4,W0
0AB6:  ADD     B44,W0
0AB8:  MOV     W0,W5
0ABA:  MOV     #4,W0
0ABC:  ADD     B44,W0
0ABE:  MOV     #C,W4
0AC0:  MOV     [W0++],[W4++]
0AC2:  MOV     [W0++],[W4++]
0AC4:  MOV     #8,W0
0AC6:  ADD     B44,W0
0AC8:  MOV     W0,W4
0ACA:  MOV     #0,W3
0ACC:  MOV     [W4++],[W3++]
0ACE:  MOV     [W4++],[W3++]
0AD0:  ADD     W0,W6,[W5]
0AD2:  ADDC    W1,W7,[++W5]
.................... 
....................    }
0AD4:  BRA     B56
....................    else if (kalman_filter->kalman_diff < 0) {
0AD6:  MOV     #8,W0
0AD8:  ADD     B44,W0
0ADA:  MOV     #A,W4
0ADC:  MOV     [W0++],[W4++]
0ADE:  MOV     [W0++],[W4++]
0AE0:  CP      W6,#0
0AE2:  BRA     GT,B56
0AE4:  BRA     LT,AEA
0AE6:  CP      W5,#0
0AE8:  BRA     C,B56
.................... 
....................         kalman_filter->kalman_diff = 0 - kalman_filter->kalman_diff;
0AEA:  MOV     #8,W0
0AEC:  ADD     B44,W0
0AEE:  MOV     W0,W5
0AF0:  MOV     #8,W0
0AF2:  ADD     B44,W0
0AF4:  MOV     W0,W4
0AF6:  MOV     #0,W3
0AF8:  MOV     [W4++],[W3++]
0AFA:  MOV     [W4++],[W3++]
0AFC:  MOV     #0,W4
0AFE:  SUB     W4,W0,[W5]
0B00:  MOV     #0,W4
0B02:  SUBB    W4,W1,[++W5]
....................         kalman_filter->kalman_diff = kalman_filter->kalman_diff >> kalman_filter->KALMAN_DOWN;
0B04:  MOV     #8,W0
0B06:  ADD     B44,W0
0B08:  MOV     W0,W5
0B0A:  MOV     #8,W0
0B0C:  ADD     B44,W0
0B0E:  MOV     #C,W4
0B10:  MOV     [W0++],[W4++]
0B12:  MOV     [W0++],[W4++]
0B14:  MOV     #10,W0
0B16:  ADD     B44,W0
0B18:  MOV     W0,W4
0B1A:  MOV     #0,W3
0B1C:  MOV     [W4++],[W3++]
0B1E:  MOV     [W4++],[W3++]
0B20:  MOV     W0,W4
0B22:  MOV     #C,W3
0B24:  MOV     [W3++],[W5++]
0B26:  MOV     [W3++],[W5++]
0B28:  SUB     #4,W5
0B2A:  INC     W4,W4
0B2C:  DEC     W4,W4
0B2E:  BRA     Z,B36
0B30:  LSR     [++W5],[W5]
0B32:  RRC     [--W5],[W5]
0B34:  BRA     B2C
....................         kalman_filter->kalman_big_2 = kalman_filter->kalman_big_2 - kalman_filter->kalman_diff;
0B36:  MOV     #4,W0
0B38:  ADD     B44,W0
0B3A:  MOV     W0,W5
0B3C:  MOV     #4,W0
0B3E:  ADD     B44,W0
0B40:  MOV     #C,W4
0B42:  MOV     [W0++],[W4++]
0B44:  MOV     [W0++],[W4++]
0B46:  MOV     #8,W0
0B48:  ADD     B44,W0
0B4A:  MOV     W0,W4
0B4C:  MOV     #0,W3
0B4E:  MOV     [W4++],[W3++]
0B50:  MOV     [W4++],[W3++]
0B52:  SUB     W6,W0,[W5]
0B54:  SUBB    W7,W1,[++W5]
.................... 
....................     }
.................... 
....................     *filtered_out = kalman_filter->kalman_big_2 >> kalman_filter->KALMAN_UP;
0B56:  MOV     B48,W5
0B58:  MOV     #4,W0
0B5A:  ADD     B44,W0
0B5C:  MOV     #C,W4
0B5E:  MOV     [W0++],[W4++]
0B60:  MOV     [W0++],[W4++]
0B62:  MOV     #C,W0
0B64:  ADD     B44,W0
0B66:  MOV     W0,W4
0B68:  MOV     #0,W3
0B6A:  MOV     [W4++],[W3++]
0B6C:  MOV     [W4++],[W3++]
0B6E:  MOV     W0,W4
0B70:  MOV.D   W6,W0
0B72:  INC     W4,W4
0B74:  DEC     W4,W4
0B76:  BRA     Z,B7E
0B78:  LSR     W1,W1
0B7A:  RRC     W0,W0
0B7C:  BRA     B74
0B7E:  MOV     W0,[W5]
0B80:  MOV     [--W15],W8
0B82:  MOV     [--W15],W7
0B84:  MOV     [--W15],W6
0B86:  MOV     [--W15],W5
0B88:  RETURN  
....................    
.................... }
.................... 
.................... #use delay(clock=64000000,crystal=8000000)
.................... #use rs232(UART1, baud=57600, RECEIVE_BUFFER=100 , stream=UART_PORT1)
.................... 
.................... #FUSES NOWDT                    //No Watch Dog Timer
.................... #FUSES CKSFSM                   //Clock Switching is enabled, fail Safe clock monitor is enabled
.................... #FUSES BORV42                   //Brownout reset at 4.5V
.................... #FUSES WRT                      //Program Memory Write Protected
.................... #FUSES PROTECT                  //Code protected from reads
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float32)(unsigned int16)y;
.................... 
....................  else if (y < 10000000.0)
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
....................       res = 32768.0*(float32)l;
....................       res += (float32)(unsigned int16)y;
....................    }
.................... 
....................  else
....................   res = y;
.................... 
....................  y = y - (float32)(unsigned int16)y;
.................... 
....................  if (s)
....................   res = -res;
.................... 
....................  if (y != 0)
....................  {
....................   if (s == 1 && n == 0)
....................    res -= 1.0;
.................... 
....................   if (s == 0 && n == 1)
....................    res += 1.0;
....................  }
....................  if (x == 0)
....................     res = 0;
.................... 
....................  return (res);
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl[0]*y2 + pl[1];
.................... 
....................       r = ql[0]*y2 + ql[1];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
....................          r = -(float32)-n;
....................       else
....................          r = (float32)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
*
127E:  MOV     W5,[W15++]
1280:  MOV     W6,[W15++]
1282:  MOV     W7,[W15++]
1284:  MOV     W8,[W15++]
1286:  CLR     AAC
1288:  CLR     AAE
128A:  CLR     AB0
128C:  MOV     #3FF0,W4
128E:  MOV     W4,AB2
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
1290:  MOV     #FF1F,W4
1292:  MOV     W4,ABC
1294:  SETM    ABE
1296:  SETM    AC0
1298:  MOV     #BFDF,W4
129A:  MOV     W4,AC2
129C:  MOV     #1C35,W4
129E:  MOV     W4,AC4
12A0:  MOV     #5555,W4
12A2:  MOV     W4,AC6
12A4:  MOV     #5555,W4
12A6:  MOV     W4,AC8
12A8:  MOV     #3FA5,W4
12AA:  MOV     W4,ACA
12AC:  MOV     #3F1C,W4
12AE:  MOV     W4,ACC
12B0:  MOV     #16A7,W4
12B2:  MOV     W4,ACE
12B4:  MOV     #C16C,W4
12B6:  MOV     W4,AD0
12B8:  MOV     #BF56,W4
12BA:  MOV     W4,AD2
12BC:  MOV     #F3E6,W4
12BE:  MOV     W4,AD4
12C0:  MOV     #D65,W4
12C2:  MOV     W4,AD6
12C4:  MOV     #1A0,W4
12C6:  MOV     W4,AD8
12C8:  MOV     #3EFA,W4
12CA:  MOV     W4,ADA
12CC:  MOV     #A3E,W4
12CE:  MOV     W4,ADC
12D0:  MOV     #3931,W4
12D2:  MOV     W4,ADE
12D4:  MOV     #7E4C,W4
12D6:  MOV     W4,AE0
12D8:  MOV     #BE92,W4
12DA:  MOV     W4,AE2
12DC:  MOV     #DDFB,W4
12DE:  MOV     W4,AE4
12E0:  MOV     #2B77,W4
12E2:  MOV     W4,AE6
12E4:  MOV     #EDB1,W4
12E6:  MOV     W4,AE8
12E8:  MOV     #3E21,W4
12EA:  MOV     W4,AEA
12EC:  MOV     #6FCC,W4
12EE:  MOV     W4,AEC
12F0:  MOV     #8FF7,W4
12F2:  MOV     W4,AEE
12F4:  MOV     #C610,W4
12F6:  MOV     W4,AF0
12F8:  MOV     #BDA8,W4
12FA:  MOV     W4,AF2
12FC:  MOV     #124C,W4
12FE:  MOV     W4,AF4
1300:  MOV     #8E1C,W4
1302:  MOV     W4,AF6
1304:  MOV     #3AF9,W4
1306:  MOV     W4,AF8
1308:  MOV     #3CF3,W4
130A:  MOV     W4,AFA
130C:  MOV     #7676,W4
130E:  MOV     W4,AFC
1310:  MOV     #350F,W4
1312:  MOV     W4,AFE
1314:  MOV     #C0DE,W4
1316:  MOV     W4,B00
1318:  MOV     #3CF0,W4
131A:  MOV     W4,B02
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
131C:  MOV     A92,W0
131E:  MOV     A94,W1
1320:  MOV     A96,W2
1322:  MOV     A98,W3
1324:  MOV     #0,W4
1326:  MOV     #0,W5
1328:  MOV     #0,W6
132A:  MOV     #0,W7
132C:  CALL    119C
1330:  BRA     NC,133C
1332:  MOV     #A92,W0
1334:  MOV     #A92,W1
1336:  REPEAT  #7
1338:  MOV     [W0++],[W1++]
133A:  BTG.B   A99.7
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
133C:  MOV     A92,W0
133E:  MOV     A94,W1
1340:  MOV     A96,W2
1342:  MOV     A98,W3
1344:  MOV     #C884,W4
1346:  MOV     #6DC9,W5
1348:  MOV     #5F30,W6
134A:  MOV     #3FE4,W7
134C:  CALL    D96
1350:  CALL    1220
1354:  MOV.B   W0L,A9A
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
1356:  MOV     A92,W0
1358:  MOV     A94,W1
135A:  MOV     A96,W2
135C:  MOV     A98,W3
135E:  MOV     #C884,W4
1360:  MOV     #6DC9,W5
1362:  MOV     #5F30,W6
1364:  MOV     #3FE4,W7
1366:  CALL    D96
136A:  MOV     W0,W5
136C:  MOV     W1,W6
136E:  MOV     W2,W7
1370:  MOV     W3,W8
1372:  MOV     #0,W1
1374:  MOV     #0,W2
1376:  MOV     #0,W3
1378:  MOV.B   A9A,W0L
137A:  CLR.B   1
137C:  CALL    D2C
1380:  BSET.B  43.0
1382:  MOV     W5,[W15++]
1384:  MOV     W6,[W15++]
1386:  MOV     W7,[W15++]
1388:  MOV     W0,W4
138A:  MOV     W5,W0
138C:  MOV     W1,W5
138E:  MOV     W6,W1
1390:  MOV     W2,W6
1392:  MOV     W7,W2
1394:  MOV     W3,W7
1396:  MOV     W8,W3
1398:  CALL    FAE
139C:  MOV     [--W15],W7
139E:  MOV     [--W15],W6
13A0:  MOV     [--W15],W5
13A2:  MOV     W0,AB4
13A4:  MOV     W1,AB6
13A6:  MOV     W2,AB8
13A8:  MOV     W3,ABA
....................    quad = quad % 4;                    // quadrant (0 to 3)
13AA:  MOV.B   A9A,W0L
13AC:  AND.B   W0L,#3,W0L
13AE:  MOV.B   W0L,A9A
.................... 
....................    if (quad == 0 || quad == 2)
13B0:  CP0.B   A9A
13B2:  BRA     Z,13BA
13B4:  MOV     A9A,W4
13B6:  CP.B    W4L,#2
13B8:  BRA     NZ,13D8
....................       t = frac * PI_DIV_BY_TWO;
13BA:  MOV     AB4,W0
13BC:  MOV     AB6,W1
13BE:  MOV     AB8,W2
13C0:  MOV     ABA,W3
13C2:  MOV     #2D18,W4
13C4:  MOV     #5444,W5
13C6:  MOV     #21FB,W6
13C8:  MOV     #3FF9,W7
13CA:  CALL    D96
13CE:  MOV     W0,AA4
13D0:  MOV     W1,AA6
13D2:  MOV     W2,AA8
13D4:  MOV     W3,AAA
13D6:  BRA     146C
....................    else if (quad == 1)
13D8:  MOV     A9A,W4
13DA:  CP.B    W4L,#1
13DC:  BRA     NZ,1426
....................       t = (1-frac) * PI_DIV_BY_TWO;
13DE:  BSET.B  43.0
13E0:  MOV     #0,W0
13E2:  MOV     #0,W1
13E4:  MOV     #0,W2
13E6:  MOV     #3FF0,W3
13E8:  MOV     AB4,W4
13EA:  MOV     AB6,W5
13EC:  MOV     AB8,W6
13EE:  MOV     ABA,W7
13F0:  CALL    FAE
13F4:  MOV     W0,W5
13F6:  MOV     W1,W6
13F8:  MOV     W2,W7
13FA:  MOV     W3,W8
13FC:  MOV     W5,[W15++]
13FE:  MOV     W6,[W15++]
1400:  MOV     W7,[W15++]
1402:  MOV     W5,W0
1404:  MOV     W6,W1
1406:  MOV     W7,W2
1408:  MOV     W8,W3
140A:  MOV     #2D18,W4
140C:  MOV     #5444,W5
140E:  MOV     #21FB,W6
1410:  MOV     #3FF9,W7
1412:  CALL    D96
1416:  MOV     [--W15],W7
1418:  MOV     [--W15],W6
141A:  MOV     [--W15],W5
141C:  MOV     W0,AA4
141E:  MOV     W1,AA6
1420:  MOV     W2,AA8
1422:  MOV     W3,AAA
1424:  BRA     146C
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
1426:  BSET.B  43.0
1428:  MOV     AB4,W0
142A:  MOV     AB6,W1
142C:  MOV     AB8,W2
142E:  MOV     ABA,W3
1430:  MOV     #0,W4
1432:  MOV     #0,W5
1434:  MOV     #0,W6
1436:  MOV     #3FF0,W7
1438:  CALL    FAE
143C:  MOV     W0,W5
143E:  MOV     W1,W6
1440:  MOV     W2,W7
1442:  MOV     W3,W8
1444:  MOV     W5,[W15++]
1446:  MOV     W6,[W15++]
1448:  MOV     W7,[W15++]
144A:  MOV     W5,W0
144C:  MOV     W6,W1
144E:  MOV     W7,W2
1450:  MOV     W8,W3
1452:  MOV     #2D18,W4
1454:  MOV     #5444,W5
1456:  MOV     #21FB,W6
1458:  MOV     #3FF9,W7
145A:  CALL    D96
145E:  MOV     [--W15],W7
1460:  MOV     [--W15],W6
1462:  MOV     [--W15],W5
1464:  MOV     W0,AA4
1466:  MOV     W1,AA6
1468:  MOV     W2,AA8
146A:  MOV     W3,AAA
.................... 
....................    y = 1.0;
146C:  CLR     A9C
146E:  CLR     A9E
1470:  CLR     AA0
1472:  MOV     #3FF0,W4
1474:  MOV     W4,AA2
....................    t = t * t;
1476:  MOV     AA4,W0
1478:  MOV     AA6,W1
147A:  MOV     AA8,W2
147C:  MOV     AAA,W3
147E:  MOV     AA4,W4
1480:  MOV     AA6,W5
1482:  MOV     AA8,W6
1484:  MOV     AAA,W7
1486:  CALL    D96
148A:  MOV     W0,AA4
148C:  MOV     W1,AA6
148E:  MOV     W2,AA8
1490:  MOV     W3,AAA
....................    for (i = 0; i <= 8; i++)
1492:  CLR.B   A9B
1494:  MOV     A9A,W4
1496:  LSR     W4,#8,W4
1498:  CP.B    W4L,#8
149A:  BRA     GTU,14FE
....................    {
....................       t2 = t2 * t;
149C:  MOV     AAC,W0
149E:  MOV     AAE,W1
14A0:  MOV     AB0,W2
14A2:  MOV     AB2,W3
14A4:  MOV     AA4,W4
14A6:  MOV     AA6,W5
14A8:  MOV     AA8,W6
14AA:  MOV     AAA,W7
14AC:  CALL    D96
14B0:  MOV     W0,AAC
14B2:  MOV     W1,AAE
14B4:  MOV     W2,AB0
14B6:  MOV     W3,AB2
....................       y = y + p_64[i] * t2;
14B8:  MOV.B   A9B,W0L
14BA:  CLR.B   1
14BC:  SL      W0,#3,W0
14BE:  MOV     #ABC,W4
14C0:  ADD     W0,W4,W0
14C2:  MOV     W0,W5
14C4:  MOV     W5,[W15++]
14C6:  MOV     [W5],W0
14C8:  MOV     [++W5],W1
14CA:  MOV     [++W5],W2
14CC:  MOV     [++W5],W3
14CE:  MOV     AAC,W4
14D0:  MOV     AAE,W5
14D2:  MOV     AB0,W6
14D4:  MOV     AB2,W7
14D6:  CALL    D96
14DA:  MOV     [--W15],W5
14DC:  BCLR.B  43.0
14DE:  MOV     W0,W4
14E0:  MOV     W1,W5
14E2:  MOV     W2,W6
14E4:  MOV     W3,W7
14E6:  MOV     A9C,W0
14E8:  MOV     A9E,W1
14EA:  MOV     AA0,W2
14EC:  MOV     AA2,W3
14EE:  CALL    FAE
14F2:  MOV     W0,A9C
14F4:  MOV     W1,A9E
14F6:  MOV     W2,AA0
14F8:  MOV     W3,AA2
14FA:  INC.B   0A9B
14FC:  BRA     1494
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
14FE:  MOV     A9A,W4
1500:  CP.B    W4L,#2
1502:  BRA     Z,150A
1504:  MOV     A9A,W4
1506:  CP.B    W4L,#1
1508:  BRA     NZ,1514
....................       y = -y;  // correct sign
150A:  MOV     #A9C,W0
150C:  MOV     #A9C,W1
150E:  REPEAT  #7
1510:  MOV     [W0++],[W1++]
1512:  BTG.B   AA3.7
.................... 
....................    return (y);
1514:  MOV     A9C,W0
1516:  MOV     A9E,W1
1518:  MOV     AA0,W2
151A:  MOV     AA2,W3
151C:  MOV     [--W15],W8
151E:  MOV     [--W15],W7
1520:  MOV     [--W15],W6
1522:  MOV     [--W15],W5
1524:  RETURN  
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
1526:  MOV     W5,[W15++]
1528:  MOV     W6,[W15++]
152A:  MOV     W7,[W15++]
152C:  MOV     W8,[W15++]
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
152E:  BSET.B  43.0
1530:  MOV     A82,W0
1532:  MOV     A84,W1
1534:  MOV     A86,W2
1536:  MOV     A88,W3
1538:  MOV     #2D18,W4
153A:  MOV     #5444,W5
153C:  MOV     #21FB,W6
153E:  MOV     #3FF9,W7
1540:  CALL    FAE
1544:  MOV     W0,W5
1546:  MOV     W1,W6
1548:  MOV     W2,W7
154A:  MOV     W3,W8
154C:  MOV     W5,A92
154E:  MOV     W6,A94
1550:  MOV     W7,A96
1552:  MOV     W8,A98
1554:  CALL    127E
1558:  MOV     [--W15],W8
155A:  MOV     [--W15],W7
155C:  MOV     [--W15],W6
155E:  MOV     [--W15],W5
1560:  RETURN  
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... #include <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];
....................             c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
....................        result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #ifndef __PCB__
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
....................    goto StrtoulGO;
.................... 
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(; sd!=0; )
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtoulGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
....................    }
....................    if (endptr)
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... #endif
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #define P1TCON    0x01C0
.................... #define P1TMR     0x01C2 
.................... #define P1TPER    0x01C4
.................... #define P1SECMP   0x01C6
.................... #define PWM1CON1  0x01C8 
.................... #define PWM1CON2  0x01CA
.................... #define P1DTCON1  0x01CC
.................... #define P1DTCON2  0x01CE  
.................... #define P1FLTACON 0x01D0
.................... #define P1OVDCON  0x01D4     
.................... #define P1DC1     0x01D6   
.................... #define P1DC2     0x01D8
.................... #define P1DC3     0x01DA
.................... #define IPC14     0x00C0  
.................... #define CLKDIV    0x0744 
.................... #define PLLFBD    0x0746
.................... 
.................... 
.................... /* ADC REGISTERS */
.................... 
.................... // adc buffer registers
.................... #define ADCBUF0 0x0280
.................... #define ADCBUF1 0x0282
.................... #define ADCBUF2 0x0284
.................... #define ADCBUF3 0x0286
.................... // adc control registers
.................... #define ADCON1 0x02A0
.................... #define ADCON2 0x02A2
.................... #define ADCON3 0x02A4
.................... // adc chennel select registers.
.................... #define ADCHS  0x02A6
.................... #define ADPCFG 0x02A8
.................... #define ADCSSL 0x02AA
.................... 
.................... #define IFS0 0x0084
.................... 
.................... 
.................... /*------------QUADRATURE ENCODER REGISTERS-------------------*/
.................... #define QEICON  0x0122       // Control Status Register.
.................... #define DFLTCON 0x0124      // Digital Filter Control Register.
.................... #define POSCNT  0x0126     // Position Count Register.
.................... #define MAXCNT  0x0128    // Maximum Count Register.
.................... //!#define ADPCFG  0x02A8   // Encoder Multiplexed pins.
.................... #define IEC2    0x0090  // for enabling the QE interrupt.
.................... #define IPC10   0x00A8 // QEI interrupt priority Register.
.................... 
.................... #define UPDN 3       // Direction testing flag.
.................... /*------------QUADRATURE ENCODER REGISTERS-------------------*/
.................... 
.................... #define TIM_OVERFLOW_VAL 65535
.................... #define U1TXREG   0x0210
.................... #define U1BRG     0x0214
.................... 
.................... #define ADC_pin sAN1
.................... #define LED_PIN PIN_C13
.................... #define TICK_PIN PIN_B0
.................... 
.................... #define voltage_offset 1000//1248
.................... #define low_duty_limit 50
.................... #define high_duty_limit 1950
.................... #define SLOPE 0
.................... 
.................... #define break_level 5
.................... #define sustain_level 200  
.................... #define break_amplitude 0 
.................... 
.................... #define pedestal_amplitude 500
.................... #define peak_amplitude 950
.................... 
.................... 
.................... #define throttle_PIN PIN_B1
.................... #define PWM_tick_pin PIN_B2
.................... #define TIM_tick_pin PIN_B3
.................... #define ENC_TICK_PIN PIN_B0
.................... 
.................... #define KALMAN_UP_1     7
.................... #define KALMAN_DOWN_1   5
.................... 
.................... #define KALMAN_UP_2     8
.................... #define KALMAN_DOWN_2   5
.................... 
.................... #define current_prob1   sAN6
.................... #define current_prob2   sAN8
.................... 
.................... 
.................... #define TIM_FREQ  60 // for 4k hz sampling rate.
.................... 
.................... #define init_freq 30
.................... 
.................... void initMCPWM(void);
.................... void fill_sine_table(void);  
.................... int1 QEI_get_direction(void);
.................... int set_pwm_duty(int16 ,  int16);
.................... 
.................... unsigned int16 duty[3]={0,0,0},sample=0;
.................... signed int16 peak_voltage =0;//  1184; 
.................... signed int32 reference[3] = {0,0,0};
.................... 
.................... const unsigned max_samples=30.0;
.................... signed int16 sine_table[max_samples];
.................... unsigned int16 sine_index,phase_angle[3] = {0 , 0 , 0};  
.................... double theeta;
.................... 
.................... unsigned int16 raw_adc =0 ;
.................... signed int16 throttle_level = 0;
.................... unsigned int16 freq = 1;
.................... 
.................... //-----------ENCODER VARIABLES-----------//
.................... int32 position_count = 0;
.................... int32 prev_count = 0;
.................... int32 enc_count = 0;
.................... int32 position_count_new = 0;
.................... int1 direction_flag = 0;
.................... unsigned int16 position_capture = 0;
.................... //-----------ENCODER VARIABLES-----------//
.................... int1 sec_flage = 0;
.................... int1 tick = 0;
.................... int1 enc_tick = 0;
.................... int1 uart_tick = 0;
.................... int8 tick_count = 0;
.................... unsigned long millis_count = 0;
.................... unsigned long sec_count = 0;
.................... 
.................... char Serial_OutputBuffer[100];
.................... 
.................... unsigned int16 ascending_speed , descending_speed , attained_speed , loaded_speed;  
.................... int16 loaded_val = 0;
.................... int16 attained_throttle;
.................... unsigned int32 throttle_delay = 0;
.................... static int1 enc_mutx = 0;
.................... 
.................... //---------------FILTER VARIABLES-----------------//
.................... KALMAN filter1_sin1 , filter2_sin1 , filter1_sin2 , filter2_sin2;
.................... unsigned int16 ADC1_sample =   0;
.................... unsigned int16 ADC2_sample =   0;
.................... 
.................... unsigned int16 filtered_sin1 = 0;
.................... unsigned int16 filtered_sin2 = 0;
.................... 
.................... signed sampled_sin1 = 0;
.................... signed sampled_sin2 = 0;
.................... 
.................... unsigned int16 abs_sin1 = 0;
.................... unsigned int16 abs_sin2 = 0;
.................... 
.................... unsigned int16 prob1 = 0;
.................... unsigned int16 prob2 = 0;
.................... 
.................... char symb = ' ';
.................... char symb1 = ' ';
.................... //---------------FILTER VARIABLES-----------------//
.................... 
.................... int1 ch1 = 0;
.................... int1 stop_pwm = 0;
.................... 
.................... 
.................... #int_PWM1
.................... void  PWM1_isr(void) 
*
0746:  PUSH    42
0748:  PUSH    36
074A:  PUSH    32
074C:  MOV     W0,[W15++]
074E:  MOV     #2,W0
0750:  REPEAT  #C
0752:  MOV     [W0++],[W15++]
.................... {
....................    tick_count++;
0754:  INC.B   0997
....................    if(tick_count >= 8)
0756:  MOV     996,W4
0758:  LSR     W4,#8,W4
075A:  CP.B    W4L,#8
075C:  BRA     LT,76E
....................    {     
....................       millis_count++;
075E:  INC     099A
0760:  BTSC.B  42.1
0762:  INC     099C
....................       sec_count++;
0764:  INC     099E
0766:  BTSC.B  42.1
0768:  INC     09A0
....................       tick = 1;
076A:  BSET.B  996.2
....................       
....................       tick_count=0;
076C:  CLR.B   997
....................    
....................    }
....................    
....................    if (millis_count >= 100) {
076E:  MOV     99C,W4
0770:  CP      W4,#0
0772:  BRA     NC,784
0774:  BRA     GTU,77E
0776:  MOV     99A,W4
0778:  MOV     #64,W3
077A:  CP      W3,W4
077C:  BRA     GTU,784
....................       enc_tick = 1;
077E:  BSET.B  996.3
.................... //!      uart_tick = 1;
....................       millis_count = 0;
0780:  CLR     99A
0782:  CLR     99C
....................       
....................    }
....................    if (sec_count >= 1000) 
0784:  MOV     9A0,W4
0786:  CP      W4,#0
0788:  BRA     NC,79A
078A:  BRA     GTU,794
078C:  MOV     99E,W4
078E:  MOV     #3E8,W3
0790:  CP      W3,W4
0792:  BRA     GTU,79A
....................    {
....................       sec_flage = 1;
0794:  BSET.B  996.1
....................       sec_count = 0;
0796:  CLR     99E
0798:  CLR     9A0
....................    
....................    }
....................    
.................... }
.................... 
079A:  BCLR.B  88.7
079C:  MOV     #1A,W0
079E:  REPEAT  #C
07A0:  MOV     [--W15],[W0--]
07A2:  MOV     [--W15],W0
07A4:  POP     32
07A6:  POP     36
07A8:  POP     42
07AA:  RETFIE  
.................... #INT_TIMER3
.................... void  timer3_isr(void) 
*
07EE:  PUSH    42
07F0:  PUSH    36
07F2:  PUSH    32
07F4:  MOV     W0,[W15++]
07F6:  MOV     #2,W0
07F8:  REPEAT  #C
07FA:  MOV     [W0++],[W15++]
.................... {
....................    
....................    sample = (sample+1)%max_samples;
07FC:  MOV     924,W4
07FE:  ADD     W4,#1,W5
0800:  MOV     #1E,W4
0802:  REPEAT  #11
0804:  DIV.U   W5,W4
0806:  MOV     W1,924
....................    phase_angle[0] = sample;
0808:  PUSH    924
080A:  POP     972
....................    phase_angle[1] = (sample+10)%max_samples; 
080C:  MOV     924,W4
080E:  ADD     W4,#A,W5
0810:  MOV     #1E,W4
0812:  REPEAT  #11
0814:  DIV.U   W5,W4
0816:  MOV     W1,974
....................    phase_angle[2] = (sample+20)%max_samples;  
0818:  MOV     924,W4
081A:  ADD     W4,#14,W5
081C:  MOV     #1E,W4
081E:  REPEAT  #11
0820:  DIV.U   W5,W4
0822:  MOV     W1,976
.................... 
....................    for (int i = 0 ; i < 3 ; i++) {
0824:  CLR     B44
0826:  MOV     B44,W4
0828:  CP      W4,#3
082A:  BRA     GE,9C2
....................       
....................       reference[i] = sine_table[phase_angle[i]];
082C:  MOV     B44,W4
082E:  MUL.UU  W4,#4,W0
0830:  MOV     #928,W4
0832:  ADD     W0,W4,W5
0834:  MOV     B44,W4
0836:  MUL.UU  W4,#2,W0
0838:  MOV     #972,W4
083A:  ADD     W0,W4,W0
083C:  MOV     [W0],W6
083E:  SL      W6,#1,W0
0840:  MOV     #934,W4
0842:  ADD     W0,W4,W0
0844:  MOV     W0,W4
0846:  MOV     [W4],W0
0848:  CLR     W1
084A:  BTSC    W0.F
084C:  SETM    W1
084E:  MOV     #0,W4
0850:  MOV     [W4++],[W5++]
0852:  MOV     [W4++],[W5++]
....................       reference[i] = reference[i] * peak_voltage; 
0854:  MOV     B44,W4
0856:  MUL.UU  W4,#4,W0
0858:  MOV     #928,W4
085A:  ADD     W0,W4,W5
085C:  MOV     B44,W4
085E:  MUL.UU  W4,#4,W0
0860:  MOV     #928,W4
0862:  ADD     W0,W4,W0
0864:  MOV     #C,W4
0866:  MOV     [W0++],[W4++]
0868:  MOV     [W0++],[W4++]
086A:  MOV     926,W0
086C:  CLR     W1
086E:  BTSC    W0.F
0870:  SETM    W1
0872:  MOV     W0,W2
0874:  MOV     W1,W3
0876:  MOV     W6,W0
0878:  MOV     W7,W1
087A:  CALL    7AC
087E:  MOV     #0,W4
0880:  MOV     [W4++],[W5++]
0882:  MOV     [W4++],[W5++]
....................       if( reference[i] > 0)
0884:  MOV     B44,W4
0886:  MUL.UU  W4,#4,W0
0888:  MOV     #928,W4
088A:  ADD     W0,W4,W0
088C:  MOV     #A,W4
088E:  MOV     [W0++],[W4++]
0890:  MOV     [W0++],[W4++]
0892:  CP      W6,#0
0894:  BRA     LT,8C2
0896:  BRA     GT,89C
0898:  CP      W5,#0
089A:  BRA     LEU,8C2
....................       {
....................          reference[i] = reference[i] >> 8; 
089C:  MOV     B44,W4
089E:  MUL.UU  W4,#4,W0
08A0:  MOV     #928,W4
08A2:  ADD     W0,W4,W5
08A4:  MOV     B44,W4
08A6:  MUL.UU  W4,#4,W0
08A8:  MOV     #928,W4
08AA:  ADD     W0,W4,W0
08AC:  MOV     #C,W4
08AE:  MOV     [W0++],[W4++]
08B0:  MOV     [W0++],[W4++]
08B2:  MOV.B   D,W0L
08B4:  MOV.B   W0L,[W5]
08B6:  MOV.B   W7L,[W5+#1]
08B8:  MOV.B   F,W0L
08BA:  MOV.B   W0L,[W5+#2]
08BC:  MOV.B   #0,W0L
08BE:  MOV.B   W0L,[W5+#3]
....................       }
08C0:  BRA     93E
....................       else if( reference[i] < 0)
08C2:  MOV     B44,W4
08C4:  MUL.UU  W4,#4,W0
08C6:  MOV     #928,W4
08C8:  ADD     W0,W4,W0
08CA:  MOV     #A,W4
08CC:  MOV     [W0++],[W4++]
08CE:  MOV     [W0++],[W4++]
08D0:  CP      W6,#0
08D2:  BRA     GT,93E
08D4:  BRA     LT,8DA
08D6:  CP      W5,#0
08D8:  BRA     C,93E
....................       {
....................          reference[i] = 0 - reference[i];
08DA:  MOV     B44,W4
08DC:  MUL.UU  W4,#4,W0
08DE:  MOV     #928,W4
08E0:  ADD     W0,W4,W5
08E2:  MOV     B44,W4
08E4:  MUL.UU  W4,#4,W0
08E6:  MOV     #928,W4
08E8:  ADD     W0,W4,W0
08EA:  MOV     W0,W4
08EC:  MOV     #0,W3
08EE:  MOV     [W4++],[W3++]
08F0:  MOV     [W4++],[W3++]
08F2:  MOV     #0,W4
08F4:  SUB     W4,W0,[W5]
08F6:  MOV     #0,W4
08F8:  SUBB    W4,W1,[++W5]
....................          reference[i] = reference[i] >> 8;
08FA:  MOV     B44,W4
08FC:  MUL.UU  W4,#4,W0
08FE:  MOV     #928,W4
0900:  ADD     W0,W4,W5
0902:  MOV     B44,W4
0904:  MUL.UU  W4,#4,W0
0906:  MOV     #928,W4
0908:  ADD     W0,W4,W0
090A:  MOV     #C,W4
090C:  MOV     [W0++],[W4++]
090E:  MOV     [W0++],[W4++]
0910:  MOV.B   D,W0L
0912:  MOV.B   W0L,[W5]
0914:  MOV.B   W7L,[W5+#1]
0916:  MOV.B   F,W0L
0918:  MOV.B   W0L,[W5+#2]
091A:  MOV.B   #0,W0L
091C:  MOV.B   W0L,[W5+#3]
....................          reference[i] = 0 - reference[i];
091E:  MOV     B44,W4
0920:  MUL.UU  W4,#4,W0
0922:  MOV     #928,W4
0924:  ADD     W0,W4,W5
0926:  MOV     B44,W4
0928:  MUL.UU  W4,#4,W0
092A:  MOV     #928,W4
092C:  ADD     W0,W4,W0
092E:  MOV     W0,W4
0930:  MOV     #0,W3
0932:  MOV     [W4++],[W3++]
0934:  MOV     [W4++],[W3++]
0936:  MOV     #0,W4
0938:  SUB     W4,W0,[W5]
093A:  MOV     #0,W4
093C:  SUBB    W4,W1,[++W5]
....................       }
....................       
....................       reference[i] = reference[i] + voltage_offset;
093E:  MOV     B44,W4
0940:  MUL.UU  W4,#4,W0
0942:  MOV     #928,W4
0944:  ADD     W0,W4,W5
0946:  MOV     B44,W4
0948:  MUL.UU  W4,#4,W0
094A:  MOV     #928,W4
094C:  ADD     W0,W4,W0
094E:  MOV     #C,W4
0950:  MOV     [W0++],[W4++]
0952:  MOV     [W0++],[W4++]
0954:  MOV     #3E8,W4
0956:  ADD     W6,W4,[W5]
0958:  ADDC    W7,#0,[++W5]
....................       if(reference[i] > high_duty_limit )
095A:  MOV     B44,W4
095C:  MUL.UU  W4,#4,W0
095E:  MOV     #928,W4
0960:  ADD     W0,W4,W0
0962:  MOV     #A,W4
0964:  MOV     [W0++],[W4++]
0966:  MOV     [W0++],[W4++]
0968:  CP      W6,#0
096A:  BRA     LT,98C
096C:  BRA     GT,974
096E:  MOV     #79E,W4
0970:  CP      W4,W5
0972:  BRA     C,98C
....................       { 
....................          reference[i] = high_duty_limit;
0974:  MOV     B44,W4
0976:  MUL.UU  W4,#4,W0
0978:  MOV     #928,W4
097A:  ADD     W0,W4,W5
097C:  MOV.B   #9E,W0L
097E:  MOV.B   W0L,[W5]
0980:  MOV.B   #7,W0L
0982:  MOV.B   W0L,[W5+#1]
0984:  MOV.B   #0,W0L
0986:  MOV.B   W0L,[W5+#2]
0988:  MOV.B   #0,W0L
098A:  MOV.B   W0L,[W5+#3]
....................       }
....................       if(reference[i] < low_duty_limit)
098C:  MOV     B44,W4
098E:  MUL.UU  W4,#4,W0
0990:  MOV     #928,W4
0992:  ADD     W0,W4,W0
0994:  MOV     #A,W4
0996:  MOV     [W0++],[W4++]
0998:  MOV     [W0++],[W4++]
099A:  CP      W6,#0
099C:  BRA     GT,9BE
099E:  BRA     LT,9A6
09A0:  MOV     #32,W4
09A2:  CP      W4,W5
09A4:  BRA     LEU,9BE
....................       { 
....................          reference[i] = low_duty_limit;
09A6:  MOV     B44,W4
09A8:  MUL.UU  W4,#4,W0
09AA:  MOV     #928,W4
09AC:  ADD     W0,W4,W5
09AE:  MOV.B   #32,W0L
09B0:  MOV.B   W0L,[W5]
09B2:  MOV.B   #0,W0L
09B4:  MOV.B   W0L,[W5+#1]
09B6:  MOV.B   #0,W0L
09B8:  MOV.B   W0L,[W5+#2]
09BA:  MOV.B   #0,W0L
09BC:  MOV.B   W0L,[W5+#3]
....................       }
09BE:  INC     0B44
09C0:  BRA     826
....................    }
....................       
....................    duty[0] = reference[0];  
09C2:  PUSH    928
09C4:  POP     91E
....................    duty[1] = reference[1];  
09C6:  PUSH    92C
09C8:  POP     920
....................    duty[2] = reference[2];
09CA:  PUSH    930
09CC:  POP     922
....................    
....................    if (!stop_pwm) 
09CE:  BTSC.B  996.7
09D0:  BRA     9EC
....................    {
....................        *(P1DC1+1) = duty[0]>>8;   *P1DC1 = duty[0]; 
09D2:  MOV.B   91F,W0L
09D4:  MOV.B   W0L,1D7
09D6:  MOV.B   91E,W0L
09D8:  MOV.B   W0L,1D6
....................        *(P1DC2+1) = duty[1]>>8;   *P1DC2 = duty[1];
09DA:  MOV.B   921,W0L
09DC:  MOV.B   W0L,1D9
09DE:  MOV.B   920,W0L
09E0:  MOV.B   W0L,1D8
....................        *(P1DC3+1) = duty[2]>>8;   *P1DC3 = duty[2];
09E2:  MOV.B   923,W0L
09E4:  MOV.B   W0L,1DB
09E6:  MOV.B   922,W0L
09E8:  MOV.B   W0L,1DA
....................    }
09EA:  BRA     9F8
....................    else 
....................    {
....................        *(P1DC1+1) = 0x00;   *P1DC1 = 0x00; 
09EC:  CLR.B   1D7
09EE:  CLR.B   1D6
....................        *(P1DC2+1) = 0x00;   *P1DC2 = 0x00;
09F0:  CLR.B   1D9
09F2:  CLR.B   1D8
....................        *(P1DC3+1) = 0x00;   *P1DC3 = 0x00;
09F4:  CLR.B   1DB
09F6:  CLR.B   1DA
....................    }
....................    
....................    setup_timer2(TMR_INTERNAL | TMR_DIV_BY_1 | TMR_32_BIT , timer_table[freq]); //need to implement on TIM2 register configuration.
09F8:  MOV     984,W0
09FA:  SL      W0,#1,W0
09FC:  CALL    100
0A00:  MOV     W0,W5
0A02:  CLR     110
0A04:  MOV     W5,10C
0A06:  MOV     W6,10E
0A08:  MOV     #8008,W4
0A0A:  MOV     W4,110
.................... 
.................... 
.................... }
.................... 
0A0C:  BCLR.B  84.7
0A0E:  MOV     #1A,W0
0A10:  REPEAT  #C
0A12:  MOV     [--W15],[W0--]
0A14:  MOV     [--W15],W0
0A16:  POP     32
0A18:  POP     36
0A1A:  POP     42
0A1C:  RETFIE  
.................... #INT_TIMER4
.................... void  timer4_isr(void) 
*
0B8A:  PUSH    42
0B8C:  PUSH    36
0B8E:  PUSH    32
0B90:  MOV     W0,[W15++]
0B92:  MOV     #2,W0
0B94:  REPEAT  #C
0B96:  MOV     [W0++],[W15++]
.................... {  
....................    output_bit(LED_PIN , 1);
0B98:  BSET.B  2D1.5
0B9A:  BCLR.B  2CD.5
.................... 
....................    setup_adc_ports(ADC_pin);
0B9C:  MOV     #FFFD,W4
0B9E:  MOV     W4,2A8
0BA0:  CLR     2A2
....................       
....................    set_adc_channel(1);
0BA2:  MOV     #1,W4
0BA4:  MOV     W4,2A6
....................    raw_adc = read_adc();
0BA6:  BCLR.B  2A0.0
0BA8:  BSET.B  2A0.1
0BAA:  BTSS.B  2A0.0
0BAC:  BRA     BAA
0BAE:  PUSH    280
0BB0:  POP     980
....................    output_bit(LED_PIN , 0);
0BB2:  BCLR.B  2D1.5
0BB4:  BCLR.B  2CD.5
....................    
....................    if (raw_adc > 1023)
0BB6:  MOV     980,W4
0BB8:  MOV     #3FF,W3
0BBA:  CP      W3,W4
0BBC:  BRA     C,BC2
....................    {
....................       raw_adc = 1023;
0BBE:  MOV     #3FF,W4
0BC0:  MOV     W4,980
....................    }
....................    raw_adc = raw_adc >> 1;
0BC2:  LSR     980
....................          
....................    
....................   
....................    if (!ch1) 
0BC4:  BTSC.B  996.6
0BC6:  BRA     C1E
....................    {
....................     
....................       setup_adc_ports(current_prob1);
0BC8:  MOV     #FFBF,W4
0BCA:  MOV     W4,2A8
0BCC:  CLR     2A2
....................       set_adc_channel(6);
0BCE:  MOV     #6,W4
0BD0:  MOV     W4,2A6
....................       ADC1_sample = read_adc();
0BD2:  BCLR.B  2A0.0
0BD4:  BSET.B  2A0.1
0BD6:  BTSS.B  2A0.0
0BD8:  BRA     BD6
0BDA:  PUSH    280
0BDC:  POP     A66
.................... 
....................       KALMAN_begin(&filter1_sin1 , &ADC1_sample , &filtered_sin1);
0BDE:  MOV     #A16,W4
0BE0:  MOV     W4,B44
0BE2:  MOV     #A66,W4
0BE4:  MOV     W4,B46
0BE6:  MOV     #A6A,W4
0BE8:  MOV     W4,B48
0BEA:  CALL    A1E
....................       sampled_sin1 = filtered_sin1 - ADC1_sample;
0BEE:  MOV     A6A,W4
0BF0:  MOV     A66,W3
0BF2:  SUB     W4,W3,W0
0BF4:  MOV     W0,A6E
....................       abs_sin1 = abs(sampled_sin1);
0BF6:  MOV     A6E,W0
0BF8:  BTSS    W0.F
0BFA:  BRA     C02
0BFC:  MOV     #0,W4
0BFE:  MOV     A6E,W3
0C00:  SUB     W4,W3,W0
0C02:  MOV     W0,A72
....................       filtered_sin1 = 0;
0C04:  CLR     A6A
....................       KALMAN_begin(&filter2_sin1 , &abs_sin1 , &filtered_sin1);
0C06:  MOV     #A2A,W4
0C08:  MOV     W4,B44
0C0A:  MOV     #A72,W4
0C0C:  MOV     W4,B46
0C0E:  MOV     #A6A,W4
0C10:  MOV     W4,B48
0C12:  CALL    A1E
....................       prob1 = filtered_sin1;
0C16:  PUSH    A6A
0C18:  POP     A76
....................       
....................       ch1 = 1;
0C1A:  BSET.B  996.6
....................    }
0C1C:  BRA     C72
....................    else 
....................    {
....................        
....................       setup_adc_ports(current_prob2);
0C1E:  MOV     #FEFF,W4
0C20:  MOV     W4,2A8
0C22:  CLR     2A2
....................       set_adc_channel(8);
0C24:  MOV     #8,W4
0C26:  MOV     W4,2A6
....................       ADC2_sample = read_adc();
0C28:  BCLR.B  2A0.0
0C2A:  BSET.B  2A0.1
0C2C:  BTSS.B  2A0.0
0C2E:  BRA     C2C
0C30:  PUSH    280
0C32:  POP     A68
.................... 
....................       KALMAN_begin(&filter1_sin2 , &ADC2_sample , &filtered_sin2);
0C34:  MOV     #A3E,W4
0C36:  MOV     W4,B44
0C38:  MOV     #A68,W4
0C3A:  MOV     W4,B46
0C3C:  MOV     #A6C,W4
0C3E:  MOV     W4,B48
0C40:  CALL    A1E
....................       sampled_sin2 = filtered_sin2 - ADC2_sample; 
0C44:  MOV     A6C,W4
0C46:  MOV     A68,W3
0C48:  SUB     W4,W3,W0
0C4A:  MOV     W0,A70
....................       abs_sin2 = abs(sampled_sin2); 
0C4C:  MOV     A70,W0
0C4E:  BTSS    W0.F
0C50:  BRA     C58
0C52:  MOV     #0,W4
0C54:  MOV     A70,W3
0C56:  SUB     W4,W3,W0
0C58:  MOV     W0,A74
....................       filtered_sin2 = 0;
0C5A:  CLR     A6C
....................       KALMAN_begin(&filter2_sin2 , &abs_sin2 , &filtered_sin2);
0C5C:  MOV     #A52,W4
0C5E:  MOV     W4,B44
0C60:  MOV     #A74,W4
0C62:  MOV     W4,B46
0C64:  MOV     #A6C,W4
0C66:  MOV     W4,B48
0C68:  CALL    A1E
....................       prob2 = filtered_sin2;
0C6C:  PUSH    A6C
0C6E:  POP     A78
....................       
....................       ch1 = 0;
0C70:  BCLR.B  996.6
....................    
....................    
....................    }
....................    
....................       
0C72:  BCLR.B  86.5
0C74:  MOV     #1A,W0
0C76:  REPEAT  #C
0C78:  MOV     [--W15],[W0--]
0C7A:  MOV     [--W15],W0
0C7C:  POP     32
0C7E:  POP     36
0C80:  POP     42
0C82:  RETFIE  
.................... }
.................... 
....................    
.................... void main()
*
1942:  MOV     #F80,W15
1944:  MOV     #FFF,W0
1946:  MOV     W0,20
1948:  NOP     
194A:  MOV     #4444,W0
194C:  MOV     W0,96
194E:  MOV     #4444,W0
1950:  MOV     W0,A6
1952:  BSET.B  81.7
1954:  MOV     #8000,W4
1956:  MOV     W4,20C
1958:  MOV     #400,W4
195A:  MOV     W4,20E
195C:  MOV     #10,W4
195E:  MOV     W4,214
1960:  CLR     864
1962:  CLR     866
1964:  CLR     864
1966:  CLR     866
1968:  BSET.B  8D.1
196A:  CLR     924
196C:  CLR     926
196E:  CLR     980
1970:  CLR     982
1972:  MOV     #1,W4
1974:  MOV     W4,984
1976:  CLR     986
1978:  CLR     988
197A:  CLR     98A
197C:  CLR     98C
197E:  CLR     98E
1980:  CLR     990
1982:  CLR     992
1984:  CLR     994
1986:  BCLR.B  996.0
1988:  CLR     998
198A:  BCLR.B  996.1
198C:  BCLR.B  996.2
198E:  BCLR.B  996.3
1990:  BCLR.B  996.4
1992:  CLR.B   997
1994:  CLR     99A
1996:  CLR     99C
1998:  CLR     99E
199A:  CLR     9A0
199C:  CLR     A0E
199E:  CLR     A12
19A0:  CLR     A14
19A2:  CLR     A66
19A4:  CLR     A68
19A6:  CLR     A6A
19A8:  CLR     A6C
19AA:  CLR     A6E
19AC:  CLR     A70
19AE:  CLR     A72
19B0:  CLR     A74
19B2:  CLR     A76
19B4:  CLR     A78
19B6:  MOV.B   #20,W0L
19B8:  MOV.B   W0L,A7A
19BA:  MOV.B   #20,W0L
19BC:  MOV.B   W0L,A7B
19BE:  BCLR.B  996.6
19C0:  BCLR.B  996.7
19C2:  CLR     A7C
19C4:  SETM    2A8
19C6:  BCLR.B  996.5
19C8:  BRA     1A6A
19CA:  DATA    C0,06,08
19CC:  DATA    68,00,00
19CE:  DATA    4B,F0,3F
19D0:  DATA    5C,0A,58
19D2:  DATA    F6,3B,8F
19D4:  DATA    00,C0,3C
19D6:  DATA    8B,28,AC
19D8:  DATA    3C,BE,F6
19DA:  DATA    3F,D2,D5
19DC:  DATA    44,16,8C
19DE:  DATA    15,D7,BF
19E0:  DATA    69,00,5A
19E2:  DATA    2E,1B,87
19E4:  DATA    99,3F,9A
19E6:  DATA    5F,AD,4B
19E8:  DATA    91,E4,01
19EA:  DATA    C0,5D,11
19EC:  DATA    2F,92,E4
19EE:  DATA    81,FB,3F
19F0:  DATA    38,DA,91
19F2:  DATA    80,9D,C5
19F4:  DATA    E0,BF,6F
19F6:  DATA    12,C0,B4
19F8:  DATA    C3,09,AB
19FA:  DATA    3F,6B,C1
19FC:  DATA    03,4E,C1
19FE:  DATA    B5,45,BF
1A00:  DATA    F7,40,05
1A02:  DATA    FF,00,5C
1A04:  DATA    EF,3F,F3
1A06:  DATA    A3,E2,F7
1A08:  DATA    D7,FF,01
1A0A:  DATA    40,C0,B4
1A0C:  DATA    FF,05,3C
1A0E:  DATA    58,FC,3F
1A10:  DATA    3B,D3,C0
1A12:  DATA    B5,BA,8C
1A14:  DATA    E2,3F,39
1A16:  DATA    D3,C7,3D
1A18:  DATA    41,79,B2
1A1A:  DATA    3F,87,0D
1A1C:  DATA    3C,50,D0
1A1E:  DATA    AF,62,3F
1A20:  DATA    30,4B,8D
1A22:  DATA    A2,82,AA
1A24:  DATA    04,40,09
1A26:  DATA    A0,40,4A
1A28:  DATA    05,76,03
1A2A:  DATA    40,EC,9E
1A2C:  DATA    37,88,A6
1A2E:  DATA    44,F0,3F
1A30:  DATA    8F,12,8D
1A32:  DATA    29,9A,5B
1A34:  DATA    C7,3F,0E
1A36:  DATA    E0,80,7C
1A38:  DATA    A1,D8,86
1A3A:  DATA    3F,29,4B
1A3C:  DATA    FB,95,C2
1A3E:  DATA    37,1A,3F
1A40:  DATA    00,00,C0
1A42:  DATA    06,09,1E
1A44:  DATA    00,C0,0C
1A46:  DATA    09,28,00
1A48:  DATA    C0,06,09
1A4A:  DATA    72,00,00
1A4C:  DATA    00,00,00
1A4E:  INC     W2,W2
1A50:  CP      W2,#1
1A52:  BRA     NZ,1A5C
1A54:  TBLRDL  [W1],W3
1A56:  TBLRDH  [W1++],W4
1A58:  MOV.B   6,W0L
1A5A:  RETURN  
1A5C:  CP      W2,#2
1A5E:  BRA     NZ,1A64
1A60:  MOV.B   7,W0L
1A62:  RETURN  
1A64:  MOV.B   8,W0L
1A66:  CLR     W2
1A68:  RETURN  
1A6A:  MOV     #0,W6
1A6C:  MOV     #0,W0
1A6E:  MOV     W0,32
1A70:  MOV     #19CA,W0
1A72:  MOV     W0,W1
1A74:  CLR     W2
1A76:  CALL    1A4E
1A7A:  MOV.B   W0L,B
1A7C:  CALL    1A4E
1A80:  MOV.B   W0L,A
1A82:  CP0     W5
1A84:  BRA     Z,1AB8
1A86:  BTSS    W5.F
1A88:  BRA     1A98
1A8A:  CALL    1A4E
1A8E:  MOV.B   W0L,D
1A90:  CALL    1A4E
1A94:  MOV.B   W0L,C
1A96:  BCLR    W5.F
1A98:  BTSS    W5.E
1A9A:  BRA     1AAC
1A9C:  BCLR    W5.E
1A9E:  DEC     W5,W5
1AA0:  CALL    1A4E
1AA4:  MOV.B   W0L,W7L
1AA6:  REPEAT  W5
1AA8:  MOV.B   W7L,[W6++]
1AAA:  BRA     1A76
1AAC:  CALL    1A4E
1AB0:  MOV.B   W0L,[W6++]
1AB2:  DEC     W5,W5
1AB4:  BRA     NZ,1AAC
1AB6:  BRA     1A76
.................... { 
....................    KALMAN_init(&filter1_sin1 , KALMAN_UP_1 , KALMAN_DOWN_1);
1AB8:  MOV     #A16,W4
1ABA:  MOV     W4,A7E
1ABC:  MOV     #7,W4
1ABE:  MOV     W4,A80
1AC0:  CLR     A82
1AC2:  MOV     #5,W4
1AC4:  MOV     W4,A84
1AC6:  CLR     A86
1AC8:  CALL    C84
....................    KALMAN_init(&filter2_sin1 , KALMAN_UP_2 , KALMAN_DOWN_2);
1ACC:  MOV     #A2A,W4
1ACE:  MOV     W4,A7E
1AD0:  MOV     #8,W4
1AD2:  MOV     W4,A80
1AD4:  CLR     A82
1AD6:  MOV     #5,W4
1AD8:  MOV     W4,A84
1ADA:  CLR     A86
1ADC:  CALL    C84
....................    
....................    KALMAN_init(&filter1_sin2 , KALMAN_UP_1 , KALMAN_DOWN_1);
1AE0:  MOV     #A3E,W4
1AE2:  MOV     W4,A7E
1AE4:  MOV     #7,W4
1AE6:  MOV     W4,A80
1AE8:  CLR     A82
1AEA:  MOV     #5,W4
1AEC:  MOV     W4,A84
1AEE:  CLR     A86
1AF0:  CALL    C84
....................    KALMAN_init(&filter2_sin2 , KALMAN_UP_2 , KALMAN_DOWN_2);
1AF4:  MOV     #A52,W4
1AF6:  MOV     W4,A7E
1AF8:  MOV     #8,W4
1AFA:  MOV     W4,A80
1AFC:  CLR     A82
1AFE:  MOV     #5,W4
1B00:  MOV     W4,A84
1B02:  CLR     A86
1B04:  CALL    C84
....................    
.................... 
....................    *U1BRG = 8;    // setting uart baudrate to 115200.
1B08:  MOV.B   #8,W0L
1B0A:  MOV.B   W0L,214
....................    
....................    sprintf(Serial_OutputBuffer, "\nMotor Control Unit v0.1\r\n");
1B0C:  MOV     #9A2,W4
1B0E:  MOV     W4,A7C
1B10:  MOV     #0,W1
1B12:  MOV     W1,W0
1B14:  CLR.B   1
1B16:  CALL    6E4
1B1A:  INC     W1,W1
1B1C:  MOV     W1,[W15++]
1B1E:  MOV     W0,[W15++]
1B20:  MOV     [--W15],W0
1B22:  CALL    CC6
1B26:  MOV     [--W15],W1
1B28:  MOV     #19,W0
1B2A:  CPSGT   W1,W0
1B2C:  BRA     1B12
....................    printf(Serial_OutputBuffer);
1B2E:  MOV     #9A2,W1
1B30:  CP0.B   [W1]
1B32:  BRA     Z,1B42
1B34:  BTSC.B  20F.1
1B36:  BRA     1B34
1B38:  MOV.B   [W1+#0],W0L
1B3A:  MOV.B   W0L,210
1B3C:  CLR.B   211
1B3E:  INC     W1,W1
1B40:  BRA     1B30
....................    
....................    
....................    attained_throttle = 0;
1B42:  CLR     A10
....................    position_capture = 0;
1B44:  CLR     998
....................    freq = 1;
1B46:  MOV     #1,W4
1B48:  MOV     W4,984
....................     
....................    initMCPWM();
1B4A:  CALL    CD4
....................    fill_sine_table();
1B4E:  CALL    15C0
.................... 
....................    output_drive(LED_PIN);
1B52:  BCLR.B  2CD.5
....................    output_drive(TICK_PIN);
1B54:  BCLR.B  2C6.0
.................... 
....................    setup_adc(ADC_CLOCK_DIV_2 | ADC_TAD_MUL_16);
1B56:  MOV     #1001,W4
1B58:  MOV     W4,2A4
1B5A:  MOV     #80E0,W4
1B5C:  MOV     W4,2A0
....................    
....................    delay_us(10);
1B5E:  REPEAT  #9E
1B60:  NOP     
....................    
....................    setup_qei( QEI_MODE_X2 , QEI_FILTER_DIV_1 ,0);
1B62:  MOV     #400,W4
1B64:  MOV     W4,122
1B66:  CLR     124
1B68:  CLR     128
1B6A:  CLR     126
....................    setup_timer2(TMR_INTERNAL | TMR_DIV_BY_1 | TMR_32_BIT , timer_table[freq]);
1B6C:  MOV     984,W0
1B6E:  SL      W0,#1,W0
1B70:  CALL    100
1B74:  MOV     W0,W5
1B76:  CLR     110
1B78:  MOV     W5,10C
1B7A:  MOV     W6,10E
1B7C:  MOV     #8008,W4
1B7E:  MOV     W4,110
....................    enable_interrupts(INT_TIMER3);   // enable interrupt in timer3 register (in case of 32bit mode) 
1B80:  BSET.B  8C.7
.................... 
....................     // enable interrupt
....................    
....................    setup_timer4(TMR_INTERNAL | TMR_DIV_BY_64 , TIM_FREQ);
1B82:  CLR     11E
1B84:  MOV     #3C,W4
1B86:  MOV     W4,11A
1B88:  MOV     #8020,W4
1B8A:  MOV     W4,11E
....................    enable_interrupts(INT_TIMER4);
1B8C:  BSET.B  8E.5
.................... 
....................    enable_interrupts(INT_PWM1);
1B8E:  BSET.B  90.7
....................    enable_interrupts(INTR_GLOBAL);
1B90:  BCLR.B  81.7
1B92:  CLR     42
1B94:  BSET.B  81.7
....................    
.................... 
....................    while(TRUE)         
....................    {
....................      
....................       if (enc_tick) 
1B96:  BTSS.B  996.3
1B98:  BRA     1C98
....................       {
....................          
....................          throttle_level = raw_adc - 100;
1B9A:  MOV     980,W4
1B9C:  SUB     #64,W4
1B9E:  MOV     W4,982
....................          if (throttle_level > 255)
1BA0:  MOV     982,W4
1BA2:  MOV     #FF,W3
1BA4:  CP      W3,W4
1BA6:  BRA     GE,1BAC
....................          {
....................             throttle_level = 255;
1BA8:  MOV     #FF,W4
1BAA:  MOV     W4,982
....................          }
....................          if (throttle_level < 0)   
1BAC:  MOV     982,W4
1BAE:  CP      W4,#0
1BB0:  BRA     GE,1BB4
....................          {  
....................             throttle_level = 0; 
1BB2:  CLR     982
....................          }
....................  
....................           ascending_speed  = ascend_speed_table[attained_throttle];
1BB4:  MOV     A10,W4
1BB6:  MUL.UU  W4,#2,W0
1BB8:  CALL    3F0
1BBC:  MOV     W0,A06
....................           descending_speed = descend_speed_table[attained_throttle];
1BBE:  MOV     A10,W4
1BC0:  MUL.UU  W4,#2,W0
1BC2:  CALL    56A
1BC6:  MOV     W0,A08
....................           
....................           loaded_val = attained_throttle -1;
1BC8:  MOV     A10,W4
1BCA:  SUB     W4,#1,W0
1BCC:  MOV     W0,A0E
....................           if (loaded_val < 0) 
1BCE:  MOV     A0E,W4
1BD0:  CP      W4,#0
1BD2:  BRA     GE,1BD6
....................           {
....................             loaded_val = 0;
1BD4:  CLR     A0E
....................           
....................           }
....................           loaded_speed = ascend_speed_table[loaded_val];
1BD6:  MOV     A0E,W4
1BD8:  MUL.UU  W4,#2,W0
1BDA:  CALL    3F0
1BDE:  MOV     W0,A0C
....................           
....................           if (!enc_mutx) 
1BE0:  BTSC.B  996.5
1BE2:  BRA     1BE8
....................           {
....................             attained_speed = position_count_new;      // READING ENCODER's SHARED VARIABLE. 
1BE4:  PUSH    992
1BE6:  POP     A0A
....................  
....................           }
....................           
....................           
....................           if (throttle_level > attained_throttle) 
1BE8:  MOV     A10,W0
1BEA:  MOV     982,W4
1BEC:  CP      W4,W0
1BEE:  BRA     LE,1C2A
....................           {
....................             
....................             symb1 = '+';
1BF0:  MOV.B   #2B,W0L
1BF2:  MOV.B   W0L,A7B
....................             if (attained_speed >= ascending_speed)
1BF4:  MOV     A06,W0
1BF6:  MOV     A0A,W4
1BF8:  CP      W4,W0
1BFA:  BRA     NC,1C08
....................             {
....................             
....................                symb = '+';
1BFC:  MOV.B   #2B,W0L
1BFE:  MOV.B   W0L,A7A
....................                attained_throttle++;
1C00:  INC     0A10
....................                throttle_delay = 0;
1C02:  CLR     A12
1C04:  CLR     A14
.................... 
....................             }
1C06:  BRA     1C12
....................             else 
....................             {
....................                symb = '0';
1C08:  MOV.B   #30,W0L
1C0A:  MOV.B   W0L,A7A
....................                throttle_delay++;
1C0C:  INC     0A12
1C0E:  BTSC.B  42.1
1C10:  INC     0A14
....................        
....................             }
....................             
....................             if (attained_speed < loaded_speed) 
1C12:  MOV     A0A,W0
1C14:  MOV     A0C,W4
1C16:  CP      W4,W0
1C18:  BRA     LEU,1C28
....................             {
....................                attained_throttle--;
1C1A:  DEC     0A10
....................                symb = '-';
1C1C:  MOV.B   #2D,W0L
1C1E:  MOV.B   W0L,A7A
....................                if (attained_throttle < 0) 
1C20:  MOV     A10,W4
1C22:  CP      W4,#0
1C24:  BRA     GE,1C28
....................                {
....................                   attained_throttle = 0;
1C26:  CLR     A10
....................                
....................                }
....................                  
....................             }
....................      
....................           }
1C28:  BRA     1C6C
....................           else if(throttle_level < attained_throttle) 
1C2A:  MOV     982,W0
1C2C:  MOV     A10,W4
1C2E:  CP      W4,W0
1C30:  BRA     LE,1C5E
....................           {
....................             symb1 = '-';
1C32:  MOV.B   #2D,W0L
1C34:  MOV.B   W0L,A7B
....................             if (attained_speed <= descending_speed) 
1C36:  MOV     A0A,W0
1C38:  MOV     A08,W4
1C3A:  CP      W4,W0
1C3C:  BRA     NC,1C52
....................             {
....................                attained_throttle--; 
1C3E:  DEC     0A10
....................                throttle_delay = 0;
1C40:  CLR     A12
1C42:  CLR     A14
....................                symb = '-';
1C44:  MOV.B   #2D,W0L
1C46:  MOV.B   W0L,A7A
....................                if (attained_throttle < 0)
1C48:  MOV     A10,W4
1C4A:  CP      W4,#0
1C4C:  BRA     GE,1C50
....................                {
....................                   attained_throttle = 0;
1C4E:  CLR     A10
....................                }
....................          
....................             }
1C50:  BRA     1C5C
....................             else 
....................             {
....................                symb = '0';
1C52:  MOV.B   #30,W0L
1C54:  MOV.B   W0L,A7A
....................                throttle_delay++;
1C56:  INC     0A12
1C58:  BTSC.B  42.1
1C5A:  INC     0A14
....................    
....................             }
....................           
....................           
....................           }
1C5C:  BRA     1C6C
....................           else if (throttle_level == attained_throttle)
1C5E:  MOV     982,W0
1C60:  CP      A10
1C62:  BRA     NZ,1C6C
....................           {
....................                symb1 = '0';
1C64:  MOV.B   #30,W0L
1C66:  MOV.B   W0L,A7B
....................                symb = '0';
1C68:  MOV.B   #30,W0L
1C6A:  MOV.B   W0L,A7A
....................             
....................           }
....................           
.................... 
....................           if (attained_throttle != 0) 
1C6C:  CP0     A10
1C6E:  BRA     Z,1C82
....................           {
....................             freq = attained_throttle;
1C70:  PUSH    A10
1C72:  POP     984
....................             peak_voltage = gain_table[attained_throttle];
1C74:  MOV     A10,W4
1C76:  MUL.UU  W4,#2,W0
1C78:  CALL    278
1C7C:  MOV     W0,926
....................             stop_pwm = 0;
1C7E:  BCLR.B  996.7
....................              
....................           }
1C80:  BRA     1C84
....................           else stop_pwm = 1;
1C82:  BSET.B  996.7
....................           
....................           if (throttle_delay >= 99) 
1C84:  MOV     A14,W4
1C86:  CP      W4,#0
1C88:  BRA     NC,1C98
1C8A:  BRA     GTU,1C94
1C8C:  MOV     A12,W4
1C8E:  MOV     #63,W3
1C90:  CP      W3,W4
1C92:  BRA     GTU,1C98
....................           {
....................             throttle_delay = 0;
1C94:  CLR     A12
1C96:  CLR     A14
....................           
....................           }
....................          
....................        
....................         
.................... //!         tick = 0;  
.................... 
....................         
....................       } 
....................  
....................       if (enc_tick) 
1C98:  BTSS.B  996.3
1C9A:  BRA     1E38
....................       {
....................          
....................          enc_mutx = 1;
1C9C:  BSET.B  996.5
....................          position_count = *(POSCNT +1);
1C9E:  MOV.B   127,W0L
1CA0:  MOV.B   W0L,986
1CA2:  CLR.B   987
1CA4:  CLR     988
....................          position_count = position_count << 8;
1CA6:  MOV.B   988,W0L
1CA8:  MOV.B   W0L,989
1CAA:  MOV.B   987,W0L
1CAC:  MOV.B   W0L,988
1CAE:  MOV.B   986,W0L
1CB0:  MOV.B   W0L,987
1CB2:  CLR.B   986
....................          position_count = position_count | *POSCNT;   
1CB4:  MOV.B   126,W0L
1CB6:  CLR.B   1
1CB8:  IOR     986
....................          
.................... 
....................          direction_flag = QEI_get_direction();
1CBA:  CALL    1688
1CBE:  BCLR.B  996.0
1CC0:  BTSC.B  0.0
1CC2:  BSET.B  996.0
.................... 
....................          enc_count = position_count - prev_count;
1CC4:  MOV     986,W4
1CC6:  MOV     98A,W3
1CC8:  SUB     W4,W3,W0
1CCA:  MOV     W0,98E
1CCC:  MOV     988,W4
1CCE:  MOV     98C,W3
1CD0:  SUBB    W4,W3,W0
1CD2:  MOV     W0,990
....................      
....................          if (direction_flag == 1 && enc_count < 0) 
1CD4:  BTSS.B  996.0
1CD6:  BRA     1CF4
1CD8:  MOV     990,W4
1CDA:  CP      W4,#0
1CDC:  BRA     GT,1CF4
1CDE:  BRA     LT,1CE6
1CE0:  MOV     98E,W4
1CE2:  CP      W4,#0
1CE4:  BRA     C,1CF4
....................          {
....................             enc_count = enc_count + TIM_OVERFLOW_VAL ;
1CE6:  MOV     #FFFF,W4
1CE8:  MOV     98E,W3
1CEA:  ADD     W3,W4,W0
1CEC:  MOV     W0,98E
1CEE:  MOV     990,W4
1CF0:  ADDC    W4,#0,W0
1CF2:  MOV     W0,990
.................... 
....................          }
.................... 
....................          if (direction_flag == 0 && enc_count > 0)   
1CF4:  BTSC.B  996.0
1CF6:  BRA     1D14
1CF8:  MOV     990,W4
1CFA:  CP      W4,#0
1CFC:  BRA     LT,1D14
1CFE:  BRA     GT,1D06
1D00:  MOV     98E,W4
1D02:  CP      W4,#0
1D04:  BRA     LEU,1D14
....................          {
....................             enc_count = enc_count - TIM_OVERFLOW_VAL ;
1D06:  MOV     98E,W4
1D08:  MOV     #FFFF,W3
1D0A:  SUB     W4,W3,W0
1D0C:  MOV     W0,98E
1D0E:  MOV     990,W4
1D10:  SUBB    W4,#0,W0
1D12:  MOV     W0,990
....................          }
....................    
....................          enc_count = abs(enc_count);
1D14:  MOV     98E,W0
1D16:  MOV     990,W1
1D18:  BTSS    W1.F
1D1A:  BRA     1D28
1D1C:  MOV     #0,W4
1D1E:  MOV     98E,W3
1D20:  SUB     W4,W3,W0
1D22:  MOV     #0,W4
1D24:  MOV     990,W3
1D26:  SUBB    W4,W3,W1
1D28:  MOV     W0,98E
1D2A:  MOV     W1,990
....................          enc_count = enc_count >> 1;
1D2C:  LSR     990
1D2E:  RRC     98E
....................          prev_count = position_count;           
1D30:  PUSH    986
1D32:  POP     98A
1D34:  PUSH    988
1D36:  POP     98C
....................          position_count_new = enc_count;
1D38:  PUSH    98E
1D3A:  POP     992
1D3C:  PUSH    990
1D3E:  POP     994
....................         
....................          sprintf(Serial_OutputBuffer, "\r\n%03d,%03d,%03d,%03d,%03d,%03d,%03d : %02d,%02d : %c , %c , %02d" ,
....................          raw_adc , throttle_level , attained_throttle,  attained_speed , ascending_speed, descending_speed , loaded_speed , prob1,prob2 , 
....................          symb1 , symb ,throttle_delay);
1D40:  MOV     #9A2,W4
1D42:  MOV     W4,A7C
1D44:  MOV.B   #D,W0L
1D46:  CALL    CC6
1D4A:  MOV.B   #A,W0L
1D4C:  CALL    CC6
1D50:  MOV     980,W0
1D52:  MOV     #8003,W4
1D54:  CALL    1696
1D58:  MOV.B   #2C,W0L
1D5A:  CALL    CC6
1D5E:  MOV     982,W0
1D60:  MOV     #8003,W4
1D62:  CALL    1696
1D66:  MOV.B   #2C,W0L
1D68:  CALL    CC6
1D6C:  MOV     A10,W0
1D6E:  MOV     #8003,W4
1D70:  CALL    1696
1D74:  MOV.B   #2C,W0L
1D76:  CALL    CC6
1D7A:  MOV     A0A,W0
1D7C:  MOV     #8003,W4
1D7E:  CALL    1696
1D82:  MOV.B   #2C,W0L
1D84:  CALL    CC6
1D88:  MOV     A06,W0
1D8A:  MOV     #8003,W4
1D8C:  CALL    1696
1D90:  MOV.B   #2C,W0L
1D92:  CALL    CC6
1D96:  MOV     A08,W0
1D98:  MOV     #8003,W4
1D9A:  CALL    1696
1D9E:  MOV.B   #2C,W0L
1DA0:  CALL    CC6
1DA4:  MOV     A0C,W0
1DA6:  MOV     #8003,W4
1DA8:  CALL    1696
1DAC:  MOV.B   #20,W0L
1DAE:  CALL    CC6
1DB2:  MOV.B   #3A,W0L
1DB4:  CALL    CC6
1DB8:  MOV.B   #20,W0L
1DBA:  CALL    CC6
1DBE:  MOV     A76,W0
1DC0:  MOV     #8002,W4
1DC2:  CALL    1696
1DC6:  MOV.B   #2C,W0L
1DC8:  CALL    CC6
1DCC:  MOV     A78,W0
1DCE:  MOV     #8002,W4
1DD0:  CALL    1696
1DD4:  MOV.B   #20,W0L
1DD6:  CALL    CC6
1DDA:  MOV.B   #3A,W0L
1DDC:  CALL    CC6
1DE0:  MOV.B   #20,W0L
1DE2:  CALL    CC6
1DE6:  MOV.B   A7B,W0L
1DE8:  CALL    CC6
1DEC:  MOV.B   #20,W0L
1DEE:  CALL    CC6
1DF2:  MOV.B   #2C,W0L
1DF4:  CALL    CC6
1DF8:  MOV.B   #20,W0L
1DFA:  CALL    CC6
1DFE:  MOV.B   A7A,W0L
1E00:  CALL    CC6
1E04:  MOV.B   #20,W0L
1E06:  CALL    CC6
1E0A:  MOV.B   #2C,W0L
1E0C:  CALL    CC6
1E10:  MOV.B   #20,W0L
1E12:  CALL    CC6
1E16:  MOV     A12,W0
1E18:  MOV     A14,W1
1E1A:  MOV     #8002,W4
1E1C:  CALL    180A
....................          printf(Serial_OutputBuffer);
1E20:  MOV     #9A2,W1
1E22:  CP0.B   [W1]
1E24:  BRA     Z,1E34
1E26:  BTSC.B  20F.1
1E28:  BRA     1E26
1E2A:  MOV.B   [W1+#0],W0L
1E2C:  MOV.B   W0L,210
1E2E:  CLR.B   211
1E30:  INC     W1,W1
1E32:  BRA     1E22
.................... 
....................          enc_mutx = 0;
1E34:  BCLR.B  996.5
....................          enc_tick = 0;
1E36:  BCLR.B  996.3
....................        
....................   
....................   
....................       }
1E38:  BRA     1B96
....................     } 
.................... }    
.................... 
1E3A:  PWRSAV  #0
.................... 
.................... void initMCPWM(void) 
.................... {    
....................    *(P1TCON+1)  =  0x80;  *P1TCON =  0x02;
*
0CD4:  MOV.B   #80,W0L
0CD6:  MOV.B   W0L,1C1
0CD8:  MOV.B   #2,W0L
0CDA:  MOV.B   W0L,1C0
....................    *(P1TPER+1)  =  0x03;  *P1TPER =  0xE7;  
0CDC:  MOV.B   #3,W0L
0CDE:  MOV.B   W0L,1C5
0CE0:  MOV.B   #E7,W0L
0CE2:  MOV.B   W0L,1C4
....................    *(P1SECMP+1) =  0x00;  *P1SECMP=  0x01; //
0CE4:  CLR.B   1C7
0CE6:  MOV.B   #1,W0L
0CE8:  MOV.B   W0L,1C6
....................    *(PWM1CON1+1)=  0x00;  *PWM1CON1= 0x77;  
0CEA:  CLR.B   1C9
0CEC:  MOV.B   #77,W0L
0CEE:  MOV.B   W0L,1C8
....................    *(PWM1CON2+1)=  0x00;  *PWM1CON2= 0x02;
0CF0:  CLR.B   1CB
0CF2:  MOV.B   #2,W0L
0CF4:  MOV.B   W0L,1CA
....................    *(P1DTCON1+1)=  0x00;  *P1DTCON1= 0x10; //0x09
0CF6:  CLR.B   1CD
0CF8:  MOV.B   #10,W0L
0CFA:  MOV.B   W0L,1CC
....................    *(P1DTCON2+1)=  0x00;  *P1DTCON2= 0x00;
0CFC:  CLR.B   1CF
0CFE:  CLR.B   1CE
....................    *(P1FLTACON+1)= 0x00;  *P1FLTACON=0x00; //0x0000
0D00:  CLR.B   1D1
0D02:  CLR.B   1D0
....................    *(P1OVDCON+1)=  0x3F;  *P1OVDCON= 0x0F;
0D04:  MOV.B   #3F,W0L
0D06:  MOV.B   W0L,1D5
0D08:  MOV.B   #F,W0L
0D0A:  MOV.B   W0L,1D4
....................    
....................    *(P1DC1+1) = duty[0]>>8;   *P1DC1 = duty[0]; 
0D0C:  MOV.B   91F,W0L
0D0E:  MOV.B   W0L,1D7
0D10:  MOV.B   91E,W0L
0D12:  MOV.B   W0L,1D6
....................    *(P1DC2+1) = duty[1]>>8;   *P1DC2 = duty[1];
0D14:  MOV.B   921,W0L
0D16:  MOV.B   W0L,1D9
0D18:  MOV.B   920,W0L
0D1A:  MOV.B   W0L,1D8
....................    *(P1DC3+1) = duty[2]>>8;   *P1DC3 = duty[2];  
0D1C:  MOV.B   923,W0L
0D1E:  MOV.B   W0L,1DB
0D20:  MOV.B   922,W0L
0D22:  MOV.B   W0L,1DA
....................    *(IPC14+1) =0x00;*(IPC14) =0x70;
0D24:  CLR.B   C1
0D26:  MOV.B   #70,W0L
0D28:  MOV.B   W0L,C0
0D2A:  RETURN  
.................... }
.................... 
.................... 
....................    
.................... void fill_sine_table(void)
*
15C0:  MOV     W5,[W15++]
15C2:  MOV     W6,[W15++]
15C4:  MOV     W7,[W15++]
15C6:  MOV     W8,[W15++]
.................... {
....................    for(sine_index=0;sine_index < max_samples;sine_index++)  
15C8:  CLR     970
15CA:  MOV     970,W4
15CC:  CP      W4,#1E
15CE:  BRA     C,167E
....................    {
....................       theeta=sine_index*2.0*PI/max_samples;
15D0:  MOV     970,W0
15D2:  MOV     #0,W1
15D4:  MOV     #0,W2
15D6:  MOV     #0,W3
15D8:  CALL    D2C
15DC:  MOV     #0,W4
15DE:  MOV     #0,W5
15E0:  MOV     #0,W6
15E2:  MOV     #4000,W7
15E4:  CALL    D96
15E8:  MOV     W0,W5
15EA:  MOV     W1,W6
15EC:  MOV     W2,W7
15EE:  MOV     W3,W8
15F0:  MOV     W5,[W15++]
15F2:  MOV     W6,[W15++]
15F4:  MOV     W7,[W15++]
15F6:  MOV     W5,W0
15F8:  MOV     W6,W1
15FA:  MOV     W7,W2
15FC:  MOV     W8,W3
15FE:  MOV     #2D18,W4
1600:  MOV     #5444,W5
1602:  MOV     #21FB,W6
1604:  MOV     #4009,W7
1606:  CALL    D96
160A:  MOV     [--W15],W7
160C:  MOV     [--W15],W6
160E:  MOV     [--W15],W5
1610:  MOV     W0,W5
1612:  MOV     W1,W6
1614:  MOV     W2,W7
1616:  MOV     W3,W8
1618:  MOV     W5,[W15++]
161A:  MOV     W6,[W15++]
161C:  MOV     W7,[W15++]
161E:  MOV     W5,W0
1620:  MOV     W6,W1
1622:  MOV     W7,W2
1624:  MOV     W8,W3
1626:  MOV     #0,W4
1628:  MOV     #0,W5
162A:  MOV     #0,W6
162C:  MOV     #403E,W7
162E:  CALL    EA6
1632:  MOV     [--W15],W7
1634:  MOV     [--W15],W6
1636:  MOV     [--W15],W5
1638:  MOV     W0,978
163A:  MOV     W1,97A
163C:  MOV     W2,97C
163E:  MOV     W3,97E
....................       sine_table[sine_index]=255*sin(theeta);
1640:  MOV     970,W0
1642:  SL      W0,#1,W0
1644:  MOV     #934,W4
1646:  ADD     W0,W4,W5
1648:  PUSH    978
164A:  POP     A82
164C:  PUSH    97A
164E:  POP     A84
1650:  PUSH    97C
1652:  POP     A86
1654:  PUSH    97E
1656:  POP     A88
1658:  CALL    1526
165C:  MOV     W5,[W15++]
165E:  MOV     W0,W4
1660:  MOV     W1,W5
1662:  MOV     W2,W6
1664:  MOV     W3,W7
1666:  MOV     #0,W0
1668:  MOV     #0,W1
166A:  MOV     #E000,W2
166C:  MOV     #406F,W3
166E:  CALL    D96
1672:  MOV     [--W15],W5
1674:  CALL    1562
1678:  MOV     W0,[W5]
167A:  INC     0970
167C:  BRA     15CA
....................    }
167E:  MOV     [--W15],W8
1680:  MOV     [--W15],W7
1682:  MOV     [--W15],W6
1684:  MOV     [--W15],W5
1686:  RETURN  
.................... }
.................... 
.................... int1 QEI_get_direction(void) 
.................... {
....................    if (*(QEICON +1) & (1 << UPDN)) return 1;
1688:  BTSS.B  123.3
168A:  BRA     1692
168C:  MOV.B   #1,W0L
168E:  MOV.B   W0L,0
1690:  BRA     1694
....................    
....................    return 0;
1692:  CLR.B   0
1694:  RETURN  
.................... 
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
....................   
....................    
.................... 
.................... 
.................... 
.................... //-----------------IMPLEMENATION REQUIRED--------------//
.................... 
.................... //==========RESPONSE ON BREAK INPUT===========
.................... // DRIVE PWM TO 0 ON BREAK INPUT...
.................... 
.................... 
.................... //=========INPUT FREQUENCY VS MOTOR SPEED DIFFERENCE CALCULATION====
.................... /*
....................    speed  = (freq_table[throttle_level] * 120) / poles
....................    enc_freq = (speed * 64) / 60
....................    
....................    slip = motor_enc_freq - enc_freq;
....................    
.................... */
.................... /*
.................... ==========FOLLOW UP MOTOR SPEED ALGORITHM===========
.................... - sending throttle value from serial.
.................... - is speed_table[throttle_level] == motor_enc
.................... - if yes go to next speed value.
.................... 
.................... if (current_speed != set_speed && current_speed == next_speed)
....................          {
....................             next_speed++;
....................             throttle_level++;
....................             prev_speed = current_speed;
....................          }
....................          
....................          if (current_speed <= prev_speed)
....................          {
....................             // speed is decreasing.
....................             prev_speed = current_speed;
....................             
....................          }
....................          
....................          
....................          //!             if (attained_speed < loaded_speed) 
.................... //!             {
.................... //!               position_capture = attained_speed;
.................... //!               descend_flag = 1;
.................... //!                attained_throttle--; 
.................... //!                if (attained_throttle < 20)
.................... //!                {
.................... //!                   attained_throttle = 20;
.................... //!                }
.................... //!             }
.................... //!             else {descend_flag = 0;}
.................... 
.................... //-----------drive test code--------//
....................       if (drive_inc) 
....................       {
.................... 
....................          
....................          attained_throttle++;
....................          if (attained_throttle > 255)
....................          {
....................             attained_throttle = 255;
....................          }
....................          if (attained_throttle < 0)   
....................          {  
....................             attained_throttle = 0; 
....................          }
....................          freq = attained_throttle;
....................          peak_voltage = gain_table[attained_throttle];
.................... 
....................          drive_inc = 0;
....................       }
....................       
....................       //!   if (sec_tick >= 1000) 
.................... //!   {
.................... //!      drive_inc = 1;
.................... //!      sec_tick = 0;
.................... //!   
.................... //!   }
.................... 
....................    // printing tables//
....................    for (int i = 0 ;i <= 255; i++) 
....................    {  
....................       sprintf(Serial_OutputBuffer , "[%d] : %d\n" , i , ascend_speed_table[i]);
....................       printf(Serial_OutputBuffer);
....................    }
....................   
....................  
.................... */
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
....................   

Configuration Fuses:
   Word  1L: 0306   XT_PLL8 PR CKSFSM
          H: 0000  
   Word  2L: 003F   WPSB16 WPSA512 NOWDT
          H: 0000  
   Word  3L: 8793   PUT64 BORV42 BROWNOUT LPOL_HIGH HPOL_HIGH NOPWMPIN MCLR
          H: 0000  
   Word  4L: 310F  
          H: 0000  
   Word  5L: 330F  
          H: 0000  
   Word  6L: 0004   WRT PROTECT
          H: 0000  
   Word  7L: C003   ICSP1 NODEBUG
          H: 0000  
